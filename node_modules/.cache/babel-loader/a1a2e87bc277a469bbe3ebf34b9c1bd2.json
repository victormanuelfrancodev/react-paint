{"ast":null,"code":"!function (t, e) {\n  if (\"object\" == typeof exports && \"object\" == typeof module) module.exports = e(require(\"jsdom\"));else if (\"function\" == typeof define && define.amd) define([\"jsdom\"], e);else {\n    var i = \"object\" == typeof exports ? e(require(\"jsdom\")) : e(t.jsdom);\n\n    for (var r in i) {\n      (\"object\" == typeof exports ? exports : t)[r] = i[r];\n    }\n  }\n}(window, function (f) {\n  return function (t) {\n    var e = {};\n\n    function i(r) {\n      if (e[r]) return e[r].exports;\n      var n = e[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return t[r].call(n.exports, n, n.exports, i), n.l = !0, n.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, r) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: r\n      });\n    }, i.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.t = function (t, e) {\n      if (1 & e && (t = i(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var r = Object.create(null);\n      if (i.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var n in t) {\n        i.d(r, n, function (e) {\n          return t[e];\n        }.bind(null, n));\n      }\n      return r;\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 28);\n  }([function (t, e, i) {\n    t.exports = i(17)();\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    };\n  }, function (t, e) {\n    function i(t, e) {\n      for (var i = 0; i < e.length; i++) {\n        var r = e[i];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n      }\n    }\n\n    t.exports = function (t, e, r) {\n      return e && i(t.prototype, e), r && i(t, r), t;\n    };\n  }, function (t, e, i) {\n    var r = i(12),\n        n = i(13);\n\n    t.exports = function (t, e) {\n      return !e || \"object\" !== r(e) && \"function\" != typeof e ? n(t) : e;\n    };\n  }, function (t, e) {\n    function i(e) {\n      return t.exports = i = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      }, i(e);\n    }\n\n    t.exports = i;\n  }, function (t, e, i) {\n    var r = i(14);\n\n    t.exports = function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && r(t, e);\n    };\n  }, function (t, e, i) {\n    (function (t) {\n      /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */\n      var r,\n          n,\n          o,\n          s,\n          a,\n          h,\n          c,\n          l,\n          u,\n          f,\n          d,\n          g,\n          p,\n          v,\n          m,\n          y,\n          _,\n          b,\n          x,\n          C,\n          S,\n          w,\n          T,\n          O,\n          E,\n          k,\n          P,\n          A = A || {\n        version: \"2.4.3\"\n      };\n\n      function D(t, e) {\n        var i = t.canvas,\n            r = e.targetCanvas,\n            n = r.getContext(\"2d\");\n        n.translate(0, r.height), n.scale(1, -1);\n        var o = i.height - r.height;\n        n.drawImage(i, 0, o, r.width, r.height, 0, 0, r.width, r.height);\n      }\n\n      function j(t, e) {\n        var i = e.targetCanvas.getContext(\"2d\"),\n            r = e.destinationWidth,\n            n = e.destinationHeight,\n            o = r * n * 4,\n            s = new Uint8Array(this.imageBuffer, 0, o),\n            a = new Uint8ClampedArray(this.imageBuffer, 0, o);\n        t.readPixels(0, 0, r, n, t.RGBA, t.UNSIGNED_BYTE, s);\n        var h = new ImageData(a, r, n);\n        i.putImageData(h, 0, 0);\n      }\n\n      e.fabric = A, \"undefined\" != typeof document && \"undefined\" != typeof window ? (A.document = document, A.window = window) : (A.document = i(24).jsdom(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n          FetchExternalResources: [\"img\"]\n        }\n      }), A.jsdomImplForWrapper = i(25).implForWrapper, A.nodeCanvas = i(26).Canvas, A.window = A.document.defaultView, DOMParser = i(27).DOMParser), A.isTouchSupported = \"ontouchstart\" in A.window, A.isLikelyNode = void 0 !== t && \"undefined\" == typeof window, A.SHARED_ATTRIBUTES = [\"display\", \"transform\", \"fill\", \"fill-opacity\", \"fill-rule\", \"opacity\", \"stroke\", \"stroke-dasharray\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"id\", \"paint-order\", \"instantiated_by_use\", \"clip-path\"], A.DPI = 96, A.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:e[-+]?\\\\d+)?)\", A.fontPaths = {}, A.iMatrix = [1, 0, 0, 1, 0, 0], A.canvasModule = \"canvas\", A.perfLimitSizeTotal = 2097152, A.maxCacheSideLimit = 4096, A.minCacheSideLimit = 256, A.charWidthsCache = {}, A.textureSize = 2048, A.enableGLFiltering = !0, A.devicePixelRatio = A.window.devicePixelRatio || A.window.webkitDevicePixelRatio || A.window.mozDevicePixelRatio || 1, A.browserShadowBlurConstant = 1, A.arcToSegmentsCache = {}, A.boundsOfCurveCache = {}, A.cachesBoundsOfCurve = !0, A.initFilterBackend = function () {\n        return A.enableGLFiltering && A.isWebglSupported && A.isWebglSupported(A.textureSize) ? (console.log(\"max texture size: \" + A.maxTextureSize), new A.WebglFilterBackend({\n          tileSize: A.textureSize\n        })) : A.Canvas2dFilterBackend ? new A.Canvas2dFilterBackend() : void 0;\n      }, \"undefined\" != typeof document && \"undefined\" != typeof window && (window.fabric = A), function () {\n        function t(t, e) {\n          if (this.__eventListeners[t]) {\n            var i = this.__eventListeners[t];\n            e ? i[i.indexOf(e)] = !1 : A.util.array.fill(i, !1);\n          }\n        }\n\n        function e(t, e) {\n          if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length) for (var i in t) {\n            this.on(i, t[i]);\n          } else this.__eventListeners[t] || (this.__eventListeners[t] = []), this.__eventListeners[t].push(e);\n          return this;\n        }\n\n        function i(e, i) {\n          if (this.__eventListeners) {\n            if (0 === arguments.length) for (e in this.__eventListeners) {\n              t.call(this, e);\n            } else if (1 === arguments.length && \"object\" == typeof e) for (var r in e) {\n              t.call(this, r, e[r]);\n            } else t.call(this, e, i);\n            return this;\n          }\n        }\n\n        function r(t, e) {\n          if (this.__eventListeners) {\n            var i = this.__eventListeners[t];\n\n            if (i) {\n              for (var r = 0, n = i.length; r < n; r++) {\n                i[r] && i[r].call(this, e || {});\n              }\n\n              return this.__eventListeners[t] = i.filter(function (t) {\n                return !1 !== t;\n              }), this;\n            }\n          }\n        }\n\n        A.Observable = {\n          observe: e,\n          stopObserving: i,\n          fire: r,\n          on: e,\n          off: i,\n          trigger: r\n        };\n      }(), A.Collection = {\n        _objects: [],\n        add: function add() {\n          if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var t = 0, e = arguments.length; t < e; t++) {\n            this._onObjectAdded(arguments[t]);\n          }\n          return this.renderOnAddRemove && this.requestRenderAll(), this;\n        },\n        insertAt: function insertAt(t, e, i) {\n          var r = this._objects;\n          return i ? r[e] = t : r.splice(e, 0, t), this._onObjectAdded && this._onObjectAdded(t), this.renderOnAddRemove && this.requestRenderAll(), this;\n        },\n        remove: function remove() {\n          for (var t, e = this._objects, i = !1, r = 0, n = arguments.length; r < n; r++) {\n            -1 !== (t = e.indexOf(arguments[r])) && (i = !0, e.splice(t, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[r]));\n          }\n\n          return this.renderOnAddRemove && i && this.requestRenderAll(), this;\n        },\n        forEachObject: function forEachObject(t, e) {\n          for (var i = this.getObjects(), r = 0, n = i.length; r < n; r++) {\n            t.call(e, i[r], r, i);\n          }\n\n          return this;\n        },\n        getObjects: function getObjects(t) {\n          return void 0 === t ? this._objects.concat() : this._objects.filter(function (e) {\n            return e.type === t;\n          });\n        },\n        item: function item(t) {\n          return this._objects[t];\n        },\n        isEmpty: function isEmpty() {\n          return 0 === this._objects.length;\n        },\n        size: function size() {\n          return this._objects.length;\n        },\n        contains: function contains(t) {\n          return -1 < this._objects.indexOf(t);\n        },\n        complexity: function complexity() {\n          return this._objects.reduce(function (t, e) {\n            return t + (e.complexity ? e.complexity() : 0);\n          }, 0);\n        }\n      }, A.CommonMethods = {\n        _setOptions: function _setOptions(t) {\n          for (var e in t) {\n            this.set(e, t[e]);\n          }\n        },\n        _initGradient: function _initGradient(t, e) {\n          !t || !t.colorStops || t instanceof A.Gradient || this.set(e, new A.Gradient(t));\n        },\n        _initPattern: function _initPattern(t, e, i) {\n          !t || !t.source || t instanceof A.Pattern ? i && i() : this.set(e, new A.Pattern(t, i));\n        },\n        _initClipping: function _initClipping(t) {\n          if (t.clipTo && \"string\" == typeof t.clipTo) {\n            var e = A.util.getFunctionBody(t.clipTo);\n            void 0 !== e && (this.clipTo = new Function(\"ctx\", e));\n          }\n        },\n        _setObject: function _setObject(t) {\n          for (var e in t) {\n            this._set(e, t[e]);\n          }\n        },\n        set: function set(t, e) {\n          return \"object\" == typeof t ? this._setObject(t) : \"function\" == typeof e && \"clipTo\" !== t ? this._set(t, e(this.get(t))) : this._set(t, e), this;\n        },\n        _set: function _set(t, e) {\n          this[t] = e;\n        },\n        toggle: function toggle(t) {\n          var e = this.get(t);\n          return \"boolean\" == typeof e && this.set(t, !e), this;\n        },\n        get: function get(t) {\n          return this[t];\n        }\n      }, r = e, n = Math.sqrt, o = Math.atan2, s = Math.pow, a = Math.abs, h = Math.PI / 180, c = Math.PI / 2, A.util = {\n        cos: function cos(t) {\n          if (0 === t) return 1;\n\n          switch (t < 0 && (t = -t), t / c) {\n            case 1:\n            case 3:\n              return 0;\n\n            case 2:\n              return -1;\n          }\n\n          return Math.cos(t);\n        },\n        sin: function sin(t) {\n          if (0 === t) return 0;\n          var e = 1;\n\n          switch (t < 0 && (e = -1), t / c) {\n            case 1:\n              return e;\n\n            case 2:\n              return 0;\n\n            case 3:\n              return -e;\n          }\n\n          return Math.sin(t);\n        },\n        removeFromArray: function removeFromArray(t, e) {\n          var i = t.indexOf(e);\n          return -1 !== i && t.splice(i, 1), t;\n        },\n        getRandomInt: function getRandomInt(t, e) {\n          return Math.floor(Math.random() * (e - t + 1)) + t;\n        },\n        degreesToRadians: function degreesToRadians(t) {\n          return t * h;\n        },\n        radiansToDegrees: function radiansToDegrees(t) {\n          return t / h;\n        },\n        rotatePoint: function rotatePoint(t, e, i) {\n          t.subtractEquals(e);\n          var r = A.util.rotateVector(t, i);\n          return new A.Point(r.x, r.y).addEquals(e);\n        },\n        rotateVector: function rotateVector(t, e) {\n          var i = A.util.sin(e),\n              r = A.util.cos(e);\n          return {\n            x: t.x * r - t.y * i,\n            y: t.x * i + t.y * r\n          };\n        },\n        transformPoint: function transformPoint(t, e, i) {\n          return i ? new A.Point(e[0] * t.x + e[2] * t.y, e[1] * t.x + e[3] * t.y) : new A.Point(e[0] * t.x + e[2] * t.y + e[4], e[1] * t.x + e[3] * t.y + e[5]);\n        },\n        makeBoundingBoxFromPoints: function makeBoundingBoxFromPoints(t) {\n          var e = [t[0].x, t[1].x, t[2].x, t[3].x],\n              i = A.util.array.min(e),\n              r = A.util.array.max(e) - i,\n              n = [t[0].y, t[1].y, t[2].y, t[3].y],\n              o = A.util.array.min(n);\n          return {\n            left: i,\n            top: o,\n            width: r,\n            height: A.util.array.max(n) - o\n          };\n        },\n        invertTransform: function invertTransform(t) {\n          var e = 1 / (t[0] * t[3] - t[1] * t[2]),\n              i = [e * t[3], -e * t[1], -e * t[2], e * t[0]],\n              r = A.util.transformPoint({\n            x: t[4],\n            y: t[5]\n          }, i, !0);\n          return i[4] = -r.x, i[5] = -r.y, i;\n        },\n        toFixed: function toFixed(t, e) {\n          return parseFloat(Number(t).toFixed(e));\n        },\n        parseUnit: function parseUnit(t, e) {\n          var i = /\\D{0,2}$/.exec(t),\n              r = parseFloat(t);\n\n          switch (e || (e = A.Text.DEFAULT_SVG_FONT_SIZE), i[0]) {\n            case \"mm\":\n              return r * A.DPI / 25.4;\n\n            case \"cm\":\n              return r * A.DPI / 2.54;\n\n            case \"in\":\n              return r * A.DPI;\n\n            case \"pt\":\n              return r * A.DPI / 72;\n\n            case \"pc\":\n              return r * A.DPI / 72 * 12;\n\n            case \"em\":\n              return r * e;\n\n            default:\n              return r;\n          }\n        },\n        falseFunction: function falseFunction() {\n          return !1;\n        },\n        getKlass: function getKlass(t, e) {\n          return t = A.util.string.camelize(t.charAt(0).toUpperCase() + t.slice(1)), A.util.resolveNamespace(e)[t];\n        },\n        getSvgAttributes: function getSvgAttributes(t) {\n          var e = [\"instantiated_by_use\", \"style\", \"id\", \"class\"];\n\n          switch (t) {\n            case \"linearGradient\":\n              e = e.concat([\"x1\", \"y1\", \"x2\", \"y2\", \"gradientUnits\", \"gradientTransform\"]);\n              break;\n\n            case \"radialGradient\":\n              e = e.concat([\"gradientUnits\", \"gradientTransform\", \"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\"]);\n              break;\n\n            case \"stop\":\n              e = e.concat([\"offset\", \"stop-color\", \"stop-opacity\"]);\n          }\n\n          return e;\n        },\n        resolveNamespace: function resolveNamespace(t) {\n          if (!t) return A;\n          var e,\n              i = t.split(\".\"),\n              n = i.length,\n              o = r || A.window;\n\n          for (e = 0; e < n; ++e) {\n            o = o[i[e]];\n          }\n\n          return o;\n        },\n        loadImage: function loadImage(t, e, i, r) {\n          if (t) {\n            var n = A.util.createImage(),\n                o = function o() {\n              e && e.call(i, n), n = n.onload = n.onerror = null;\n            };\n\n            n.onload = o, n.onerror = function () {\n              A.log(\"Error loading \" + n.src), e && e.call(i, null, !0), n = n.onload = n.onerror = null;\n            }, 0 !== t.indexOf(\"data\") && r && (n.crossOrigin = r), \"data:image/svg\" === t.substring(0, 14) && (n.onload = null, A.util.loadImageInDom(n, o)), n.src = t;\n          } else e && e.call(i, t);\n        },\n        loadImageInDom: function loadImageInDom(t, e) {\n          var i = A.document.createElement(\"div\");\n          i.style.width = i.style.height = \"1px\", i.style.left = i.style.top = \"-100%\", i.style.position = \"absolute\", i.appendChild(t), A.document.querySelector(\"body\").appendChild(i), t.onload = function () {\n            e(), i.parentNode.removeChild(i), i = null;\n          };\n        },\n        enlivenObjects: function enlivenObjects(t, e, i, r) {\n          function n() {\n            ++s === a && e && e(o);\n          }\n\n          var o = [],\n              s = 0,\n              a = (t = t || []).length;\n          a ? t.forEach(function (t, e) {\n            t && t.type ? A.util.getKlass(t.type, i).fromObject(t, function (i, s) {\n              s || (o[e] = i), r && r(t, i, s), n();\n            }) : n();\n          }) : e && e(o);\n        },\n        enlivenPatterns: function enlivenPatterns(t, e) {\n          function i() {\n            ++n === o && e && e(r);\n          }\n\n          var r = [],\n              n = 0,\n              o = (t = t || []).length;\n          o ? t.forEach(function (t, e) {\n            t && t.source ? new A.Pattern(t, function (t) {\n              r[e] = t, i();\n            }) : (r[e] = t, i());\n          }) : e && e(r);\n        },\n        groupSVGElements: function groupSVGElements(t, e, i) {\n          var r;\n          return t && 1 === t.length ? t[0] : (e && (e.width && e.height ? e.centerPoint = {\n            x: e.width / 2,\n            y: e.height / 2\n          } : (delete e.width, delete e.height)), r = new A.Group(t, e), void 0 !== i && (r.sourcePath = i), r);\n        },\n        populateWithProperties: function populateWithProperties(t, e, i) {\n          if (i && \"[object Array]\" === Object.prototype.toString.call(i)) for (var r = 0, n = i.length; r < n; r++) {\n            i[r] in t && (e[i[r]] = t[i[r]]);\n          }\n        },\n        drawDashedLine: function drawDashedLine(t, e, i, r, s, a) {\n          var h = r - e,\n              c = s - i,\n              l = n(h * h + c * c),\n              u = o(c, h),\n              f = a.length,\n              d = 0,\n              g = !0;\n\n          for (t.save(), t.translate(e, i), t.moveTo(0, 0), t.rotate(u), e = 0; e < l;) {\n            l < (e += a[d++ % f]) && (e = l), t[g ? \"lineTo\" : \"moveTo\"](e, 0), g = !g;\n          }\n\n          t.restore();\n        },\n        createCanvasElement: function createCanvasElement() {\n          return A.document.createElement(\"canvas\");\n        },\n        copyCanvasElement: function copyCanvasElement(t) {\n          var e = A.util.createCanvasElement();\n          return e.width = t.width, e.height = t.height, e.getContext(\"2d\").drawImage(t, 0, 0), e;\n        },\n        createImage: function createImage() {\n          return A.document.createElement(\"img\");\n        },\n        clipContext: function clipContext(t, e) {\n          e.save(), e.beginPath(), t.clipTo(e), e.clip();\n        },\n        multiplyTransformMatrices: function multiplyTransformMatrices(t, e, i) {\n          return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], i ? 0 : t[0] * e[4] + t[2] * e[5] + t[4], i ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]];\n        },\n        qrDecompose: function qrDecompose(t) {\n          var e = o(t[1], t[0]),\n              i = s(t[0], 2) + s(t[1], 2),\n              r = n(i),\n              a = (t[0] * t[3] - t[2] * t[1]) / r,\n              c = o(t[0] * t[2] + t[1] * t[3], i);\n          return {\n            angle: e / h,\n            scaleX: r,\n            scaleY: a,\n            skewX: c / h,\n            skewY: 0,\n            translateX: t[4],\n            translateY: t[5]\n          };\n        },\n        customTransformMatrix: function customTransformMatrix(t, e, i) {\n          var r = [1, 0, a(Math.tan(i * h)), 1],\n              n = [a(t), 0, 0, a(e)];\n          return A.util.multiplyTransformMatrices(n, r, !0);\n        },\n        resetObjectTransform: function resetObjectTransform(t) {\n          t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.rotate(0);\n        },\n        saveObjectTransform: function saveObjectTransform(t) {\n          return {\n            scaleX: t.scaleX,\n            scaleY: t.scaleY,\n            skewX: t.skewX,\n            skewY: t.skewY,\n            angle: t.angle,\n            left: t.left,\n            flipX: t.flipX,\n            flipY: t.flipY,\n            top: t.top\n          };\n        },\n        getFunctionBody: function getFunctionBody(t) {\n          return (String(t).match(/function[^{]*\\{([\\s\\S]*)\\}/) || {})[1];\n        },\n        isTransparent: function isTransparent(t, e, i, r) {\n          0 < r && (r < e ? e -= r : e = 0, r < i ? i -= r : i = 0);\n          var n,\n              o = !0,\n              s = t.getImageData(e, i, 2 * r || 1, 2 * r || 1),\n              a = s.data.length;\n\n          for (n = 3; n < a && 0 != (o = s.data[n] <= 0); n += 4) {\n            ;\n          }\n\n          return s = null, o;\n        },\n        parsePreserveAspectRatioAttribute: function parsePreserveAspectRatioAttribute(t) {\n          var e,\n              i = \"meet\",\n              r = t.split(\" \");\n          return r && r.length && (\"meet\" !== (i = r.pop()) && \"slice\" !== i ? (e = i, i = \"meet\") : r.length && (e = r.pop())), {\n            meetOrSlice: i,\n            alignX: \"none\" !== e ? e.slice(1, 4) : \"none\",\n            alignY: \"none\" !== e ? e.slice(5, 8) : \"none\"\n          };\n        },\n        clearFabricFontCache: function clearFabricFontCache(t) {\n          (t = (t || \"\").toLowerCase()) ? A.charWidthsCache[t] && delete A.charWidthsCache[t] : A.charWidthsCache = {};\n        },\n        limitDimsByArea: function limitDimsByArea(t, e) {\n          var i = Math.sqrt(e * t),\n              r = Math.floor(e / i);\n          return {\n            x: Math.floor(i),\n            y: r\n          };\n        },\n        capValue: function capValue(t, e, i) {\n          return Math.max(t, Math.min(e, i));\n        },\n        findScaleToFit: function findScaleToFit(t, e) {\n          return Math.min(e.width / t.width, e.height / t.height);\n        },\n        findScaleToCover: function findScaleToCover(t, e) {\n          return Math.max(e.width / t.width, e.height / t.height);\n        }\n      }, function () {\n        var t = Array.prototype.join;\n\n        function e(e, r, n, o, s, a, h) {\n          var c = t.call(arguments);\n          if (A.arcToSegmentsCache[c]) return A.arcToSegmentsCache[c];\n\n          var l = Math.PI,\n              u = h * l / 180,\n              f = A.util.sin(u),\n              d = A.util.cos(u),\n              g = 0,\n              p = 0,\n              v = -d * e * .5 - f * r * .5,\n              m = -d * r * .5 + f * e * .5,\n              y = (n = Math.abs(n)) * n,\n              _ = (o = Math.abs(o)) * o,\n              b = m * m,\n              x = v * v,\n              C = y * _ - y * b - _ * x,\n              S = 0;\n\n          if (C < 0) {\n            var w = Math.sqrt(1 - C / (y * _));\n            n *= w, o *= w;\n          } else S = (s === a ? -1 : 1) * Math.sqrt(C / (y * b + _ * x));\n\n          var T = S * n * m / o,\n              O = -S * o * v / n,\n              E = d * T - f * O + .5 * e,\n              k = f * T + d * O + .5 * r,\n              P = i(1, 0, (v - T) / n, (m - O) / o),\n              D = i((v - T) / n, (m - O) / o, (-v - T) / n, (-m - O) / o);\n          0 === a && 0 < D ? D -= 2 * l : 1 === a && D < 0 && (D += 2 * l);\n\n          for (var j, M, F, I, L, R, B, Y, X, U, W, N, z, V, G, H, q, K = Math.ceil(Math.abs(D / l * 2)), J = [], $ = D / K, Z = 8 / 3 * Math.sin($ / 4) * Math.sin($ / 4) / Math.sin($ / 2), Q = P + $, tt = 0; tt < K; tt++) {\n            J[tt] = (j = P, M = Q, F = d, I = f, L = n, R = o, B = E, Y = k, X = Z, U = g, W = p, N = A.util.cos(j), [U + X * (-F * L * (z = A.util.sin(j)) - I * R * N), W + X * (-I * L * z + F * R * N), (H = F * L * (V = A.util.cos(M)) - I * R * (G = A.util.sin(M)) + B) + X * (F * L * G + I * R * V), (q = I * L * V + F * R * G + Y) + X * (I * L * G - F * R * V), H, q]), g = J[tt][4], p = J[tt][5], P = Q, Q += $;\n          }\n\n          return A.arcToSegmentsCache[c] = J;\n        }\n\n        function i(t, e, i, r) {\n          var n = Math.atan2(e, t),\n              o = Math.atan2(r, i);\n          return n <= o ? o - n : 2 * Math.PI - (n - o);\n        }\n\n        function r(e, i, r, n, o, s, a, h) {\n          var c;\n          if (A.cachesBoundsOfCurve && (c = t.call(arguments), A.boundsOfCurveCache[c])) return A.boundsOfCurveCache[c];\n          var l,\n              u,\n              f,\n              d,\n              g,\n              p,\n              v,\n              m,\n              y = Math.sqrt,\n              _ = Math.min,\n              b = Math.max,\n              x = Math.abs,\n              C = [],\n              S = [[], []];\n          u = 6 * e - 12 * r + 6 * o, l = -3 * e + 9 * r - 9 * o + 3 * a, f = 3 * r - 3 * e;\n\n          for (var w = 0; w < 2; ++w) {\n            if (0 < w && (u = 6 * i - 12 * n + 6 * s, l = -3 * i + 9 * n - 9 * s + 3 * h, f = 3 * n - 3 * i), x(l) < 1e-12) {\n              if (x(u) < 1e-12) continue;\n              0 < (d = -f / u) && d < 1 && C.push(d);\n            } else (v = u * u - 4 * f * l) < 0 || (0 < (g = (-u + (m = y(v))) / (2 * l)) && g < 1 && C.push(g), 0 < (p = (-u - m) / (2 * l)) && p < 1 && C.push(p));\n          }\n\n          for (var T, O, E, k = C.length, P = k; k--;) {\n            T = (E = 1 - (d = C[k])) * E * E * e + 3 * E * E * d * r + 3 * E * d * d * o + d * d * d * a, S[0][k] = T, O = E * E * E * i + 3 * E * E * d * n + 3 * E * d * d * s + d * d * d * h, S[1][k] = O;\n          }\n\n          S[0][P] = e, S[1][P] = i, S[0][P + 1] = a, S[1][P + 1] = h;\n          var D = [{\n            x: _.apply(null, S[0]),\n            y: _.apply(null, S[1])\n          }, {\n            x: b.apply(null, S[0]),\n            y: b.apply(null, S[1])\n          }];\n          return A.cachesBoundsOfCurve && (A.boundsOfCurveCache[c] = D), D;\n        }\n\n        A.util.drawArc = function (t, i, r, n) {\n          for (var o = n[0], s = n[1], a = n[2], h = n[3], c = n[4], l = [[], [], [], []], u = e(n[5] - i, n[6] - r, o, s, h, c, a), f = 0, d = u.length; f < d; f++) {\n            l[f][0] = u[f][0] + i, l[f][1] = u[f][1] + r, l[f][2] = u[f][2] + i, l[f][3] = u[f][3] + r, l[f][4] = u[f][4] + i, l[f][5] = u[f][5] + r, t.bezierCurveTo.apply(t, l[f]);\n          }\n        }, A.util.getBoundsOfArc = function (t, i, n, o, s, a, h, c, l) {\n          for (var u, f = 0, d = 0, g = [], p = e(c - t, l - i, n, o, a, h, s), v = 0, m = p.length; v < m; v++) {\n            u = r(f, d, p[v][0], p[v][1], p[v][2], p[v][3], p[v][4], p[v][5]), g.push({\n              x: u[0].x + t,\n              y: u[0].y + i\n            }), g.push({\n              x: u[1].x + t,\n              y: u[1].y + i\n            }), f = p[v][4], d = p[v][5];\n          }\n\n          return g;\n        }, A.util.getBoundsOfCurve = r;\n      }(), function () {\n        var t = Array.prototype.slice;\n\n        function e(t, e, i) {\n          if (t && 0 !== t.length) {\n            var r = t.length - 1,\n                n = e ? t[r][e] : t[r];\n            if (e) for (; r--;) {\n              i(t[r][e], n) && (n = t[r][e]);\n            } else for (; r--;) {\n              i(t[r], n) && (n = t[r]);\n            }\n            return n;\n          }\n        }\n\n        A.util.array = {\n          fill: function fill(t, e) {\n            for (var i = t.length; i--;) {\n              t[i] = e;\n            }\n\n            return t;\n          },\n          invoke: function invoke(e, i) {\n            for (var r = t.call(arguments, 2), n = [], o = 0, s = e.length; o < s; o++) {\n              n[o] = r.length ? e[o][i].apply(e[o], r) : e[o][i].call(e[o]);\n            }\n\n            return n;\n          },\n          min: function min(t, i) {\n            return e(t, i, function (t, e) {\n              return t < e;\n            });\n          },\n          max: function max(t, i) {\n            return e(t, i, function (t, e) {\n              return e <= t;\n            });\n          }\n        };\n      }(), function () {\n        function t(e, i, r) {\n          if (r) {\n            if (!A.isLikelyNode && i instanceof Element) e = i;else if (i instanceof Array) {\n              e = [];\n\n              for (var n = 0, o = i.length; n < o; n++) {\n                e[n] = t({}, i[n], r);\n              }\n            } else if (i && \"object\" == typeof i) for (var s in i) {\n              i.hasOwnProperty(s) && (e[s] = t({}, i[s], r));\n            } else e = i;\n          } else for (var s in i) {\n            e[s] = i[s];\n          }\n          return e;\n        }\n\n        A.util.object = {\n          extend: t,\n          clone: function clone(e, i) {\n            return t({}, e, i);\n          }\n        }, A.util.object.extend(A.util, A.Observable);\n      }(), function () {\n        function t(t, e) {\n          var i = t.charCodeAt(e);\n          if (isNaN(i)) return \"\";\n          if (i < 55296 || 57343 < i) return t.charAt(e);\n\n          if (55296 <= i && i <= 56319) {\n            if (t.length <= e + 1) throw \"High surrogate without following low surrogate\";\n            var r = t.charCodeAt(e + 1);\n            if (r < 56320 || 57343 < r) throw \"High surrogate without following low surrogate\";\n            return t.charAt(e) + t.charAt(e + 1);\n          }\n\n          if (0 === e) throw \"Low surrogate without preceding high surrogate\";\n          var n = t.charCodeAt(e - 1);\n          if (n < 55296 || 56319 < n) throw \"Low surrogate without preceding high surrogate\";\n          return !1;\n        }\n\n        A.util.string = {\n          camelize: function camelize(t) {\n            return t.replace(/-+(.)?/g, function (t, e) {\n              return e ? e.toUpperCase() : \"\";\n            });\n          },\n          capitalize: function capitalize(t, e) {\n            return t.charAt(0).toUpperCase() + (e ? t.slice(1) : t.slice(1).toLowerCase());\n          },\n          escapeXml: function escapeXml(t) {\n            return t.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n          },\n          graphemeSplit: function graphemeSplit(e) {\n            var i,\n                r = 0,\n                n = [];\n\n            for (r = 0; r < e.length; r++) {\n              !1 !== (i = t(e, r)) && n.push(i);\n            }\n\n            return n;\n          }\n        };\n      }(), function () {\n        var t = Array.prototype.slice,\n            e = function e() {},\n            i = function () {\n          for (var t in {\n            toString: 1\n          }) {\n            if (\"toString\" === t) return !1;\n          }\n\n          return !0;\n        }(),\n            r = function r(t, e, _r) {\n          for (var n in e) {\n            n in t.prototype && \"function\" == typeof t.prototype[n] && -1 < (e[n] + \"\").indexOf(\"callSuper\") ? t.prototype[n] = function (t) {\n              return function () {\n                var i = this.constructor.superclass;\n                this.constructor.superclass = _r;\n                var n = e[t].apply(this, arguments);\n                if (this.constructor.superclass = i, \"initialize\" !== t) return n;\n              };\n            }(n) : t.prototype[n] = e[n], i && (e.toString !== Object.prototype.toString && (t.prototype.toString = e.toString), e.valueOf !== Object.prototype.valueOf && (t.prototype.valueOf = e.valueOf));\n          }\n        };\n\n        function n() {}\n\n        function o(e) {\n          for (var i = null, r = this; r.constructor.superclass;) {\n            var n = r.constructor.superclass.prototype[e];\n\n            if (r[e] !== n) {\n              i = n;\n              break;\n            }\n\n            r = r.constructor.superclass.prototype;\n          }\n\n          return i ? 1 < arguments.length ? i.apply(this, t.call(arguments, 1)) : i.call(this) : console.log(\"tried to callSuper \" + e + \", method not found in prototype chain\", this);\n        }\n\n        A.util.createClass = function () {\n          var i = null,\n              s = t.call(arguments, 0);\n\n          function a() {\n            this.initialize.apply(this, arguments);\n          }\n\n          \"function\" == typeof s[0] && (i = s.shift()), a.superclass = i, a.subclasses = [], i && (n.prototype = i.prototype, a.prototype = new n(), i.subclasses.push(a));\n\n          for (var h = 0, c = s.length; h < c; h++) {\n            r(a, s[h], i);\n          }\n\n          return a.prototype.initialize || (a.prototype.initialize = e), (a.prototype.constructor = a).prototype.callSuper = o, a;\n        };\n      }(), function () {\n        function t(t) {\n          var e,\n              i,\n              r = Array.prototype.slice.call(arguments, 1),\n              n = r.length;\n\n          for (i = 0; i < n; i++) {\n            if (e = typeof t[r[i]], !/^(?:function|object|unknown)$/.test(e)) return !1;\n          }\n\n          return !0;\n        }\n\n        var e,\n            i,\n            r,\n            n,\n            o = (r = 0, function (t) {\n          return t.__uniqueID || (t.__uniqueID = \"uniqueID__\" + r++);\n        });\n\n        function s(t, i) {\n          return {\n            handler: i,\n            wrappedHandler: (r = t, n = i, function (t) {\n              n.call(e(r), t || A.window.event);\n            })\n          };\n          var r, n;\n        }\n\n        n = {}, e = function e(t) {\n          return n[t];\n        }, i = function i(t, e) {\n          n[t] = e;\n        };\n        var a,\n            h,\n            c = t(A.document.documentElement, \"addEventListener\", \"removeEventListener\") && t(A.window, \"addEventListener\", \"removeEventListener\"),\n            l = t(A.document.documentElement, \"attachEvent\", \"detachEvent\") && t(A.window, \"attachEvent\", \"detachEvent\"),\n            u = {},\n            f = {};\n        h = c ? (a = function a(t, e, i, r) {\n          t && t.addEventListener(e, i, !l && r);\n        }, function (t, e, i, r) {\n          t && t.removeEventListener(e, i, !l && r);\n        }) : l ? (a = function a(t, e, r) {\n          if (t) {\n            var n = o(t);\n            i(n, t), u[n] || (u[n] = {}), u[n][e] || (u[n][e] = []);\n            var a = s(n, r);\n            u[n][e].push(a), t.attachEvent(\"on\" + e, a.wrappedHandler);\n          }\n        }, function (t, e, i) {\n          if (t) {\n            var r,\n                n = o(t);\n            if (u[n] && u[n][e]) for (var s = 0, a = u[n][e].length; s < a; s++) {\n              (r = u[n][e][s]) && r.handler === i && (t.detachEvent(\"on\" + e, r.wrappedHandler), u[n][e][s] = null);\n            }\n          }\n        }) : (a = function a(t, e, i) {\n          if (t) {\n            var r,\n                n,\n                s = o(t);\n\n            if (f[s] || (f[s] = {}), !f[s][e]) {\n              f[s][e] = [];\n              var a = t[\"on\" + e];\n              a && f[s][e].push(a), t[\"on\" + e] = (r = s, n = e, function (t) {\n                if (f[r] && f[r][n]) for (var e = f[r][n], i = 0, o = e.length; i < o; i++) {\n                  e[i].call(this, t || A.window.event);\n                }\n              });\n            }\n\n            f[s][e].push(i);\n          }\n        }, function (t, e, i) {\n          if (t) {\n            var r = o(t);\n            if (f[r] && f[r][e]) for (var n = f[r][e], s = 0, a = n.length; s < a; s++) {\n              n[s] === i && n.splice(s, 1);\n            }\n          }\n        }), A.util.addListener = a, A.util.removeListener = h;\n\n        var d = function d(t) {\n          return t.clientX;\n        },\n            g = function g(t) {\n          return t.clientY;\n        };\n\n        function p(t, e, i) {\n          var r,\n              n = t[\"touchend\" === t.type ? \"changedTouches\" : \"touches\"];\n          return n && n[0] && (r = n[0][i]), void 0 === r && (r = t[i]), r;\n        }\n\n        A.isTouchSupported && (d = function d(t) {\n          return p(t, 0, \"clientX\");\n        }, g = function g(t) {\n          return p(t, 0, \"clientY\");\n        }), A.util.getPointer = function (t) {\n          t || (t = A.window.event);\n          var e = t.target || (\"unknown\" != typeof t.srcElement ? t.srcElement : null),\n              i = A.util.getScrollLeftTop(e);\n          return {\n            x: d(t) + i.left,\n            y: g(t) + i.top\n          };\n        };\n      }(), u = \"string\" == typeof (l = A.document.createElement(\"div\")).style.opacity, f = \"string\" == typeof l.style.filter, d = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, g = function g(t) {\n        return t;\n      }, u ? g = function g(t, e) {\n        return t.style.opacity = e, t;\n      } : f && (g = function g(t, e) {\n        var i = t.style;\n        return t.currentStyle && !t.currentStyle.hasLayout && (i.zoom = 1), d.test(i.filter) ? (e = .9999 <= e ? \"\" : \"alpha(opacity=\" + 100 * e + \")\", i.filter = i.filter.replace(d, e)) : i.filter += \" alpha(opacity=\" + 100 * e + \")\", t;\n      }), A.util.setStyle = function (t, e) {\n        var i = t.style;\n        if (!i) return t;\n        if (\"string\" == typeof e) return t.style.cssText += \";\" + e, -1 < e.indexOf(\"opacity\") ? g(t, e.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : t;\n\n        for (var r in e) {\n          \"opacity\" === r ? g(t, e[r]) : i[\"float\" === r || \"cssFloat\" === r ? void 0 === i.styleFloat ? \"cssFloat\" : \"styleFloat\" : r] = e[r];\n        }\n\n        return t;\n      }, function () {\n        var t,\n            e,\n            i,\n            r,\n            n = Array.prototype.slice,\n            o = function o(t) {\n          return n.call(t, 0);\n        };\n\n        try {\n          t = o(A.document.childNodes) instanceof Array;\n        } catch (t) {}\n\n        function s(t, e) {\n          var i = A.document.createElement(t);\n\n          for (var r in e) {\n            \"class\" === r ? i.className = e[r] : \"for\" === r ? i.htmlFor = e[r] : i.setAttribute(r, e[r]);\n          }\n\n          return i;\n        }\n\n        function a(t) {\n          for (var e = 0, i = 0, r = A.document.documentElement, n = A.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n          }; t && (t.parentNode || t.host) && ((t = t.parentNode || t.host) === A.document ? (e = n.scrollLeft || r.scrollLeft || 0, i = n.scrollTop || r.scrollTop || 0) : (e += t.scrollLeft || 0, i += t.scrollTop || 0), 1 !== t.nodeType || \"fixed\" !== t.style.position);) {\n            ;\n          }\n\n          return {\n            left: e,\n            top: i\n          };\n        }\n\n        t || (o = function o(t) {\n          for (var e = new Array(t.length), i = t.length; i--;) {\n            e[i] = t[i];\n          }\n\n          return e;\n        }), e = A.document.defaultView && A.document.defaultView.getComputedStyle ? function (t, e) {\n          var i = A.document.defaultView.getComputedStyle(t, null);\n          return i ? i[e] : void 0;\n        } : function (t, e) {\n          var i = t.style[e];\n          return !i && t.currentStyle && (i = t.currentStyle[e]), i;\n        }, i = A.document.documentElement.style, r = \"userSelect\" in i ? \"userSelect\" : \"MozUserSelect\" in i ? \"MozUserSelect\" : \"WebkitUserSelect\" in i ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in i ? \"KhtmlUserSelect\" : \"\", A.util.makeElementUnselectable = function (t) {\n          return void 0 !== t.onselectstart && (t.onselectstart = A.util.falseFunction), r ? t.style[r] = \"none\" : \"string\" == typeof t.unselectable && (t.unselectable = \"on\"), t;\n        }, A.util.makeElementSelectable = function (t) {\n          return void 0 !== t.onselectstart && (t.onselectstart = null), r ? t.style[r] = \"\" : \"string\" == typeof t.unselectable && (t.unselectable = \"\"), t;\n        }, A.util.getScript = function (t, e) {\n          var i = A.document.getElementsByTagName(\"head\")[0],\n              r = A.document.createElement(\"script\"),\n              n = !0;\n          r.onload = r.onreadystatechange = function (t) {\n            if (n) {\n              if (\"string\" == typeof this.readyState && \"loaded\" !== this.readyState && \"complete\" !== this.readyState) return;\n              n = !1, e(t || A.window.event), r = r.onload = r.onreadystatechange = null;\n            }\n          }, r.src = t, i.appendChild(r);\n        }, A.util.getById = function (t) {\n          return \"string\" == typeof t ? A.document.getElementById(t) : t;\n        }, A.util.toArray = o, A.util.makeElement = s, A.util.addClass = function (t, e) {\n          t && -1 === (\" \" + t.className + \" \").indexOf(\" \" + e + \" \") && (t.className += (t.className ? \" \" : \"\") + e);\n        }, A.util.wrapElement = function (t, e, i) {\n          return \"string\" == typeof e && (e = s(e, i)), t.parentNode && t.parentNode.replaceChild(e, t), e.appendChild(t), e;\n        }, A.util.getScrollLeftTop = a, A.util.getElementOffset = function (t) {\n          var i,\n              r,\n              n = t && t.ownerDocument,\n              o = {\n            left: 0,\n            top: 0\n          },\n              s = {\n            left: 0,\n            top: 0\n          },\n              h = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n          };\n          if (!n) return s;\n\n          for (var c in h) {\n            s[h[c]] += parseInt(e(t, c), 10) || 0;\n          }\n\n          return i = n.documentElement, void 0 !== t.getBoundingClientRect && (o = t.getBoundingClientRect()), r = a(t), {\n            left: o.left + r.left - (i.clientLeft || 0) + s.left,\n            top: o.top + r.top - (i.clientTop || 0) + s.top\n          };\n        }, A.util.getElementStyle = e, A.util.getNodeCanvas = function (t) {\n          var e = A.jsdomImplForWrapper(t);\n          return e._canvas || e._image;\n        }, A.util.cleanUpJsdomNode = function (t) {\n          if (A.isLikelyNode) {\n            var e = A.jsdomImplForWrapper(t);\n            e && (e._image = null, e._canvas = null, e._currentSrc = null, e._attributes = null, e._classList = null);\n          }\n        };\n      }(), function () {\n        function t() {}\n\n        A.util.request = function (e, i) {\n          i || (i = {});\n\n          var r,\n              n,\n              o = i.method ? i.method.toUpperCase() : \"GET\",\n              s = i.onComplete || function () {},\n              a = new A.window.XMLHttpRequest(),\n              h = i.body || i.parameters;\n\n          return a.onreadystatechange = function () {\n            4 === a.readyState && (s(a), a.onreadystatechange = t);\n          }, \"GET\" === o && (h = null, \"string\" == typeof i.parameters && (r = e, n = i.parameters, e = r + (/\\?/.test(r) ? \"&\" : \"?\") + n)), a.open(o, e, !0), \"POST\" !== o && \"PUT\" !== o || a.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"), a.send(h), a;\n        };\n      }(), A.log = function () {}, A.warn = function () {}, \"undefined\" != typeof console && [\"log\", \"warn\"].forEach(function (t) {\n        void 0 !== console[t] && \"function\" == typeof console[t].apply && (A[t] = function () {\n          return console[t].apply(console, arguments);\n        });\n      }), function () {\n        function t() {\n          return !1;\n        }\n\n        var e = A.window.requestAnimationFrame || A.window.webkitRequestAnimationFrame || A.window.mozRequestAnimationFrame || A.window.oRequestAnimationFrame || A.window.msRequestAnimationFrame || function (t) {\n          return A.window.setTimeout(t, 1e3 / 60);\n        },\n            i = A.window.cancelAnimationFrame || A.window.clearTimeout;\n\n        function r() {\n          return e.apply(A.window, arguments);\n        }\n\n        A.util.animate = function (e) {\n          r(function (i) {\n            e || (e = {});\n\n            var n,\n                o = i || +new Date(),\n                s = e.duration || 500,\n                a = o + s,\n                h = e.onChange || t,\n                c = e.abort || t,\n                l = e.onComplete || t,\n                u = e.easing || function (t, e, i, r) {\n              return -i * Math.cos(t / r * (Math.PI / 2)) + i + e;\n            },\n                f = \"startValue\" in e ? e.startValue : 0,\n                d = \"endValue\" in e ? e.endValue : 100,\n                g = e.byValue || d - f;\n\n            e.onStart && e.onStart(), function t(i) {\n              if (c()) l(d, 1, 1);else {\n                n = i || +new Date();\n                var p = a < n ? s : n - o,\n                    v = p / s,\n                    m = u(p, f, g, s),\n                    y = Math.abs((m - f) / g);\n                h(m, y, v), a < n ? e.onComplete && e.onComplete() : r(t);\n              }\n            }(o);\n          });\n        }, A.util.requestAnimFrame = r, A.util.cancelAnimFrame = function () {\n          return i.apply(A.window, arguments);\n        };\n      }(), A.util.animateColor = function (t, e, i, r) {\n        var n = new A.Color(t).getSource(),\n            o = new A.Color(e).getSource();\n        r = r || {}, A.util.animate(A.util.object.extend(r, {\n          duration: i || 500,\n          startValue: n,\n          endValue: o,\n          byValue: o,\n          easing: function easing(t, e, i, n) {\n            var o, s, a, h;\n            return o = e, s = i, a = r.colorEasing ? r.colorEasing(t, n) : 1 - Math.cos(t / n * (Math.PI / 2)), h = \"rgba(\" + parseInt(o[0] + a * (s[0] - o[0]), 10) + \",\" + parseInt(o[1] + a * (s[1] - o[1]), 10) + \",\" + parseInt(o[2] + a * (s[2] - o[2]), 10), (h += \",\" + (o && s ? parseFloat(o[3] + a * (s[3] - o[3])) : 1)) + \")\";\n          }\n        }));\n      }, function () {\n        function t(t, e, i, r) {\n          return r = t < Math.abs(e) ? (t = e, i / 4) : 0 === e && 0 === t ? i / (2 * Math.PI) * Math.asin(1) : i / (2 * Math.PI) * Math.asin(e / t), {\n            a: t,\n            c: e,\n            p: i,\n            s: r\n          };\n        }\n\n        function e(t, e, i) {\n          return t.a * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - t.s) * (2 * Math.PI) / t.p);\n        }\n\n        function i(t, e, i, n) {\n          return i - r(n - t, 0, i, n) + e;\n        }\n\n        function r(t, e, i, r) {\n          return (t /= r) < 1 / 2.75 ? i * (7.5625 * t * t) + e : t < 2 / 2.75 ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e;\n        }\n\n        A.util.ease = {\n          easeInQuad: function easeInQuad(t, e, i, r) {\n            return i * (t /= r) * t + e;\n          },\n          easeOutQuad: function easeOutQuad(t, e, i, r) {\n            return -i * (t /= r) * (t - 2) + e;\n          },\n          easeInOutQuad: function easeInOutQuad(t, e, i, r) {\n            return (t /= r / 2) < 1 ? i / 2 * t * t + e : -i / 2 * (--t * (t - 2) - 1) + e;\n          },\n          easeInCubic: function easeInCubic(t, e, i, r) {\n            return i * (t /= r) * t * t + e;\n          },\n          easeOutCubic: function easeOutCubic(t, e, i, r) {\n            return i * ((t = t / r - 1) * t * t + 1) + e;\n          },\n          easeInOutCubic: function easeInOutCubic(t, e, i, r) {\n            return (t /= r / 2) < 1 ? i / 2 * t * t * t + e : i / 2 * ((t -= 2) * t * t + 2) + e;\n          },\n          easeInQuart: function easeInQuart(t, e, i, r) {\n            return i * (t /= r) * t * t * t + e;\n          },\n          easeOutQuart: function easeOutQuart(t, e, i, r) {\n            return -i * ((t = t / r - 1) * t * t * t - 1) + e;\n          },\n          easeInOutQuart: function easeInOutQuart(t, e, i, r) {\n            return (t /= r / 2) < 1 ? i / 2 * t * t * t * t + e : -i / 2 * ((t -= 2) * t * t * t - 2) + e;\n          },\n          easeInQuint: function easeInQuint(t, e, i, r) {\n            return i * (t /= r) * t * t * t * t + e;\n          },\n          easeOutQuint: function easeOutQuint(t, e, i, r) {\n            return i * ((t = t / r - 1) * t * t * t * t + 1) + e;\n          },\n          easeInOutQuint: function easeInOutQuint(t, e, i, r) {\n            return (t /= r / 2) < 1 ? i / 2 * t * t * t * t * t + e : i / 2 * ((t -= 2) * t * t * t * t + 2) + e;\n          },\n          easeInSine: function easeInSine(t, e, i, r) {\n            return -i * Math.cos(t / r * (Math.PI / 2)) + i + e;\n          },\n          easeOutSine: function easeOutSine(t, e, i, r) {\n            return i * Math.sin(t / r * (Math.PI / 2)) + e;\n          },\n          easeInOutSine: function easeInOutSine(t, e, i, r) {\n            return -i / 2 * (Math.cos(Math.PI * t / r) - 1) + e;\n          },\n          easeInExpo: function easeInExpo(t, e, i, r) {\n            return 0 === t ? e : i * Math.pow(2, 10 * (t / r - 1)) + e;\n          },\n          easeOutExpo: function easeOutExpo(t, e, i, r) {\n            return t === r ? e + i : i * (1 - Math.pow(2, -10 * t / r)) + e;\n          },\n          easeInOutExpo: function easeInOutExpo(t, e, i, r) {\n            return 0 === t ? e : t === r ? e + i : (t /= r / 2) < 1 ? i / 2 * Math.pow(2, 10 * (t - 1)) + e : i / 2 * (2 - Math.pow(2, -10 * --t)) + e;\n          },\n          easeInCirc: function easeInCirc(t, e, i, r) {\n            return -i * (Math.sqrt(1 - (t /= r) * t) - 1) + e;\n          },\n          easeOutCirc: function easeOutCirc(t, e, i, r) {\n            return i * Math.sqrt(1 - (t = t / r - 1) * t) + e;\n          },\n          easeInOutCirc: function easeInOutCirc(t, e, i, r) {\n            return (t /= r / 2) < 1 ? -i / 2 * (Math.sqrt(1 - t * t) - 1) + e : i / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e;\n          },\n          easeInElastic: function easeInElastic(i, r, n, o) {\n            var s = 0;\n            return 0 === i ? r : 1 == (i /= o) ? r + n : (s || (s = .3 * o), -e(t(n, n, s, 1.70158), i, o) + r);\n          },\n          easeOutElastic: function easeOutElastic(e, i, r, n) {\n            var o = 0;\n            if (0 === e) return i;\n            if (1 == (e /= n)) return i + r;\n            o || (o = .3 * n);\n            var s = t(r, r, o, 1.70158);\n            return s.a * Math.pow(2, -10 * e) * Math.sin((e * n - s.s) * (2 * Math.PI) / s.p) + s.c + i;\n          },\n          easeInOutElastic: function easeInOutElastic(i, r, n, o) {\n            var s = 0;\n            if (0 === i) return r;\n            if (2 == (i /= o / 2)) return r + n;\n            s || (s = o * (.3 * 1.5));\n            var a = t(n, n, s, 1.70158);\n            return i < 1 ? -.5 * e(a, i, o) + r : a.a * Math.pow(2, -10 * (i -= 1)) * Math.sin((i * o - a.s) * (2 * Math.PI) / a.p) * .5 + a.c + r;\n          },\n          easeInBack: function easeInBack(t, e, i, r, n) {\n            return void 0 === n && (n = 1.70158), i * (t /= r) * t * ((n + 1) * t - n) + e;\n          },\n          easeOutBack: function easeOutBack(t, e, i, r, n) {\n            return void 0 === n && (n = 1.70158), i * ((t = t / r - 1) * t * ((n + 1) * t + n) + 1) + e;\n          },\n          easeInOutBack: function easeInOutBack(t, e, i, r, n) {\n            return void 0 === n && (n = 1.70158), (t /= r / 2) < 1 ? i / 2 * (t * t * ((1 + (n *= 1.525)) * t - n)) + e : i / 2 * ((t -= 2) * t * ((1 + (n *= 1.525)) * t + n) + 2) + e;\n          },\n          easeInBounce: i,\n          easeOutBounce: r,\n          easeInOutBounce: function easeInOutBounce(t, e, n, o) {\n            return t < o / 2 ? .5 * i(2 * t, 0, n, o) + e : .5 * r(2 * t - o, 0, n, o) + .5 * n + e;\n          }\n        };\n      }(), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.util.object.clone,\n            n = e.util.toFixed,\n            o = e.util.parseUnit,\n            s = e.util.multiplyTransformMatrices,\n            a = {\n          cx: \"left\",\n          x: \"left\",\n          r: \"radius\",\n          cy: \"top\",\n          y: \"top\",\n          display: \"visible\",\n          visibility: \"visible\",\n          transform: \"transformMatrix\",\n          \"fill-opacity\": \"fillOpacity\",\n          \"fill-rule\": \"fillRule\",\n          \"font-family\": \"fontFamily\",\n          \"font-size\": \"fontSize\",\n          \"font-style\": \"fontStyle\",\n          \"font-weight\": \"fontWeight\",\n          \"letter-spacing\": \"charSpacing\",\n          \"paint-order\": \"paintFirst\",\n          \"stroke-dasharray\": \"strokeDashArray\",\n          \"stroke-linecap\": \"strokeLineCap\",\n          \"stroke-linejoin\": \"strokeLineJoin\",\n          \"stroke-miterlimit\": \"strokeMiterLimit\",\n          \"stroke-opacity\": \"strokeOpacity\",\n          \"stroke-width\": \"strokeWidth\",\n          \"text-decoration\": \"textDecoration\",\n          \"text-anchor\": \"textAnchor\",\n          opacity: \"opacity\",\n          \"clip-path\": \"clipPath\",\n          \"clip-rule\": \"clipRule\"\n        },\n            h = {\n          stroke: \"strokeOpacity\",\n          fill: \"fillOpacity\"\n        };\n\n        function c(t, i, r, n) {\n          var a,\n              h = \"[object Array]\" === Object.prototype.toString.call(i);\n          if (\"fill\" !== t && \"stroke\" !== t || \"none\" !== i) {\n            if (\"strokeDashArray\" === t) i = \"none\" === i ? null : i.replace(/,/g, \" \").split(/\\s+/).map(function (t) {\n              return parseFloat(t);\n            });else if (\"transformMatrix\" === t) i = r && r.transformMatrix ? s(r.transformMatrix, e.parseTransformAttribute(i)) : e.parseTransformAttribute(i);else if (\"visible\" === t) i = \"none\" !== i && \"hidden\" !== i, r && !1 === r.visible && (i = !1);else if (\"opacity\" === t) i = parseFloat(i), r && void 0 !== r.opacity && (i *= r.opacity);else if (\"textAnchor\" === t) i = \"start\" === i ? \"left\" : \"end\" === i ? \"right\" : \"center\";else if (\"charSpacing\" === t) a = o(i, n) / n * 1e3;else if (\"paintFirst\" === t) {\n              var c = i.indexOf(\"fill\"),\n                  l = i.indexOf(\"stroke\");\n              i = \"fill\", -1 < c && -1 < l && l < c ? i = \"stroke\" : -1 === c && -1 < l && (i = \"stroke\");\n            } else a = h ? i.map(o) : o(i, n);\n          } else i = \"\";\n          return !h && isNaN(a) ? i : a;\n        }\n\n        function l(t) {\n          return new RegExp(\"^(\" + t.join(\"|\") + \")\\\\b\", \"i\");\n        }\n\n        function u(t, e) {\n          var i,\n              r,\n              n,\n              o,\n              s = [];\n\n          for (n = 0, o = e.length; n < o; n++) {\n            i = e[n], r = t.getElementsByTagName(i), s = s.concat(Array.prototype.slice.call(r));\n          }\n\n          return s;\n        }\n\n        function f(t, e) {\n          var i,\n              r = !0;\n          return (i = d(t, e.pop())) && e.length && (r = function (t, e) {\n            for (var i, r = !0; t.parentNode && 1 === t.parentNode.nodeType && e.length;) {\n              r && (i = e.pop()), r = d(t = t.parentNode, i);\n            }\n\n            return 0 === e.length;\n          }(t, e)), i && r && 0 === e.length;\n        }\n\n        function d(t, e) {\n          var i,\n              r,\n              n = t.nodeName,\n              o = t.getAttribute(\"class\"),\n              s = t.getAttribute(\"id\");\n          if (i = new RegExp(\"^\" + n, \"i\"), e = e.replace(i, \"\"), s && e.length && (i = new RegExp(\"#\" + s + \"(?![a-zA-Z\\\\-]+)\", \"i\"), e = e.replace(i, \"\")), o && e.length) for (r = (o = o.split(\" \")).length; r--;) {\n            i = new RegExp(\"\\\\.\" + o[r] + \"(?![a-zA-Z\\\\-]+)\", \"i\"), e = e.replace(i, \"\");\n          }\n          return 0 === e.length;\n        }\n\n        function g(t, e) {\n          var i;\n          if (t.getElementById && (i = t.getElementById(e)), i) return i;\n          var r,\n              n,\n              o,\n              s = t.getElementsByTagName(\"*\");\n\n          for (n = 0, o = s.length; n < o; n++) {\n            if (e === (r = s[n]).getAttribute(\"id\")) return r;\n          }\n        }\n\n        e.svgValidTagNamesRegEx = l([\"path\", \"circle\", \"polygon\", \"polyline\", \"ellipse\", \"rect\", \"line\", \"image\", \"text\"]), e.svgViewBoxElementsRegEx = l([\"symbol\", \"image\", \"marker\", \"pattern\", \"view\", \"svg\"]), e.svgInvalidAncestorsRegEx = l([\"pattern\", \"defs\", \"symbol\", \"metadata\", \"clipPath\", \"mask\", \"desc\"]), e.svgValidParentsRegEx = l([\"symbol\", \"g\", \"a\", \"svg\", \"clipPath\", \"defs\"]), e.cssRules = {}, e.gradientDefs = {}, e.clipPaths = {}, e.parseTransformAttribute = function () {\n          function t(t, i, r) {\n            t[r] = Math.tan(e.util.degreesToRadians(i[0]));\n          }\n\n          var i = [1, 0, 0, 1, 0, 0],\n              r = e.reNum,\n              n = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\",\n              o = \"(?:(?:(matrix)\\\\s*\\\\(\\\\s*(\" + r + \")\" + n + \"(\" + r + \")\" + n + \"(\" + r + \")\" + n + \"(\" + r + \")\" + n + \"(\" + r + \")\" + n + \"(\" + r + \")\\\\s*\\\\))|(?:(translate)\\\\s*\\\\(\\\\s*(\" + r + \")(?:\" + n + \"(\" + r + \"))?\\\\s*\\\\))|(?:(scale)\\\\s*\\\\(\\\\s*(\" + r + \")(?:\" + n + \"(\" + r + \"))?\\\\s*\\\\))|(?:(rotate)\\\\s*\\\\(\\\\s*(\" + r + \")(?:\" + n + \"(\" + r + \")\" + n + \"(\" + r + \"))?\\\\s*\\\\))|(?:(skewX)\\\\s*\\\\(\\\\s*(\" + r + \")\\\\s*\\\\))|(?:(skewY)\\\\s*\\\\(\\\\s*(\" + r + \")\\\\s*\\\\)))\",\n              s = new RegExp(\"^\\\\s*(?:(?:\" + o + \"(?:\" + n + \"*\" + o + \")*)?)\\\\s*$\"),\n              a = new RegExp(o, \"g\");\n          return function (r) {\n            var n = i.concat(),\n                h = [];\n            if (!r || r && !s.test(r)) return n;\n            r.replace(a, function (r) {\n              var s,\n                  a,\n                  c,\n                  l,\n                  u,\n                  f,\n                  d,\n                  g,\n                  p,\n                  v,\n                  m,\n                  y,\n                  _ = new RegExp(o).exec(r).filter(function (t) {\n                return !!t;\n              }),\n                  b = _[1],\n                  x = _.slice(2).map(parseFloat);\n\n              switch (b) {\n                case \"translate\":\n                  y = x, (m = n)[4] = y[0], 2 === y.length && (m[5] = y[1]);\n                  break;\n\n                case \"rotate\":\n                  x[0] = e.util.degreesToRadians(x[0]), u = n, f = x, d = e.util.cos(f[0]), g = e.util.sin(f[0]), v = p = 0, 3 === f.length && (p = f[1], v = f[2]), u[0] = d, u[1] = g, u[2] = -g, u[3] = d, u[4] = p - (d * p - g * v), u[5] = v - (g * p + d * v);\n                  break;\n\n                case \"scale\":\n                  s = n, c = (a = x)[0], l = 2 === a.length ? a[1] : a[0], s[0] = c, s[3] = l;\n                  break;\n\n                case \"skewX\":\n                  t(n, x, 2);\n                  break;\n\n                case \"skewY\":\n                  t(n, x, 1);\n                  break;\n\n                case \"matrix\":\n                  n = x;\n              }\n\n              h.push(n.concat()), n = i.concat();\n            });\n\n            for (var c = h[0]; 1 < h.length;) {\n              h.shift(), c = e.util.multiplyTransformMatrices(c, h[0]);\n            }\n\n            return c;\n          };\n        }();\n        var p = new RegExp(\"^\\\\s*(\" + e.reNum + \"+)\\\\s*,?\\\\s*(\" + e.reNum + \"+)\\\\s*,?\\\\s*(\" + e.reNum + \"+)\\\\s*,?\\\\s*(\" + e.reNum + \"+)\\\\s*$\");\n\n        function v(t) {\n          var i,\n              r,\n              n,\n              s,\n              a,\n              h,\n              c = t.getAttribute(\"viewBox\"),\n              l = 1,\n              u = 1,\n              f = t.getAttribute(\"width\"),\n              d = t.getAttribute(\"height\"),\n              g = t.getAttribute(\"x\") || 0,\n              v = t.getAttribute(\"y\") || 0,\n              m = t.getAttribute(\"preserveAspectRatio\") || \"\",\n              y = !c || !e.svgViewBoxElementsRegEx.test(t.nodeName) || !(c = c.match(p)),\n              _ = !f || !d || \"100%\" === f || \"100%\" === d,\n              b = y && _,\n              x = {},\n              C = \"\",\n              S = 0,\n              w = 0;\n\n          if (x.width = 0, x.height = 0, x.toBeParsed = b) return x;\n          if (y) return x.width = o(f), x.height = o(d), x;\n          if (i = -parseFloat(c[1]), r = -parseFloat(c[2]), n = parseFloat(c[3]), s = parseFloat(c[4]), _ ? (x.width = n, x.height = s) : (x.width = o(f), x.height = o(d), l = x.width / n, u = x.height / s), \"none\" !== (m = e.util.parsePreserveAspectRatioAttribute(m)).alignX && (\"meet\" === m.meetOrSlice && (u = l = u < l ? u : l), \"slice\" === m.meetOrSlice && (u = l = u < l ? l : u), S = x.width - n * l, w = x.height - s * l, \"Mid\" === m.alignX && (S /= 2), \"Mid\" === m.alignY && (w /= 2), \"Min\" === m.alignX && (S = 0), \"Min\" === m.alignY && (w = 0)), 1 === l && 1 === u && 0 === i && 0 === r && 0 === g && 0 === v) return x;\n\n          if ((g || v) && (C = \" translate(\" + o(g) + \" \" + o(v) + \") \"), a = C + \" matrix(\" + l + \" 0 0 \" + u + \" \" + (i * l + S) + \" \" + (r * u + w) + \") \", x.viewboxTransform = e.parseTransformAttribute(a), \"svg\" === t.nodeName) {\n            for (h = t.ownerDocument.createElement(\"g\"); t.firstChild;) {\n              h.appendChild(t.firstChild);\n            }\n\n            t.appendChild(h);\n          } else a = (h = t).getAttribute(\"transform\") + a;\n\n          return h.setAttribute(\"transform\", a), x;\n        }\n\n        e.parseSVGDocument = function (t, i, n, o) {\n          if (t) {\n            !function (t) {\n              for (var e = u(t, [\"use\", \"svg:use\"]), i = 0; e.length && i < e.length;) {\n                var r,\n                    n,\n                    o,\n                    s,\n                    a = e[i],\n                    h = (a.getAttribute(\"xlink:href\") || a.getAttribute(\"href\")).substr(1),\n                    c = a.getAttribute(\"x\") || 0,\n                    l = a.getAttribute(\"y\") || 0,\n                    f = g(t, h).cloneNode(!0),\n                    d = (f.getAttribute(\"transform\") || \"\") + \" translate(\" + c + \", \" + l + \")\",\n                    p = e.length;\n\n                if (v(f), /^svg$/i.test(f.nodeName)) {\n                  var m = f.ownerDocument.createElement(\"g\");\n\n                  for (n = 0, s = (o = f.attributes).length; n < s; n++) {\n                    r = o.item(n), m.setAttribute(r.nodeName, r.nodeValue);\n                  }\n\n                  for (; f.firstChild;) {\n                    m.appendChild(f.firstChild);\n                  }\n\n                  f = m;\n                }\n\n                for (n = 0, s = (o = a.attributes).length; n < s; n++) {\n                  \"x\" !== (r = o.item(n)).nodeName && \"y\" !== r.nodeName && \"xlink:href\" !== r.nodeName && \"href\" !== r.nodeName && (\"transform\" === r.nodeName ? d = r.nodeValue + \" \" + d : f.setAttribute(r.nodeName, r.nodeValue));\n                }\n\n                f.setAttribute(\"transform\", d), f.setAttribute(\"instantiated_by_use\", \"1\"), f.removeAttribute(\"id\"), a.parentNode.replaceChild(f, a), e.length === p && i++;\n              }\n            }(t);\n            var s,\n                a,\n                h = e.Object.__uid++,\n                c = v(t),\n                l = e.util.toArray(t.getElementsByTagName(\"*\"));\n\n            if (c.crossOrigin = o && o.crossOrigin, c.svgUid = h, 0 === l.length && e.isLikelyNode) {\n              var f = [];\n\n              for (s = 0, a = (l = t.selectNodes('//*[name(.)!=\"svg\"]')).length; s < a; s++) {\n                f[s] = l[s];\n              }\n\n              l = f;\n            }\n\n            var d = l.filter(function (t) {\n              return v(t), e.svgValidTagNamesRegEx.test(t.nodeName.replace(\"svg:\", \"\")) && !function (t, e) {\n                for (; t && (t = t.parentNode);) {\n                  if (t.nodeName && e.test(t.nodeName.replace(\"svg:\", \"\")) && !t.getAttribute(\"instantiated_by_use\")) return !0;\n                }\n\n                return !1;\n              }(t, e.svgInvalidAncestorsRegEx);\n            });\n            if (!d || d && !d.length) i && i([], {});else {\n              var p = {};\n              l.filter(function (t) {\n                return \"clipPath\" === t.nodeName.replace(\"svg:\", \"\");\n              }).forEach(function (t) {\n                var i = t.getAttribute(\"id\");\n                p[i] = e.util.toArray(t.getElementsByTagName(\"*\")).filter(function (t) {\n                  return e.svgValidTagNamesRegEx.test(t.nodeName.replace(\"svg:\", \"\"));\n                });\n              }), e.gradientDefs[h] = e.getGradientDefs(t), e.cssRules[h] = e.getCSSRules(t), e.clipPaths[h] = p, e.parseElements(d, function (t, r) {\n                i && (i(t, c, r, l), delete e.gradientDefs[h], delete e.cssRules[h], delete e.clipPaths[h]);\n              }, r(c), n, o);\n            }\n          }\n        };\n\n        var m = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + e.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + e.reNum + \"))?\\\\s+(.*)\");\n        i(e, {\n          parseFontDeclaration: function parseFontDeclaration(t, e) {\n            var i = t.match(m);\n\n            if (i) {\n              var r = i[1],\n                  n = i[3],\n                  s = i[4],\n                  a = i[5],\n                  h = i[6];\n              r && (e.fontStyle = r), n && (e.fontWeight = isNaN(parseFloat(n)) ? n : parseFloat(n)), s && (e.fontSize = o(s)), h && (e.fontFamily = h), a && (e.lineHeight = \"normal\" === a ? 1 : a);\n            }\n          },\n          getGradientDefs: function getGradientDefs(t) {\n            var e,\n                i,\n                r,\n                n = u(t, [\"linearGradient\", \"radialGradient\", \"svg:linearGradient\", \"svg:radialGradient\"]),\n                o = 0,\n                s = {},\n                a = {};\n\n            for (o = n.length; o--;) {\n              r = (e = n[o]).getAttribute(\"xlink:href\"), i = e.getAttribute(\"id\"), r && (a[i] = r.substr(1)), s[i] = e;\n            }\n\n            for (i in a) {\n              var h = s[a[i]].cloneNode(!0);\n\n              for (e = s[i]; h.firstChild;) {\n                e.appendChild(h.firstChild);\n              }\n            }\n\n            return s;\n          },\n          parseAttributes: function parseAttributes(t, r, o) {\n            if (t) {\n              var s,\n                  l,\n                  u = {};\n              void 0 === o && (o = t.getAttribute(\"svgUid\")), t.parentNode && e.svgValidParentsRegEx.test(t.parentNode.nodeName) && (u = e.parseAttributes(t.parentNode, r, o));\n              var d = r.reduce(function (e, i) {\n                return (s = t.getAttribute(i)) && (e[i] = s), e;\n              }, {});\n              d = i(d, i(function (t, i) {\n                var r = {};\n\n                for (var n in e.cssRules[i]) {\n                  if (f(t, n.split(\" \"))) for (var o in e.cssRules[i][n]) {\n                    r[o] = e.cssRules[i][n][o];\n                  }\n                }\n\n                return r;\n              }(t, o), e.parseStyleAttribute(t))), l = u && u.fontSize || d[\"font-size\"] || e.Text.DEFAULT_SVG_FONT_SIZE;\n              var g,\n                  p,\n                  v,\n                  m = {};\n\n              for (var y in d) {\n                p = c(g = (v = y) in a ? a[v] : v, d[y], u, l), m[g] = p;\n              }\n\n              m && m.font && e.parseFontDeclaration(m.font, m);\n\n              var _ = i(u, m);\n\n              return e.svgValidParentsRegEx.test(t.nodeName) ? _ : function (t) {\n                for (var i in h) {\n                  if (void 0 !== t[h[i]] && \"\" !== t[i]) {\n                    if (void 0 === t[i]) {\n                      if (!e.Object.prototype[i]) continue;\n                      t[i] = e.Object.prototype[i];\n                    }\n\n                    if (0 !== t[i].indexOf(\"url(\")) {\n                      var r = new e.Color(t[i]);\n                      t[i] = r.setAlpha(n(r.getAlpha() * t[h[i]], 2)).toRgba();\n                    }\n                  }\n                }\n\n                return t;\n              }(_);\n            }\n          },\n          parseElements: function parseElements(t, i, r, n, o) {\n            new e.ElementsParser(t, i, r, n, o).parse();\n          },\n          parseStyleAttribute: function parseStyleAttribute(t) {\n            var e,\n                i,\n                r,\n                n = {},\n                o = t.getAttribute(\"style\");\n            return o && (\"string\" == typeof o ? (e = n, o.replace(/;\\s*$/, \"\").split(\";\").forEach(function (t) {\n              var n = t.split(\":\");\n              i = n[0].trim().toLowerCase(), r = n[1].trim(), e[i] = r;\n            })) : function (t, e) {\n              var i, r;\n\n              for (var n in t) {\n                void 0 !== t[n] && (i = n.toLowerCase(), r = t[n], e[i] = r);\n              }\n            }(o, n)), n;\n          },\n          parsePointsAttribute: function parsePointsAttribute(t) {\n            if (!t) return null;\n            var e,\n                i,\n                r = [];\n\n            for (e = 0, i = (t = (t = t.replace(/,/g, \" \").trim()).split(/\\s+/)).length; e < i; e += 2) {\n              r.push({\n                x: parseFloat(t[e]),\n                y: parseFloat(t[e + 1])\n              });\n            }\n\n            return r;\n          },\n          getCSSRules: function getCSSRules(t) {\n            var i,\n                r,\n                n = t.getElementsByTagName(\"style\"),\n                o = {};\n\n            for (i = 0, r = n.length; i < r; i++) {\n              var s = n[i].textContent || n[i].text;\n              \"\" !== (s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\")).trim() && s.match(/[^{]*\\{[\\s\\S]*?\\}/g).map(function (t) {\n                return t.trim();\n              }).forEach(function (t) {\n                var n = t.match(/([\\s\\S]*?)\\s*\\{([^}]*)\\}/),\n                    s = {},\n                    a = n[2].trim().replace(/;$/, \"\").split(/\\s*;\\s*/);\n\n                for (i = 0, r = a.length; i < r; i++) {\n                  var h = a[i].split(/\\s*:\\s*/),\n                      c = h[0],\n                      l = h[1];\n                  s[c] = l;\n                }\n\n                (t = n[1]).split(\",\").forEach(function (t) {\n                  \"\" !== (t = t.replace(/^svg/i, \"\").trim()) && (o[t] ? e.util.object.extend(o[t], s) : o[t] = e.util.object.clone(s));\n                });\n              });\n            }\n\n            return o;\n          },\n          loadSVGFromURL: function loadSVGFromURL(t, i, r, n) {\n            t = t.replace(/^\\n\\s*/, \"\").trim(), new e.util.request(t, {\n              method: \"get\",\n              onComplete: function onComplete(t) {\n                var o = t.responseXML;\n                if (o && !o.documentElement && e.window.ActiveXObject && t.responseText && ((o = new ActiveXObject(\"Microsoft.XMLDOM\")).async = \"false\", o.loadXML(t.responseText.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, \"\"))), !o || !o.documentElement) return i && i(null), !1;\n                e.parseSVGDocument(o.documentElement, function (t, e, r, n) {\n                  i && i(t, e, r, n);\n                }, r, n);\n              }\n            });\n          },\n          loadSVGFromString: function loadSVGFromString(t, i, r, n) {\n            var o;\n\n            if (t = t.trim(), \"undefined\" != typeof DOMParser) {\n              var s = new DOMParser();\n              s && s.parseFromString && (o = s.parseFromString(t, \"text/xml\"));\n            } else e.window.ActiveXObject && ((o = new ActiveXObject(\"Microsoft.XMLDOM\")).async = \"false\", o.loadXML(t.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, \"\")));\n\n            e.parseSVGDocument(o.documentElement, function (t, e, r, n) {\n              i(t, e, r, n);\n            }, r, n);\n          }\n        });\n      }(e), A.ElementsParser = function (t, e, i, r, n) {\n        this.elements = t, this.callback = e, this.options = i, this.reviver = r, this.svgUid = i && i.svgUid || 0, this.parsingOptions = n, this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n      }, (p = A.ElementsParser.prototype).parse = function () {\n        this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects();\n      }, p.createObjects = function () {\n        var t = this;\n        this.elements.forEach(function (e, i) {\n          e.setAttribute(\"svgUid\", t.svgUid), t.createObject(e, i);\n        });\n      }, p.findTag = function (t) {\n        return A[A.util.string.capitalize(t.tagName.replace(\"svg:\", \"\"))];\n      }, p.createObject = function (t, e) {\n        var i = this.findTag(t);\n        if (i && i.fromElement) try {\n          i.fromElement(t, this.createCallback(e, t), this.options);\n        } catch (t) {\n          A.log(t);\n        } else this.checkIfDone();\n      }, p.createCallback = function (t, e) {\n        var i = this;\n        return function (r) {\n          var n;\n          i.resolveGradient(r, \"fill\"), i.resolveGradient(r, \"stroke\"), r instanceof A.Image && (n = r.parsePreserveAspectRatioAttribute(e)), r._removeTransformMatrix(n), i.resolveClipPath(r), i.reviver && i.reviver(e, r), i.instances[t] = r, i.checkIfDone();\n        };\n      }, p.extractPropertyDefinition = function (t, e, i) {\n        var r = t[e];\n\n        if (/^url\\(/.test(r)) {\n          var n = this.regexUrl.exec(r)[1];\n          return this.regexUrl.lastIndex = 0, A[i][this.svgUid][n];\n        }\n      }, p.resolveGradient = function (t, e) {\n        var i = this.extractPropertyDefinition(t, e, \"gradientDefs\");\n        i && t.set(e, A.Gradient.fromElement(i, t));\n      }, p.createClipPathCallback = function (t, e) {\n        return function (t) {\n          t._removeTransformMatrix(), t.fillRule = t.clipRule, e.push(t);\n        };\n      }, p.resolveClipPath = function (t) {\n        var e,\n            i,\n            r,\n            n,\n            o = this.extractPropertyDefinition(t, \"clipPath\", \"clipPaths\");\n\n        if (o) {\n          r = [], i = A.util.invertTransform(t.calcTransformMatrix());\n\n          for (var s = 0; s < o.length; s++) {\n            e = o[s], this.findTag(e).fromElement(e, this.createClipPathCallback(t, r), this.options);\n          }\n\n          o = 1 === r.length ? r[0] : new A.Group(r), n = A.util.multiplyTransformMatrices(i, o.calcTransformMatrix());\n          var a = A.util.qrDecompose(n);\n          o.flipX = !1, o.flipY = !1, o.set(\"scaleX\", a.scaleX), o.set(\"scaleY\", a.scaleY), o.angle = a.angle, o.skewX = a.skewX, o.skewY = 0, o.setPositionByOrigin({\n            x: a.translateX,\n            y: a.translateY\n          }, \"center\", \"center\"), t.clipPath = o;\n        }\n      }, p.checkIfDone = function () {\n        0 == --this.numElements && (this.instances = this.instances.filter(function (t) {\n          return null != t;\n        }), this.callback(this.instances, this.elements));\n      }, function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n\n        function i(t, e) {\n          this.x = t, this.y = e;\n        }\n\n        e.Point ? e.warn(\"fabric.Point is already defined\") : (e.Point = i).prototype = {\n          type: \"point\",\n          constructor: i,\n          add: function add(t) {\n            return new i(this.x + t.x, this.y + t.y);\n          },\n          addEquals: function addEquals(t) {\n            return this.x += t.x, this.y += t.y, this;\n          },\n          scalarAdd: function scalarAdd(t) {\n            return new i(this.x + t, this.y + t);\n          },\n          scalarAddEquals: function scalarAddEquals(t) {\n            return this.x += t, this.y += t, this;\n          },\n          subtract: function subtract(t) {\n            return new i(this.x - t.x, this.y - t.y);\n          },\n          subtractEquals: function subtractEquals(t) {\n            return this.x -= t.x, this.y -= t.y, this;\n          },\n          scalarSubtract: function scalarSubtract(t) {\n            return new i(this.x - t, this.y - t);\n          },\n          scalarSubtractEquals: function scalarSubtractEquals(t) {\n            return this.x -= t, this.y -= t, this;\n          },\n          multiply: function multiply(t) {\n            return new i(this.x * t, this.y * t);\n          },\n          multiplyEquals: function multiplyEquals(t) {\n            return this.x *= t, this.y *= t, this;\n          },\n          divide: function divide(t) {\n            return new i(this.x / t, this.y / t);\n          },\n          divideEquals: function divideEquals(t) {\n            return this.x /= t, this.y /= t, this;\n          },\n          eq: function eq(t) {\n            return this.x === t.x && this.y === t.y;\n          },\n          lt: function lt(t) {\n            return this.x < t.x && this.y < t.y;\n          },\n          lte: function lte(t) {\n            return this.x <= t.x && this.y <= t.y;\n          },\n          gt: function gt(t) {\n            return this.x > t.x && this.y > t.y;\n          },\n          gte: function gte(t) {\n            return this.x >= t.x && this.y >= t.y;\n          },\n          lerp: function lerp(t, e) {\n            return void 0 === e && (e = .5), e = Math.max(Math.min(1, e), 0), new i(this.x + (t.x - this.x) * e, this.y + (t.y - this.y) * e);\n          },\n          distanceFrom: function distanceFrom(t) {\n            var e = this.x - t.x,\n                i = this.y - t.y;\n            return Math.sqrt(e * e + i * i);\n          },\n          midPointFrom: function midPointFrom(t) {\n            return this.lerp(t);\n          },\n          min: function min(t) {\n            return new i(Math.min(this.x, t.x), Math.min(this.y, t.y));\n          },\n          max: function max(t) {\n            return new i(Math.max(this.x, t.x), Math.max(this.y, t.y));\n          },\n          toString: function toString() {\n            return this.x + \",\" + this.y;\n          },\n          setXY: function setXY(t, e) {\n            return this.x = t, this.y = e, this;\n          },\n          setX: function setX(t) {\n            return this.x = t, this;\n          },\n          setY: function setY(t) {\n            return this.y = t, this;\n          },\n          setFromPoint: function setFromPoint(t) {\n            return this.x = t.x, this.y = t.y, this;\n          },\n          swap: function swap(t) {\n            var e = this.x,\n                i = this.y;\n            this.x = t.x, this.y = t.y, t.x = e, t.y = i;\n          },\n          clone: function clone() {\n            return new i(this.x, this.y);\n          }\n        };\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n\n        function i(t) {\n          this.status = t, this.points = [];\n        }\n\n        e.Intersection ? e.warn(\"fabric.Intersection is already defined\") : (e.Intersection = i, e.Intersection.prototype = {\n          constructor: i,\n          appendPoint: function appendPoint(t) {\n            return this.points.push(t), this;\n          },\n          appendPoints: function appendPoints(t) {\n            return this.points = this.points.concat(t), this;\n          }\n        }, e.Intersection.intersectLineLine = function (t, r, n, o) {\n          var s,\n              a = (o.x - n.x) * (t.y - n.y) - (o.y - n.y) * (t.x - n.x),\n              h = (r.x - t.x) * (t.y - n.y) - (r.y - t.y) * (t.x - n.x),\n              c = (o.y - n.y) * (r.x - t.x) - (o.x - n.x) * (r.y - t.y);\n\n          if (0 !== c) {\n            var l = a / c,\n                u = h / c;\n            0 <= l && l <= 1 && 0 <= u && u <= 1 ? (s = new i(\"Intersection\")).appendPoint(new e.Point(t.x + l * (r.x - t.x), t.y + l * (r.y - t.y))) : s = new i();\n          } else s = new i(0 === a || 0 === h ? \"Coincident\" : \"Parallel\");\n\n          return s;\n        }, e.Intersection.intersectLinePolygon = function (t, e, r) {\n          var n,\n              o,\n              s,\n              a,\n              h = new i(),\n              c = r.length;\n\n          for (a = 0; a < c; a++) {\n            n = r[a], o = r[(a + 1) % c], s = i.intersectLineLine(t, e, n, o), h.appendPoints(s.points);\n          }\n\n          return 0 < h.points.length && (h.status = \"Intersection\"), h;\n        }, e.Intersection.intersectPolygonPolygon = function (t, e) {\n          var r,\n              n = new i(),\n              o = t.length;\n\n          for (r = 0; r < o; r++) {\n            var s = t[r],\n                a = t[(r + 1) % o],\n                h = i.intersectLinePolygon(s, a, e);\n            n.appendPoints(h.points);\n          }\n\n          return 0 < n.points.length && (n.status = \"Intersection\"), n;\n        }, e.Intersection.intersectPolygonRectangle = function (t, r, n) {\n          var o = r.min(n),\n              s = r.max(n),\n              a = new e.Point(s.x, o.y),\n              h = new e.Point(o.x, s.y),\n              c = i.intersectLinePolygon(o, a, t),\n              l = i.intersectLinePolygon(a, s, t),\n              u = i.intersectLinePolygon(s, h, t),\n              f = i.intersectLinePolygon(h, o, t),\n              d = new i();\n          return d.appendPoints(c.points), d.appendPoints(l.points), d.appendPoints(u.points), d.appendPoints(f.points), 0 < d.points.length && (d.status = \"Intersection\"), d;\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n\n        function i(t) {\n          t ? this._tryParsingColor(t) : this.setSource([0, 0, 0, 1]);\n        }\n\n        function r(t, e, i) {\n          return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t;\n        }\n\n        e.Color ? e.warn(\"fabric.Color is already defined.\") : (e.Color = i, e.Color.prototype = {\n          _tryParsingColor: function _tryParsingColor(t) {\n            var e;\n            t in i.colorNameMap && (t = i.colorNameMap[t]), \"transparent\" === t && (e = [255, 255, 255, 0]), e || (e = i.sourceFromHex(t)), e || (e = i.sourceFromRgb(t)), e || (e = i.sourceFromHsl(t)), e || (e = [0, 0, 0, 1]), e && this.setSource(e);\n          },\n          _rgbToHsl: function _rgbToHsl(t, i, r) {\n            t /= 255, i /= 255, r /= 255;\n            var n,\n                o,\n                s,\n                a = e.util.array.max([t, i, r]),\n                h = e.util.array.min([t, i, r]);\n            if (s = (a + h) / 2, a === h) n = o = 0;else {\n              var c = a - h;\n\n              switch (o = .5 < s ? c / (2 - a - h) : c / (a + h), a) {\n                case t:\n                  n = (i - r) / c + (i < r ? 6 : 0);\n                  break;\n\n                case i:\n                  n = (r - t) / c + 2;\n                  break;\n\n                case r:\n                  n = (t - i) / c + 4;\n              }\n\n              n /= 6;\n            }\n            return [Math.round(360 * n), Math.round(100 * o), Math.round(100 * s)];\n          },\n          getSource: function getSource() {\n            return this._source;\n          },\n          setSource: function setSource(t) {\n            this._source = t;\n          },\n          toRgb: function toRgb() {\n            var t = this.getSource();\n            return \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\";\n          },\n          toRgba: function toRgba() {\n            var t = this.getSource();\n            return \"rgba(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \",\" + t[3] + \")\";\n          },\n          toHsl: function toHsl() {\n            var t = this.getSource(),\n                e = this._rgbToHsl(t[0], t[1], t[2]);\n\n            return \"hsl(\" + e[0] + \",\" + e[1] + \"%,\" + e[2] + \"%)\";\n          },\n          toHsla: function toHsla() {\n            var t = this.getSource(),\n                e = this._rgbToHsl(t[0], t[1], t[2]);\n\n            return \"hsla(\" + e[0] + \",\" + e[1] + \"%,\" + e[2] + \"%,\" + t[3] + \")\";\n          },\n          toHex: function toHex() {\n            var t,\n                e,\n                i,\n                r = this.getSource();\n            return t = 1 === (t = r[0].toString(16)).length ? \"0\" + t : t, e = 1 === (e = r[1].toString(16)).length ? \"0\" + e : e, i = 1 === (i = r[2].toString(16)).length ? \"0\" + i : i, t.toUpperCase() + e.toUpperCase() + i.toUpperCase();\n          },\n          toHexa: function toHexa() {\n            var t,\n                e = this.getSource();\n            return t = 1 === (t = (t = Math.round(255 * e[3])).toString(16)).length ? \"0\" + t : t, this.toHex() + t.toUpperCase();\n          },\n          getAlpha: function getAlpha() {\n            return this.getSource()[3];\n          },\n          setAlpha: function setAlpha(t) {\n            var e = this.getSource();\n            return e[3] = t, this.setSource(e), this;\n          },\n          toGrayscale: function toGrayscale() {\n            var t = this.getSource(),\n                e = parseInt((.3 * t[0] + .59 * t[1] + .11 * t[2]).toFixed(0), 10),\n                i = t[3];\n            return this.setSource([e, e, e, i]), this;\n          },\n          toBlackWhite: function toBlackWhite(t) {\n            var e = this.getSource(),\n                i = (.3 * e[0] + .59 * e[1] + .11 * e[2]).toFixed(0),\n                r = e[3];\n            return t = t || 127, i = Number(i) < Number(t) ? 0 : 255, this.setSource([i, i, i, r]), this;\n          },\n          overlayWith: function overlayWith(t) {\n            t instanceof i || (t = new i(t));\n            var e,\n                r = [],\n                n = this.getAlpha(),\n                o = this.getSource(),\n                s = t.getSource();\n\n            for (e = 0; e < 3; e++) {\n              r.push(Math.round(.5 * o[e] + .5 * s[e]));\n            }\n\n            return r[3] = n, this.setSource(r), this;\n          }\n        }, e.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i, e.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i, e.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, e.Color.colorNameMap = {\n          aliceblue: \"#F0F8FF\",\n          antiquewhite: \"#FAEBD7\",\n          aqua: \"#00FFFF\",\n          aquamarine: \"#7FFFD4\",\n          azure: \"#F0FFFF\",\n          beige: \"#F5F5DC\",\n          bisque: \"#FFE4C4\",\n          black: \"#000000\",\n          blanchedalmond: \"#FFEBCD\",\n          blue: \"#0000FF\",\n          blueviolet: \"#8A2BE2\",\n          brown: \"#A52A2A\",\n          burlywood: \"#DEB887\",\n          cadetblue: \"#5F9EA0\",\n          chartreuse: \"#7FFF00\",\n          chocolate: \"#D2691E\",\n          coral: \"#FF7F50\",\n          cornflowerblue: \"#6495ED\",\n          cornsilk: \"#FFF8DC\",\n          crimson: \"#DC143C\",\n          cyan: \"#00FFFF\",\n          darkblue: \"#00008B\",\n          darkcyan: \"#008B8B\",\n          darkgoldenrod: \"#B8860B\",\n          darkgray: \"#A9A9A9\",\n          darkgrey: \"#A9A9A9\",\n          darkgreen: \"#006400\",\n          darkkhaki: \"#BDB76B\",\n          darkmagenta: \"#8B008B\",\n          darkolivegreen: \"#556B2F\",\n          darkorange: \"#FF8C00\",\n          darkorchid: \"#9932CC\",\n          darkred: \"#8B0000\",\n          darksalmon: \"#E9967A\",\n          darkseagreen: \"#8FBC8F\",\n          darkslateblue: \"#483D8B\",\n          darkslategray: \"#2F4F4F\",\n          darkslategrey: \"#2F4F4F\",\n          darkturquoise: \"#00CED1\",\n          darkviolet: \"#9400D3\",\n          deeppink: \"#FF1493\",\n          deepskyblue: \"#00BFFF\",\n          dimgray: \"#696969\",\n          dimgrey: \"#696969\",\n          dodgerblue: \"#1E90FF\",\n          firebrick: \"#B22222\",\n          floralwhite: \"#FFFAF0\",\n          forestgreen: \"#228B22\",\n          fuchsia: \"#FF00FF\",\n          gainsboro: \"#DCDCDC\",\n          ghostwhite: \"#F8F8FF\",\n          gold: \"#FFD700\",\n          goldenrod: \"#DAA520\",\n          gray: \"#808080\",\n          grey: \"#808080\",\n          green: \"#008000\",\n          greenyellow: \"#ADFF2F\",\n          honeydew: \"#F0FFF0\",\n          hotpink: \"#FF69B4\",\n          indianred: \"#CD5C5C\",\n          indigo: \"#4B0082\",\n          ivory: \"#FFFFF0\",\n          khaki: \"#F0E68C\",\n          lavender: \"#E6E6FA\",\n          lavenderblush: \"#FFF0F5\",\n          lawngreen: \"#7CFC00\",\n          lemonchiffon: \"#FFFACD\",\n          lightblue: \"#ADD8E6\",\n          lightcoral: \"#F08080\",\n          lightcyan: \"#E0FFFF\",\n          lightgoldenrodyellow: \"#FAFAD2\",\n          lightgray: \"#D3D3D3\",\n          lightgrey: \"#D3D3D3\",\n          lightgreen: \"#90EE90\",\n          lightpink: \"#FFB6C1\",\n          lightsalmon: \"#FFA07A\",\n          lightseagreen: \"#20B2AA\",\n          lightskyblue: \"#87CEFA\",\n          lightslategray: \"#778899\",\n          lightslategrey: \"#778899\",\n          lightsteelblue: \"#B0C4DE\",\n          lightyellow: \"#FFFFE0\",\n          lime: \"#00FF00\",\n          limegreen: \"#32CD32\",\n          linen: \"#FAF0E6\",\n          magenta: \"#FF00FF\",\n          maroon: \"#800000\",\n          mediumaquamarine: \"#66CDAA\",\n          mediumblue: \"#0000CD\",\n          mediumorchid: \"#BA55D3\",\n          mediumpurple: \"#9370DB\",\n          mediumseagreen: \"#3CB371\",\n          mediumslateblue: \"#7B68EE\",\n          mediumspringgreen: \"#00FA9A\",\n          mediumturquoise: \"#48D1CC\",\n          mediumvioletred: \"#C71585\",\n          midnightblue: \"#191970\",\n          mintcream: \"#F5FFFA\",\n          mistyrose: \"#FFE4E1\",\n          moccasin: \"#FFE4B5\",\n          navajowhite: \"#FFDEAD\",\n          navy: \"#000080\",\n          oldlace: \"#FDF5E6\",\n          olive: \"#808000\",\n          olivedrab: \"#6B8E23\",\n          orange: \"#FFA500\",\n          orangered: \"#FF4500\",\n          orchid: \"#DA70D6\",\n          palegoldenrod: \"#EEE8AA\",\n          palegreen: \"#98FB98\",\n          paleturquoise: \"#AFEEEE\",\n          palevioletred: \"#DB7093\",\n          papayawhip: \"#FFEFD5\",\n          peachpuff: \"#FFDAB9\",\n          peru: \"#CD853F\",\n          pink: \"#FFC0CB\",\n          plum: \"#DDA0DD\",\n          powderblue: \"#B0E0E6\",\n          purple: \"#800080\",\n          rebeccapurple: \"#663399\",\n          red: \"#FF0000\",\n          rosybrown: \"#BC8F8F\",\n          royalblue: \"#4169E1\",\n          saddlebrown: \"#8B4513\",\n          salmon: \"#FA8072\",\n          sandybrown: \"#F4A460\",\n          seagreen: \"#2E8B57\",\n          seashell: \"#FFF5EE\",\n          sienna: \"#A0522D\",\n          silver: \"#C0C0C0\",\n          skyblue: \"#87CEEB\",\n          slateblue: \"#6A5ACD\",\n          slategray: \"#708090\",\n          slategrey: \"#708090\",\n          snow: \"#FFFAFA\",\n          springgreen: \"#00FF7F\",\n          steelblue: \"#4682B4\",\n          tan: \"#D2B48C\",\n          teal: \"#008080\",\n          thistle: \"#D8BFD8\",\n          tomato: \"#FF6347\",\n          turquoise: \"#40E0D0\",\n          violet: \"#EE82EE\",\n          wheat: \"#F5DEB3\",\n          white: \"#FFFFFF\",\n          whitesmoke: \"#F5F5F5\",\n          yellow: \"#FFFF00\",\n          yellowgreen: \"#9ACD32\"\n        }, e.Color.fromRgb = function (t) {\n          return i.fromSource(i.sourceFromRgb(t));\n        }, e.Color.sourceFromRgb = function (t) {\n          var e = t.match(i.reRGBa);\n\n          if (e) {\n            var r = parseInt(e[1], 10) / (/%$/.test(e[1]) ? 100 : 1) * (/%$/.test(e[1]) ? 255 : 1),\n                n = parseInt(e[2], 10) / (/%$/.test(e[2]) ? 100 : 1) * (/%$/.test(e[2]) ? 255 : 1),\n                o = parseInt(e[3], 10) / (/%$/.test(e[3]) ? 100 : 1) * (/%$/.test(e[3]) ? 255 : 1);\n            return [parseInt(r, 10), parseInt(n, 10), parseInt(o, 10), e[4] ? parseFloat(e[4]) : 1];\n          }\n        }, e.Color.fromRgba = i.fromRgb, e.Color.fromHsl = function (t) {\n          return i.fromSource(i.sourceFromHsl(t));\n        }, e.Color.sourceFromHsl = function (t) {\n          var e = t.match(i.reHSLa);\n\n          if (e) {\n            var n,\n                o,\n                s,\n                a = (parseFloat(e[1]) % 360 + 360) % 360 / 360,\n                h = parseFloat(e[2]) / (/%$/.test(e[2]) ? 100 : 1),\n                c = parseFloat(e[3]) / (/%$/.test(e[3]) ? 100 : 1);\n            if (0 === h) n = o = s = c;else {\n              var l = c <= .5 ? c * (h + 1) : c + h - c * h,\n                  u = 2 * c - l;\n              n = r(u, l, a + 1 / 3), o = r(u, l, a), s = r(u, l, a - 1 / 3);\n            }\n            return [Math.round(255 * n), Math.round(255 * o), Math.round(255 * s), e[4] ? parseFloat(e[4]) : 1];\n          }\n        }, e.Color.fromHsla = i.fromHsl, e.Color.fromHex = function (t) {\n          return i.fromSource(i.sourceFromHex(t));\n        }, e.Color.sourceFromHex = function (t) {\n          if (t.match(i.reHex)) {\n            var e = t.slice(t.indexOf(\"#\") + 1),\n                r = 3 === e.length || 4 === e.length,\n                n = 8 === e.length || 4 === e.length,\n                o = r ? e.charAt(0) + e.charAt(0) : e.substring(0, 2),\n                s = r ? e.charAt(1) + e.charAt(1) : e.substring(2, 4),\n                a = r ? e.charAt(2) + e.charAt(2) : e.substring(4, 6),\n                h = n ? r ? e.charAt(3) + e.charAt(3) : e.substring(6, 8) : \"FF\";\n            return [parseInt(o, 16), parseInt(s, 16), parseInt(a, 16), parseFloat((parseInt(h, 16) / 255).toFixed(2))];\n          }\n        }, e.Color.fromSource = function (t) {\n          var e = new i();\n          return e.setSource(t), e;\n        });\n      }(e), function () {\n        function t(t) {\n          var e,\n              i,\n              r,\n              n,\n              o = t.getAttribute(\"style\"),\n              s = t.getAttribute(\"offset\") || 0;\n\n          if (s = (s = parseFloat(s) / (/%$/.test(s) ? 100 : 1)) < 0 ? 0 : 1 < s ? 1 : s, o) {\n            var a = o.split(/\\s*;\\s*/);\n\n            for (\"\" === a[a.length - 1] && a.pop(), n = a.length; n--;) {\n              var h = a[n].split(/\\s*:\\s*/),\n                  c = h[0].trim(),\n                  l = h[1].trim();\n              \"stop-color\" === c ? e = l : \"stop-opacity\" === c && (r = l);\n            }\n          }\n\n          return e || (e = t.getAttribute(\"stop-color\") || \"rgb(0,0,0)\"), r || (r = t.getAttribute(\"stop-opacity\")), i = (e = new A.Color(e)).getAlpha(), r = isNaN(parseFloat(r)) ? 1 : parseFloat(r), r *= i, {\n            offset: s,\n            color: e.toRgb(),\n            opacity: r\n          };\n        }\n\n        var e = A.util.object.clone;\n\n        function i(t, e, i) {\n          var r,\n              n = 0,\n              o = 1,\n              s = \"\";\n\n          for (var a in e) {\n            \"Infinity\" === e[a] ? e[a] = 1 : \"-Infinity\" === e[a] && (e[a] = 0), r = parseFloat(e[a], 10), o = \"string\" == typeof e[a] && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(e[a]) ? .01 : 1, \"x1\" === a || \"x2\" === a || \"r2\" === a ? (o *= \"objectBoundingBox\" === i ? t.width : 1, n = \"objectBoundingBox\" === i && t.left || 0) : \"y1\" !== a && \"y2\" !== a || (o *= \"objectBoundingBox\" === i ? t.height : 1, n = \"objectBoundingBox\" === i && t.top || 0), e[a] = r * o + n;\n          }\n\n          if (\"ellipse\" === t.type && null !== e.r2 && \"objectBoundingBox\" === i && t.rx !== t.ry) {\n            var h = t.ry / t.rx;\n            s = \" scale(1, \" + h + \")\", e.y1 && (e.y1 /= h), e.y2 && (e.y2 /= h);\n          }\n\n          return s;\n        }\n\n        A.Gradient = A.util.createClass({\n          offsetX: 0,\n          offsetY: 0,\n          initialize: function initialize(t) {\n            t || (t = {});\n            var e = {};\n            this.id = A.Object.__uid++, this.type = t.type || \"linear\", e = {\n              x1: t.coords.x1 || 0,\n              y1: t.coords.y1 || 0,\n              x2: t.coords.x2 || 0,\n              y2: t.coords.y2 || 0\n            }, \"radial\" === this.type && (e.r1 = t.coords.r1 || 0, e.r2 = t.coords.r2 || 0), this.coords = e, this.colorStops = t.colorStops.slice(), t.gradientTransform && (this.gradientTransform = t.gradientTransform), this.offsetX = t.offsetX || this.offsetX, this.offsetY = t.offsetY || this.offsetY;\n          },\n          addColorStop: function addColorStop(t) {\n            for (var e in t) {\n              var i = new A.Color(t[e]);\n              this.colorStops.push({\n                offset: parseFloat(e),\n                color: i.toRgb(),\n                opacity: i.getAlpha()\n              });\n            }\n\n            return this;\n          },\n          toObject: function toObject(t) {\n            var e = {\n              type: this.type,\n              coords: this.coords,\n              colorStops: this.colorStops,\n              offsetX: this.offsetX,\n              offsetY: this.offsetY,\n              gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            return A.util.populateWithProperties(this, e, t), e;\n          },\n          toSVG: function toSVG(t) {\n            var i,\n                r,\n                n,\n                o,\n                s = e(this.coords, !0),\n                a = e(this.colorStops, !0),\n                h = s.r1 > s.r2,\n                c = t.width / 2,\n                l = t.height / 2;\n\n            for (var u in a.sort(function (t, e) {\n              return t.offset - e.offset;\n            }), \"path\" === t.type && (c -= t.pathOffset.x, l -= t.pathOffset.y), s) {\n              \"x1\" === u || \"x2\" === u ? s[u] += this.offsetX - c : \"y1\" !== u && \"y2\" !== u || (s[u] += this.offsetY - l);\n            }\n\n            if (o = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"userSpaceOnUse\"', this.gradientTransform && (o += ' gradientTransform=\"matrix(' + this.gradientTransform.join(\" \") + ')\" '), \"linear\" === this.type ? n = [\"<linearGradient \", o, ' x1=\"', s.x1, '\" y1=\"', s.y1, '\" x2=\"', s.x2, '\" y2=\"', s.y2, '\">\\n'] : \"radial\" === this.type && (n = [\"<radialGradient \", o, ' cx=\"', h ? s.x1 : s.x2, '\" cy=\"', h ? s.y1 : s.y2, '\" r=\"', h ? s.r1 : s.r2, '\" fx=\"', h ? s.x2 : s.x1, '\" fy=\"', h ? s.y2 : s.y1, '\">\\n']), \"radial\" === this.type) {\n              if (h) for ((a = a.concat()).reverse(), i = 0, r = a.length; i < r; i++) {\n                a[i].offset = 1 - a[i].offset;\n              }\n              var f = Math.min(s.r1, s.r2);\n\n              if (0 < f) {\n                var d = f / Math.max(s.r1, s.r2);\n\n                for (i = 0, r = a.length; i < r; i++) {\n                  a[i].offset += d * (1 - a[i].offset);\n                }\n              }\n            }\n\n            for (i = 0, r = a.length; i < r; i++) {\n              var g = a[i];\n              n.push(\"<stop \", 'offset=\"', 100 * g.offset + \"%\", '\" style=\"stop-color:', g.color, void 0 !== g.opacity ? \";stop-opacity: \" + g.opacity : \";\", '\"/>\\n');\n            }\n\n            return n.push(\"linear\" === this.type ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\"), n.join(\"\");\n          },\n          toLive: function toLive(t) {\n            var e,\n                i,\n                r,\n                n = A.util.object.clone(this.coords);\n\n            if (this.type) {\n              for (\"linear\" === this.type ? e = t.createLinearGradient(n.x1, n.y1, n.x2, n.y2) : \"radial\" === this.type && (e = t.createRadialGradient(n.x1, n.y1, n.r1, n.x2, n.y2, n.r2)), i = 0, r = this.colorStops.length; i < r; i++) {\n                var o = this.colorStops[i].color,\n                    s = this.colorStops[i].opacity,\n                    a = this.colorStops[i].offset;\n                void 0 !== s && (o = new A.Color(o).setAlpha(s).toRgba()), e.addColorStop(a, o);\n              }\n\n              return e;\n            }\n          }\n        }), A.util.object.extend(A.Gradient, {\n          fromElement: function fromElement(e, r) {\n            var n,\n                o,\n                s,\n                a,\n                h,\n                c,\n                l = e.getElementsByTagName(\"stop\"),\n                u = e.getAttribute(\"gradientUnits\") || \"objectBoundingBox\",\n                f = e.getAttribute(\"gradientTransform\"),\n                d = [];\n\n            for (\"linear\" == (n = \"linearGradient\" === e.nodeName || \"LINEARGRADIENT\" === e.nodeName ? \"linear\" : \"radial\") ? o = {\n              x1: (c = e).getAttribute(\"x1\") || 0,\n              y1: c.getAttribute(\"y1\") || 0,\n              x2: c.getAttribute(\"x2\") || \"100%\",\n              y2: c.getAttribute(\"y2\") || 0\n            } : \"radial\" === n && (o = {\n              x1: (h = e).getAttribute(\"fx\") || h.getAttribute(\"cx\") || \"50%\",\n              y1: h.getAttribute(\"fy\") || h.getAttribute(\"cy\") || \"50%\",\n              r1: 0,\n              x2: h.getAttribute(\"cx\") || \"50%\",\n              y2: h.getAttribute(\"cy\") || \"50%\",\n              r2: h.getAttribute(\"r\") || \"50%\"\n            }), a = l.length; a--;) {\n              d.push(t(l[a]));\n            }\n\n            s = i(r, o, u);\n            var g = new A.Gradient({\n              type: n,\n              coords: o,\n              colorStops: d,\n              offsetX: -r.left,\n              offsetY: -r.top\n            });\n            return (f || \"\" !== s) && (g.gradientTransform = A.parseTransformAttribute((f || \"\") + s)), g;\n          },\n          forObject: function forObject(t, e) {\n            return e || (e = {}), i(t, e.coords, \"userSpaceOnUse\"), new A.Gradient(e);\n          }\n        });\n      }(), function () {\n        \"use strict\";\n\n        var t = A.util.toFixed;\n        A.Pattern = A.util.createClass({\n          repeat: \"repeat\",\n          offsetX: 0,\n          offsetY: 0,\n          crossOrigin: \"\",\n          patternTransform: null,\n          initialize: function initialize(t, e) {\n            if (t || (t = {}), this.id = A.Object.__uid++, this.setOptions(t), !t.source || t.source && \"string\" != typeof t.source) e && e(this);else if (void 0 !== A.util.getFunctionBody(t.source)) this.source = new Function(A.util.getFunctionBody(t.source)), e && e(this);else {\n              var i = this;\n              this.source = A.util.createImage(), A.util.loadImage(t.source, function (t) {\n                i.source = t, e && e(i);\n              }, null, this.crossOrigin);\n            }\n          },\n          toObject: function toObject(e) {\n            var i,\n                r,\n                n = A.Object.NUM_FRACTION_DIGITS;\n            return \"function\" == typeof this.source ? i = String(this.source) : \"string\" == typeof this.source.src ? i = this.source.src : \"object\" == typeof this.source && this.source.toDataURL && (i = this.source.toDataURL()), r = {\n              type: \"pattern\",\n              source: i,\n              repeat: this.repeat,\n              crossOrigin: this.crossOrigin,\n              offsetX: t(this.offsetX, n),\n              offsetY: t(this.offsetY, n),\n              patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            }, A.util.populateWithProperties(this, r, e), r;\n          },\n          toSVG: function toSVG(t) {\n            var e = \"function\" == typeof this.source ? this.source() : this.source,\n                i = e.width / t.width,\n                r = e.height / t.height,\n                n = this.offsetX / t.width,\n                o = this.offsetY / t.height,\n                s = \"\";\n            return \"repeat-x\" !== this.repeat && \"no-repeat\" !== this.repeat || (r = 1, o && (r += Math.abs(o))), \"repeat-y\" !== this.repeat && \"no-repeat\" !== this.repeat || (i = 1, n && (i += Math.abs(n))), e.src ? s = e.src : e.toDataURL && (s = e.toDataURL()), '<pattern id=\"SVGID_' + this.id + '\" x=\"' + n + '\" y=\"' + o + '\" width=\"' + i + '\" height=\"' + r + '\">\\n<image x=\"0\" y=\"0\" width=\"' + e.width + '\" height=\"' + e.height + '\" xlink:href=\"' + s + '\"></image>\\n</pattern>\\n';\n          },\n          setOptions: function setOptions(t) {\n            for (var e in t) {\n              this[e] = t[e];\n            }\n          },\n          toLive: function toLive(t) {\n            var e = \"function\" == typeof this.source ? this.source() : this.source;\n            if (!e) return \"\";\n\n            if (void 0 !== e.src) {\n              if (!e.complete) return \"\";\n              if (0 === e.naturalWidth || 0 === e.naturalHeight) return \"\";\n            }\n\n            return t.createPattern(e, this.repeat);\n          }\n        });\n      }(), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.toFixed;\n        e.Shadow ? e.warn(\"fabric.Shadow is already defined.\") : (e.Shadow = e.util.createClass({\n          color: \"rgb(0,0,0)\",\n          blur: 0,\n          offsetX: 0,\n          offsetY: 0,\n          affectStroke: !1,\n          includeDefaultValues: !0,\n          initialize: function initialize(t) {\n            for (var i in \"string\" == typeof t && (t = this._parseShadow(t)), t) {\n              this[i] = t[i];\n            }\n\n            this.id = e.Object.__uid++;\n          },\n          _parseShadow: function _parseShadow(t) {\n            var i = t.trim(),\n                r = e.Shadow.reOffsetsAndBlur.exec(i) || [];\n            return {\n              color: (i.replace(e.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\").trim(),\n              offsetX: parseInt(r[1], 10) || 0,\n              offsetY: parseInt(r[2], 10) || 0,\n              blur: parseInt(r[3], 10) || 0\n            };\n          },\n          toString: function toString() {\n            return [this.offsetX, this.offsetY, this.blur, this.color].join(\"px \");\n          },\n          toSVG: function toSVG(t) {\n            var r = 40,\n                n = 40,\n                o = e.Object.NUM_FRACTION_DIGITS,\n                s = e.util.rotateVector({\n              x: this.offsetX,\n              y: this.offsetY\n            }, e.util.degreesToRadians(-t.angle)),\n                a = new e.Color(this.color);\n            return t.width && t.height && (r = 100 * i((Math.abs(s.x) + this.blur) / t.width, o) + 20, n = 100 * i((Math.abs(s.y) + this.blur) / t.height, o) + 20), t.flipX && (s.x *= -1), t.flipY && (s.y *= -1), '<filter id=\"SVGID_' + this.id + '\" y=\"-' + n + '%\" height=\"' + (100 + 2 * n) + '%\" x=\"-' + r + '%\" width=\"' + (100 + 2 * r) + '%\" >\\n\\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + i(this.blur ? this.blur / 2 : 0, o) + '\"></feGaussianBlur>\\n\\t<feOffset dx=\"' + i(s.x, o) + '\" dy=\"' + i(s.y, o) + '\" result=\"oBlur\" ></feOffset>\\n\\t<feFlood flood-color=\"' + a.toRgb() + '\" flood-opacity=\"' + a.getAlpha() + '\"/>\\n\\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n\\t<feMerge>\\n\\t\\t<feMergeNode></feMergeNode>\\n\\t\\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n\\t</feMerge>\\n</filter>\\n';\n          },\n          toObject: function toObject() {\n            if (this.includeDefaultValues) return {\n              color: this.color,\n              blur: this.blur,\n              offsetX: this.offsetX,\n              offsetY: this.offsetY,\n              affectStroke: this.affectStroke\n            };\n            var t = {},\n                i = e.Shadow.prototype;\n            return [\"color\", \"blur\", \"offsetX\", \"offsetY\", \"affectStroke\"].forEach(function (e) {\n              this[e] !== i[e] && (t[e] = this[e]);\n            }, this), t;\n          }\n        }), e.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:px)?(?:\\s?|$))?(-?\\d+(?:px)?(?:\\s?|$))?(\\d+(?:px)?)?(?:\\s?|$)(?:$|\\s)/);\n      }(e), function () {\n        \"use strict\";\n\n        if (A.StaticCanvas) A.warn(\"fabric.StaticCanvas is already defined.\");else {\n          var t = A.util.object.extend,\n              e = A.util.getElementOffset,\n              i = A.util.removeFromArray,\n              r = A.util.toFixed,\n              n = A.util.transformPoint,\n              o = A.util.invertTransform,\n              s = A.util.getNodeCanvas,\n              a = A.util.createCanvasElement,\n              h = new Error(\"Could not initialize `canvas` element\");\n          A.StaticCanvas = A.util.createClass(A.CommonMethods, {\n            initialize: function initialize(t, e) {\n              e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e);\n            },\n            backgroundColor: \"\",\n            backgroundImage: null,\n            overlayColor: \"\",\n            overlayImage: null,\n            includeDefaultValues: !0,\n            stateful: !1,\n            renderOnAddRemove: !0,\n            clipTo: null,\n            controlsAboveOverlay: !1,\n            allowTouchScrolling: !1,\n            imageSmoothingEnabled: !0,\n            viewportTransform: A.iMatrix.concat(),\n            backgroundVpt: !0,\n            overlayVpt: !0,\n            onBeforeScaleRotate: function onBeforeScaleRotate() {},\n            enableRetinaScaling: !0,\n            vptCoords: {},\n            skipOffscreen: !0,\n            clipPath: void 0,\n            _initStatic: function _initStatic(t, e) {\n              var i = this.requestRenderAllBound;\n              this._objects = [], this._createLowerCanvas(t), this._initOptions(e), this._setImageSmoothing(), this.interactive || this._initRetinaScaling(), e.overlayImage && this.setOverlayImage(e.overlayImage, i), e.backgroundImage && this.setBackgroundImage(e.backgroundImage, i), e.backgroundColor && this.setBackgroundColor(e.backgroundColor, i), e.overlayColor && this.setOverlayColor(e.overlayColor, i), this.calcOffset();\n            },\n            _isRetinaScaling: function _isRetinaScaling() {\n              return 1 !== A.devicePixelRatio && this.enableRetinaScaling;\n            },\n            getRetinaScaling: function getRetinaScaling() {\n              return this._isRetinaScaling() ? A.devicePixelRatio : 1;\n            },\n            _initRetinaScaling: function _initRetinaScaling() {\n              this._isRetinaScaling() && (this.lowerCanvasEl.setAttribute(\"width\", this.width * A.devicePixelRatio), this.lowerCanvasEl.setAttribute(\"height\", this.height * A.devicePixelRatio), this.contextContainer.scale(A.devicePixelRatio, A.devicePixelRatio));\n            },\n            calcOffset: function calcOffset() {\n              return this._offset = e(this.lowerCanvasEl), this;\n            },\n            setOverlayImage: function setOverlayImage(t, e, i) {\n              return this.__setBgOverlayImage(\"overlayImage\", t, e, i);\n            },\n            setBackgroundImage: function setBackgroundImage(t, e, i) {\n              return this.__setBgOverlayImage(\"backgroundImage\", t, e, i);\n            },\n            setOverlayColor: function setOverlayColor(t, e) {\n              return this.__setBgOverlayColor(\"overlayColor\", t, e);\n            },\n            setBackgroundColor: function setBackgroundColor(t, e) {\n              return this.__setBgOverlayColor(\"backgroundColor\", t, e);\n            },\n            _setImageSmoothing: function _setImageSmoothing() {\n              var t = this.getContext();\n              t.imageSmoothingEnabled = t.imageSmoothingEnabled || t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled || t.oImageSmoothingEnabled, t.imageSmoothingEnabled = this.imageSmoothingEnabled;\n            },\n            __setBgOverlayImage: function __setBgOverlayImage(t, e, i, r) {\n              return \"string\" == typeof e ? A.util.loadImage(e, function (e) {\n                if (e) {\n                  var n = new A.Image(e, r);\n                  (this[t] = n).canvas = this;\n                }\n\n                i && i(e);\n              }, this, r && r.crossOrigin) : (r && e.setOptions(r), (this[t] = e) && (e.canvas = this), i && i(e)), this;\n            },\n            __setBgOverlayColor: function __setBgOverlayColor(t, e, i) {\n              return this[t] = e, this._initGradient(e, t), this._initPattern(e, t, i), this;\n            },\n            _createCanvasElement: function _createCanvasElement() {\n              var t = a();\n              if (!t) throw h;\n              if (t.style || (t.style = {}), void 0 === t.getContext) throw h;\n              return t;\n            },\n            _initOptions: function _initOptions(t) {\n              var e = this.lowerCanvasEl;\n              this._setOptions(t), this.width = this.width || parseInt(e.width, 10) || 0, this.height = this.height || parseInt(e.height, 10) || 0, this.lowerCanvasEl.style && (e.width = this.width, e.height = this.height, e.style.width = this.width + \"px\", e.style.height = this.height + \"px\", this.viewportTransform = this.viewportTransform.slice());\n            },\n            _createLowerCanvas: function _createLowerCanvas(t) {\n              t && t.getContext ? this.lowerCanvasEl = t : this.lowerCanvasEl = A.util.getById(t) || this._createCanvasElement(), A.util.addClass(this.lowerCanvasEl, \"lower-canvas\"), this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n            },\n            getWidth: function getWidth() {\n              return this.width;\n            },\n            getHeight: function getHeight() {\n              return this.height;\n            },\n            setWidth: function setWidth(t, e) {\n              return this.setDimensions({\n                width: t\n              }, e);\n            },\n            setHeight: function setHeight(t, e) {\n              return this.setDimensions({\n                height: t\n              }, e);\n            },\n            setDimensions: function setDimensions(t, e) {\n              var i;\n\n              for (var r in e = e || {}, t) {\n                i = t[r], e.cssOnly || (this._setBackstoreDimension(r, t[r]), i += \"px\", this.hasLostContext = !0), e.backstoreOnly || this._setCssDimension(r, i);\n              }\n\n              return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(), this._initRetinaScaling(), this._setImageSmoothing(), this.calcOffset(), e.cssOnly || this.requestRenderAll(), this;\n            },\n            _setBackstoreDimension: function _setBackstoreDimension(t, e) {\n              return this.lowerCanvasEl[t] = e, this.upperCanvasEl && (this.upperCanvasEl[t] = e), this.cacheCanvasEl && (this.cacheCanvasEl[t] = e), this[t] = e, this;\n            },\n            _setCssDimension: function _setCssDimension(t, e) {\n              return this.lowerCanvasEl.style[t] = e, this.upperCanvasEl && (this.upperCanvasEl.style[t] = e), this.wrapperEl && (this.wrapperEl.style[t] = e), this;\n            },\n            getZoom: function getZoom() {\n              return this.viewportTransform[0];\n            },\n            setViewportTransform: function setViewportTransform(t) {\n              var e,\n                  i,\n                  r,\n                  n = this._activeObject;\n\n              for (this.viewportTransform = t, i = 0, r = this._objects.length; i < r; i++) {\n                (e = this._objects[i]).group || e.setCoords(!1, !0);\n              }\n\n              return n && \"activeSelection\" === n.type && n.setCoords(!1, !0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            zoomToPoint: function zoomToPoint(t, e) {\n              var i = t,\n                  r = this.viewportTransform.slice(0);\n              t = n(t, o(this.viewportTransform)), r[0] = e, r[3] = e;\n              var s = n(t, r);\n              return r[4] += i.x - s.x, r[5] += i.y - s.y, this.setViewportTransform(r);\n            },\n            setZoom: function setZoom(t) {\n              return this.zoomToPoint(new A.Point(0, 0), t), this;\n            },\n            absolutePan: function absolutePan(t) {\n              var e = this.viewportTransform.slice(0);\n              return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e);\n            },\n            relativePan: function relativePan(t) {\n              return this.absolutePan(new A.Point(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5]));\n            },\n            getElement: function getElement() {\n              return this.lowerCanvasEl;\n            },\n            _onObjectAdded: function _onObjectAdded(t) {\n              this.stateful && t.setupState(), t._set(\"canvas\", this), t.setCoords(), this.fire(\"object:added\", {\n                target: t\n              }), t.fire(\"added\");\n            },\n            _onObjectRemoved: function _onObjectRemoved(t) {\n              this.fire(\"object:removed\", {\n                target: t\n              }), t.fire(\"removed\"), delete t.canvas;\n            },\n            clearContext: function clearContext(t) {\n              return t.clearRect(0, 0, this.width, this.height), this;\n            },\n            getContext: function getContext() {\n              return this.contextContainer;\n            },\n            clear: function clear() {\n              return this._objects.length = 0, this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = \"\", this.overlayColor = \"\", this._hasITextHandlers && (this.off(\"mouse:up\", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire(\"canvas:cleared\"), this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            renderAll: function renderAll() {\n              var t = this.contextContainer;\n              return this.renderCanvas(t, this._objects), this;\n            },\n            renderAndReset: function renderAndReset() {\n              this.isRendering = 0, this.renderAll();\n            },\n            requestRenderAll: function requestRenderAll() {\n              return this.isRendering || (this.isRendering = A.util.requestAnimFrame(this.renderAndResetBound)), this;\n            },\n            calcViewportBoundaries: function calcViewportBoundaries() {\n              var t = {},\n                  e = this.width,\n                  i = this.height,\n                  r = o(this.viewportTransform);\n              return t.tl = n({\n                x: 0,\n                y: 0\n              }, r), t.br = n({\n                x: e,\n                y: i\n              }, r), t.tr = new A.Point(t.br.x, t.tl.y), t.bl = new A.Point(t.tl.x, t.br.y), this.vptCoords = t;\n            },\n            cancelRequestedRender: function cancelRequestedRender() {\n              this.isRendering && (A.util.cancelAnimFrame(this.isRendering), this.isRendering = 0);\n            },\n            renderCanvas: function renderCanvas(t, e) {\n              var i = this.viewportTransform,\n                  r = this.clipPath;\n              this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(t), this.fire(\"before:render\", {\n                ctx: t\n              }), this.clipTo && A.util.clipContext(this, t), this._renderBackground(t), t.save(), t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this._renderObjects(t, e), t.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.clipTo && t.restore(), r && (r.canvas = this, r.shouldCache(), r._transformDone = !0, r.renderCache({\n                forClipping: !0\n              }), this.drawClipPathOnCanvas(t)), this._renderOverlay(t), this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.fire(\"after:render\", {\n                ctx: t\n              });\n            },\n            drawClipPathOnCanvas: function drawClipPathOnCanvas(t) {\n              var e = this.viewportTransform,\n                  i = this.clipPath;\n              t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t.globalCompositeOperation = \"destination-in\", i.transform(t), t.scale(1 / i.zoomX, 1 / i.zoomY), t.drawImage(i._cacheCanvas, -i.cacheTranslationX, -i.cacheTranslationY), t.restore();\n            },\n            _renderObjects: function _renderObjects(t, e) {\n              var i, r;\n\n              for (i = 0, r = e.length; i < r; ++i) {\n                e[i] && e[i].render(t);\n              }\n            },\n            _renderBackgroundOrOverlay: function _renderBackgroundOrOverlay(t, e) {\n              var i,\n                  r = this[e + \"Color\"];\n              r && (t.fillStyle = r.toLive ? r.toLive(t, this) : r, t.fillRect(r.offsetX || 0, r.offsetY || 0, this.width, this.height)), (r = this[e + \"Image\"]) && (this[e + \"Vpt\"] && (i = this.viewportTransform, t.save(), t.transform(i[0], i[1], i[2], i[3], i[4], i[5])), r.render(t), this[e + \"Vpt\"] && t.restore());\n            },\n            _renderBackground: function _renderBackground(t) {\n              this._renderBackgroundOrOverlay(t, \"background\");\n            },\n            _renderOverlay: function _renderOverlay(t) {\n              this._renderBackgroundOrOverlay(t, \"overlay\");\n            },\n            getCenter: function getCenter() {\n              return {\n                top: this.height / 2,\n                left: this.width / 2\n              };\n            },\n            centerObjectH: function centerObjectH(t) {\n              return this._centerObject(t, new A.Point(this.getCenter().left, t.getCenterPoint().y));\n            },\n            centerObjectV: function centerObjectV(t) {\n              return this._centerObject(t, new A.Point(t.getCenterPoint().x, this.getCenter().top));\n            },\n            centerObject: function centerObject(t) {\n              var e = this.getCenter();\n              return this._centerObject(t, new A.Point(e.left, e.top));\n            },\n            viewportCenterObject: function viewportCenterObject(t) {\n              var e = this.getVpCenter();\n              return this._centerObject(t, e);\n            },\n            viewportCenterObjectH: function viewportCenterObjectH(t) {\n              var e = this.getVpCenter();\n              return this._centerObject(t, new A.Point(e.x, t.getCenterPoint().y)), this;\n            },\n            viewportCenterObjectV: function viewportCenterObjectV(t) {\n              var e = this.getVpCenter();\n              return this._centerObject(t, new A.Point(t.getCenterPoint().x, e.y));\n            },\n            getVpCenter: function getVpCenter() {\n              var t = this.getCenter(),\n                  e = o(this.viewportTransform);\n              return n({\n                x: t.left,\n                y: t.top\n              }, e);\n            },\n            _centerObject: function _centerObject(t, e) {\n              return t.setPositionByOrigin(e, \"center\", \"center\"), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            toDatalessJSON: function toDatalessJSON(t) {\n              return this.toDatalessObject(t);\n            },\n            toObject: function toObject(t) {\n              return this._toObjectMethod(\"toObject\", t);\n            },\n            toDatalessObject: function toDatalessObject(t) {\n              return this._toObjectMethod(\"toDatalessObject\", t);\n            },\n            _toObjectMethod: function _toObjectMethod(e, i) {\n              var r = this.clipPath,\n                  n = {\n                version: A.version,\n                objects: this._toObjects(e, i)\n              };\n              return r && (r = r.toObject(i)), t(n, this.__serializeBgOverlay(e, i)), A.util.populateWithProperties(this, n, i), n;\n            },\n            _toObjects: function _toObjects(t, e) {\n              return this._objects.filter(function (t) {\n                return !t.excludeFromExport;\n              }).map(function (i) {\n                return this._toObject(i, t, e);\n              }, this);\n            },\n            _toObject: function _toObject(t, e, i) {\n              var r;\n              this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1);\n              var n = t[e](i);\n              return this.includeDefaultValues || (t.includeDefaultValues = r), n;\n            },\n            __serializeBgOverlay: function __serializeBgOverlay(t, e) {\n              var i = {},\n                  r = this.backgroundImage,\n                  n = this.overlayImage;\n              return this.backgroundColor && (i.background = this.backgroundColor.toObject ? this.backgroundColor.toObject(e) : this.backgroundColor), this.overlayColor && (i.overlay = this.overlayColor.toObject ? this.overlayColor.toObject(e) : this.overlayColor), r && !r.excludeFromExport && (i.backgroundImage = this._toObject(r, t, e)), n && !n.excludeFromExport && (i.overlayImage = this._toObject(n, t, e)), i;\n            },\n            svgViewportTransformation: !0,\n            toSVG: function toSVG(t, e) {\n              t || (t = {}), t.reviver = e;\n              var i = [];\n              return this._setSVGPreamble(i, t), this._setSVGHeader(i, t), this._setSVGBgOverlayColor(i, \"backgroundColor\"), this._setSVGBgOverlayImage(i, \"backgroundImage\", e), this.clipPath && i.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n'), this._setSVGObjects(i, e), this.clipPath && i.push(\"</g>\\n\"), this._setSVGBgOverlayColor(i, \"overlayColor\"), this._setSVGBgOverlayImage(i, \"overlayImage\", e), i.push(\"</svg>\"), i.join(\"\");\n            },\n            _setSVGPreamble: function _setSVGPreamble(t, e) {\n              e.suppressPreamble || t.push('<?xml version=\"1.0\" encoding=\"', e.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n            },\n            _setSVGHeader: function _setSVGHeader(t, e) {\n              var i,\n                  n = e.width || this.width,\n                  o = e.height || this.height,\n                  s = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ',\n                  a = A.Object.NUM_FRACTION_DIGITS;\n              e.viewBox ? s = 'viewBox=\"' + e.viewBox.x + \" \" + e.viewBox.y + \" \" + e.viewBox.width + \" \" + e.viewBox.height + '\" ' : this.svgViewportTransformation && (i = this.viewportTransform, s = 'viewBox=\"' + r(-i[4] / i[0], a) + \" \" + r(-i[5] / i[3], a) + \" \" + r(this.width / i[0], a) + \" \" + r(this.height / i[3], a) + '\" '), t.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', n, '\" ', 'height=\"', o, '\" ', s, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", A.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), \"</defs>\\n\");\n            },\n            createSVGClipPathMarkup: function createSVGClipPathMarkup(t) {\n              var e = this.clipPath;\n              return e ? (e.clipPathId = \"CLIPPATH_\" + A.Object.__uid++, '<clipPath id=\"' + e.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(t.reviver) + \"</clipPath>\\n\") : \"\";\n            },\n            createSVGRefElementsMarkup: function createSVGRefElementsMarkup() {\n              var t = this;\n              return [\"backgroundColor\", \"overlayColor\"].map(function (e) {\n                var i = t[e];\n                if (i && i.toLive) return i.toSVG(t, !1);\n              }).join(\"\");\n            },\n            createSVGFontFacesMarkup: function createSVGFontFacesMarkup() {\n              var t,\n                  e,\n                  i,\n                  r,\n                  n,\n                  o,\n                  s,\n                  a,\n                  h = \"\",\n                  c = {},\n                  l = A.fontPaths,\n                  u = this._objects;\n\n              for (s = 0, a = u.length; s < a; s++) {\n                if (e = (t = u[s]).fontFamily, -1 !== t.type.indexOf(\"text\") && !c[e] && l[e] && (c[e] = !0, t.styles)) for (n in i = t.styles) {\n                  for (o in r = i[n]) {\n                    !c[e = r[o].fontFamily] && l[e] && (c[e] = !0);\n                  }\n                }\n              }\n\n              for (var f in c) {\n                h += [\"\\t\\t@font-face {\\n\", \"\\t\\t\\tfont-family: '\", f, \"';\\n\", \"\\t\\t\\tsrc: url('\", l[f], \"');\\n\", \"\\t\\t}\\n\"].join(\"\");\n              }\n\n              return h && (h = ['\\t<style type=\"text/css\">', \"<![CDATA[\\n\", h, \"]]>\", \"</style>\\n\"].join(\"\")), h;\n            },\n            _setSVGObjects: function _setSVGObjects(t, e) {\n              var i,\n                  r,\n                  n,\n                  o = this._objects;\n\n              for (r = 0, n = o.length; r < n; r++) {\n                (i = o[r]).excludeFromExport || this._setSVGObject(t, i, e);\n              }\n            },\n            _setSVGObject: function _setSVGObject(t, e, i) {\n              t.push(e.toSVG(i));\n            },\n            _setSVGBgOverlayImage: function _setSVGBgOverlayImage(t, e, i) {\n              this[e] && !this[e].excludeFromExport && this[e].toSVG && t.push(this[e].toSVG(i));\n            },\n            _setSVGBgOverlayColor: function _setSVGBgOverlayColor(t, e) {\n              var i = this[e],\n                  r = this.viewportTransform,\n                  n = this.width / r[0],\n                  o = this.height / r[3];\n              if (i) if (i.toLive) {\n                var s = i.repeat;\n                t.push('<rect transform=\"translate(', n / 2, \",\", o / 2, ')\"', ' x=\"', i.offsetX - n / 2, '\" y=\"', i.offsetY - o / 2, '\" ', 'width=\"', \"repeat-y\" === s || \"no-repeat\" === s ? i.source.width : n, '\" height=\"', \"repeat-x\" === s || \"no-repeat\" === s ? i.source.height : o, '\" fill=\"url(#SVGID_' + i.id + ')\"', \"></rect>\\n\");\n              } else t.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', this[e], '\"', \"></rect>\\n\");\n            },\n            sendToBack: function sendToBack(t) {\n              if (!t) return this;\n              var e,\n                  r,\n                  n,\n                  o = this._activeObject;\n              if (t === o && \"activeSelection\" === t.type) for (e = (n = o._objects).length; e--;) {\n                r = n[e], i(this._objects, r), this._objects.unshift(r);\n              } else i(this._objects, t), this._objects.unshift(t);\n              return this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            bringToFront: function bringToFront(t) {\n              if (!t) return this;\n              var e,\n                  r,\n                  n,\n                  o = this._activeObject;\n              if (t === o && \"activeSelection\" === t.type) for (n = o._objects, e = 0; e < n.length; e++) {\n                r = n[e], i(this._objects, r), this._objects.push(r);\n              } else i(this._objects, t), this._objects.push(t);\n              return this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            sendBackwards: function sendBackwards(t, e) {\n              if (!t) return this;\n              var r,\n                  n,\n                  o,\n                  s,\n                  a,\n                  h = this._activeObject,\n                  c = 0;\n              if (t === h && \"activeSelection\" === t.type) for (a = h._objects, r = 0; r < a.length; r++) {\n                n = a[r], 0 + c < (o = this._objects.indexOf(n)) && (s = o - 1, i(this._objects, n), this._objects.splice(s, 0, n)), c++;\n              } else 0 !== (o = this._objects.indexOf(t)) && (s = this._findNewLowerIndex(t, o, e), i(this._objects, t), this._objects.splice(s, 0, t));\n              return this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            _findNewLowerIndex: function _findNewLowerIndex(t, e, i) {\n              var r, n;\n\n              if (i) {\n                for (n = (r = e) - 1; 0 <= n; --n) {\n                  if (t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t)) {\n                    r = n;\n                    break;\n                  }\n                }\n              } else r = e - 1;\n\n              return r;\n            },\n            bringForward: function bringForward(t, e) {\n              if (!t) return this;\n              var r,\n                  n,\n                  o,\n                  s,\n                  a,\n                  h = this._activeObject,\n                  c = 0;\n              if (t === h && \"activeSelection\" === t.type) for (r = (a = h._objects).length; r--;) {\n                n = a[r], (o = this._objects.indexOf(n)) < this._objects.length - 1 - c && (s = o + 1, i(this._objects, n), this._objects.splice(s, 0, n)), c++;\n              } else (o = this._objects.indexOf(t)) !== this._objects.length - 1 && (s = this._findNewUpperIndex(t, o, e), i(this._objects, t), this._objects.splice(s, 0, t));\n              return this.renderOnAddRemove && this.requestRenderAll(), this;\n            },\n            _findNewUpperIndex: function _findNewUpperIndex(t, e, i) {\n              var r, n, o;\n\n              if (i) {\n                for (n = (r = e) + 1, o = this._objects.length; n < o; ++n) {\n                  if (t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t)) {\n                    r = n;\n                    break;\n                  }\n                }\n              } else r = e + 1;\n\n              return r;\n            },\n            moveTo: function moveTo(t, e) {\n              return i(this._objects, t), this._objects.splice(e, 0, t), this.renderOnAddRemove && this.requestRenderAll();\n            },\n            dispose: function dispose() {\n              return this.isRendering && (A.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function (t) {\n                t.dispose && t.dispose();\n              }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, A.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this;\n            },\n            toString: function toString() {\n              return \"#<fabric.Canvas (\" + this.complexity() + \"): { objects: \" + this._objects.length + \" }>\";\n            }\n          }), t(A.StaticCanvas.prototype, A.Observable), t(A.StaticCanvas.prototype, A.Collection), t(A.StaticCanvas.prototype, A.DataURLExporter), t(A.StaticCanvas, {\n            EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n            supports: function supports(t) {\n              var e = a();\n              if (!e || !e.getContext) return null;\n              var i = e.getContext(\"2d\");\n              if (!i) return null;\n\n              switch (t) {\n                case \"getImageData\":\n                  return void 0 !== i.getImageData;\n\n                case \"setLineDash\":\n                  return void 0 !== i.setLineDash;\n\n                case \"toDataURL\":\n                  return void 0 !== e.toDataURL;\n\n                case \"toDataURLWithQuality\":\n                  try {\n                    return e.toDataURL(\"image/jpeg\", 0), !0;\n                  } catch (t) {}\n\n                  return !1;\n\n                default:\n                  return null;\n              }\n            }\n          }), A.StaticCanvas.prototype.toJSON = A.StaticCanvas.prototype.toObject, A.isLikelyNode && (A.StaticCanvas.prototype.createPNGStream = function () {\n            var t = s(this.lowerCanvasEl);\n            return t && t.createPNGStream();\n          }, A.StaticCanvas.prototype.createJPEGStream = function (t) {\n            var e = s(this.lowerCanvasEl);\n            return e && e.createJPEGStream(t);\n          });\n        }\n      }(), A.BaseBrush = A.util.createClass({\n        color: \"rgb(0, 0, 0)\",\n        width: 1,\n        shadow: null,\n        strokeLineCap: \"round\",\n        strokeLineJoin: \"round\",\n        strokeMiterLimit: 10,\n        strokeDashArray: null,\n        setShadow: function setShadow(t) {\n          return this.shadow = new A.Shadow(t), this;\n        },\n        _setBrushStyles: function _setBrushStyles() {\n          var t = this.canvas.contextTop;\n          t.strokeStyle = this.color, t.lineWidth = this.width, t.lineCap = this.strokeLineCap, t.miterLimit = this.strokeMiterLimit, t.lineJoin = this.strokeLineJoin, A.StaticCanvas.supports(\"setLineDash\") && t.setLineDash(this.strokeDashArray || []);\n        },\n        _saveAndTransform: function _saveAndTransform(t) {\n          var e = this.canvas.viewportTransform;\n          t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n        },\n        _setShadow: function _setShadow() {\n          if (this.shadow) {\n            var t = this.canvas.contextTop,\n                e = this.canvas.getZoom();\n            t.shadowColor = this.shadow.color, t.shadowBlur = this.shadow.blur * e, t.shadowOffsetX = this.shadow.offsetX * e, t.shadowOffsetY = this.shadow.offsetY * e;\n          }\n        },\n        _resetShadow: function _resetShadow() {\n          var t = this.canvas.contextTop;\n          t.shadowColor = \"\", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0;\n        }\n      }), A.PencilBrush = A.util.createClass(A.BaseBrush, {\n        initialize: function initialize(t) {\n          this.canvas = t, this._points = [];\n        },\n        _drawSegment: function _drawSegment(t, e, i) {\n          var r = e.midPointFrom(i);\n          return t.quadraticCurveTo(e.x, e.y, r.x, r.y), r;\n        },\n        onMouseDown: function onMouseDown(t) {\n          this._prepareForDrawing(t), this._captureDrawingPath(t), this._render();\n        },\n        onMouseMove: function onMouseMove(t) {\n          if (this._captureDrawingPath(t) && 1 < this._points.length) if (this.needsFullRender) this.canvas.clearContext(this.canvas.contextTop), this._render();else {\n            var e = this._points,\n                i = e.length,\n                r = this.canvas.contextTop;\n            this._saveAndTransform(r), this.oldEnd && (r.beginPath(), r.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(r, e[i - 2], e[i - 1], !0), r.stroke(), r.restore();\n          }\n        },\n        onMouseUp: function onMouseUp() {\n          this.oldEnd = void 0, this._finalizeAndAddPath();\n        },\n        _prepareForDrawing: function _prepareForDrawing(t) {\n          var e = new A.Point(t.x, t.y);\n          this._reset(), this._addPoint(e), this.canvas.contextTop.moveTo(e.x, e.y);\n        },\n        _addPoint: function _addPoint(t) {\n          return !(1 < this._points.length && t.eq(this._points[this._points.length - 1]) || (this._points.push(t), 0));\n        },\n        _reset: function _reset() {\n          this._points.length = 0, this._setBrushStyles();\n          var t = new A.Color(this.color);\n          this.needsFullRender = t.getAlpha() < 1, this._setShadow();\n        },\n        _captureDrawingPath: function _captureDrawingPath(t) {\n          var e = new A.Point(t.x, t.y);\n          return this._addPoint(e);\n        },\n        _render: function _render() {\n          var t,\n              e,\n              i = this.canvas.contextTop,\n              r = this._points[0],\n              n = this._points[1];\n\n          if (this._saveAndTransform(i), i.beginPath(), 2 === this._points.length && r.x === n.x && r.y === n.y) {\n            var o = this.width / 1e3;\n            r = new A.Point(r.x, r.y), n = new A.Point(n.x, n.y), r.x -= o, n.x += o;\n          }\n\n          for (i.moveTo(r.x, r.y), t = 1, e = this._points.length; t < e; t++) {\n            this._drawSegment(i, r, n), r = this._points[t], n = this._points[t + 1];\n          }\n\n          i.lineTo(r.x, r.y), i.stroke(), i.restore();\n        },\n        convertPointsToSVGPath: function convertPointsToSVGPath(t) {\n          var e,\n              i = [],\n              r = this.width / 1e3,\n              n = new A.Point(t[0].x, t[0].y),\n              o = new A.Point(t[1].x, t[1].y),\n              s = t.length,\n              a = 1,\n              h = 1,\n              c = 2 < s;\n\n          for (c && (a = t[2].x < o.x ? -1 : t[2].x === o.x ? 0 : 1, h = t[2].y < o.y ? -1 : t[2].y === o.y ? 0 : 1), i.push(\"M \", n.x - a * r, \" \", n.y - h * r, \" \"), e = 1; e < s; e++) {\n            if (!n.eq(o)) {\n              var l = n.midPointFrom(o);\n              i.push(\"Q \", n.x, \" \", n.y, \" \", l.x, \" \", l.y, \" \");\n            }\n\n            n = t[e], e + 1 < t.length && (o = t[e + 1]);\n          }\n\n          return c && (a = n.x > t[e - 2].x ? 1 : n.x === t[e - 2].x ? 0 : -1, h = n.y > t[e - 2].y ? 1 : n.y === t[e - 2].y ? 0 : -1), i.push(\"L \", n.x + a * r, \" \", n.y + h * r), i;\n        },\n        createPath: function createPath(t) {\n          var e = new A.Path(t, {\n            fill: null,\n            stroke: this.color,\n            strokeWidth: this.width,\n            strokeLineCap: this.strokeLineCap,\n            strokeMiterLimit: this.strokeMiterLimit,\n            strokeLineJoin: this.strokeLineJoin,\n            strokeDashArray: this.strokeDashArray\n          }),\n              i = new A.Point(e.left + e.width / 2, e.top + e.height / 2);\n          return i = e.translateToGivenOrigin(i, \"center\", \"center\", e.originX, e.originY), e.top = i.y, e.left = i.x, this.shadow && (this.shadow.affectStroke = !0, e.setShadow(this.shadow)), e;\n        },\n        _finalizeAndAddPath: function _finalizeAndAddPath() {\n          this.canvas.contextTop.closePath();\n          var t = this.convertPointsToSVGPath(this._points).join(\"\");\n\n          if (\"M 0 0 Q 0 0 0 0 L 0 0\" !== t) {\n            var e = this.createPath(t);\n            this.canvas.clearContext(this.canvas.contextTop), this.canvas.add(e), this.canvas.renderAll(), e.setCoords(), this._resetShadow(), this.canvas.fire(\"path:created\", {\n              path: e\n            });\n          } else this.canvas.requestRenderAll();\n        }\n      }), A.CircleBrush = A.util.createClass(A.BaseBrush, {\n        width: 10,\n        initialize: function initialize(t) {\n          this.canvas = t, this.points = [];\n        },\n        drawDot: function drawDot(t) {\n          var e = this.addPoint(t),\n              i = this.canvas.contextTop;\n          this._saveAndTransform(i), i.fillStyle = e.fill, i.beginPath(), i.arc(e.x, e.y, e.radius, 0, 2 * Math.PI, !1), i.closePath(), i.fill(), i.restore();\n        },\n        onMouseDown: function onMouseDown(t) {\n          this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t);\n        },\n        _render: function _render() {\n          var t,\n              e,\n              i,\n              r = this.canvas.contextTop,\n              n = this.points;\n\n          for (this._saveAndTransform(r), t = 0, e = n.length; t < e; t++) {\n            i = n[t], r.fillStyle = i.fill, r.beginPath(), r.arc(i.x, i.y, i.radius, 0, 2 * Math.PI, !1), r.closePath(), r.fill();\n          }\n\n          r.restore();\n        },\n        onMouseMove: function onMouseMove(t) {\n          this.drawDot(t);\n        },\n        onMouseUp: function onMouseUp() {\n          var t,\n              e,\n              i = this.canvas.renderOnAddRemove;\n          this.canvas.renderOnAddRemove = !1;\n          var r = [];\n\n          for (t = 0, e = this.points.length; t < e; t++) {\n            var n = this.points[t],\n                o = new A.Circle({\n              radius: n.radius,\n              left: n.x,\n              top: n.y,\n              originX: \"center\",\n              originY: \"center\",\n              fill: n.fill\n            });\n            this.shadow && o.setShadow(this.shadow), r.push(o);\n          }\n\n          var s = new A.Group(r);\n          s.canvas = this.canvas, this.canvas.add(s), this.canvas.fire(\"path:created\", {\n            path: s\n          }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = i, this.canvas.requestRenderAll();\n        },\n        addPoint: function addPoint(t) {\n          var e = new A.Point(t.x, t.y),\n              i = A.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2,\n              r = new A.Color(this.color).setAlpha(A.util.getRandomInt(0, 100) / 100).toRgba();\n          return e.radius = i, e.fill = r, this.points.push(e), e;\n        }\n      }), A.SprayBrush = A.util.createClass(A.BaseBrush, {\n        width: 10,\n        density: 20,\n        dotWidth: 1,\n        dotWidthVariance: 1,\n        randomOpacity: !1,\n        optimizeOverlapping: !0,\n        initialize: function initialize(t) {\n          this.canvas = t, this.sprayChunks = [];\n        },\n        onMouseDown: function onMouseDown(t) {\n          this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t), this.render(this.sprayChunkPoints);\n        },\n        onMouseMove: function onMouseMove(t) {\n          this.addSprayChunk(t), this.render(this.sprayChunkPoints);\n        },\n        onMouseUp: function onMouseUp() {\n          var t = this.canvas.renderOnAddRemove;\n          this.canvas.renderOnAddRemove = !1;\n\n          for (var e = [], i = 0, r = this.sprayChunks.length; i < r; i++) {\n            for (var n = this.sprayChunks[i], o = 0, s = n.length; o < s; o++) {\n              var a = new A.Rect({\n                width: n[o].width,\n                height: n[o].width,\n                left: n[o].x + 1,\n                top: n[o].y + 1,\n                originX: \"center\",\n                originY: \"center\",\n                fill: this.color\n              });\n              e.push(a);\n            }\n          }\n\n          this.optimizeOverlapping && (e = this._getOptimizedRects(e));\n          var h = new A.Group(e);\n          this.shadow && h.setShadow(this.shadow), this.canvas.add(h), this.canvas.fire(\"path:created\", {\n            path: h\n          }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.requestRenderAll();\n        },\n        _getOptimizedRects: function _getOptimizedRects(t) {\n          var e,\n              i,\n              r,\n              n = {};\n\n          for (i = 0, r = t.length; i < r; i++) {\n            n[e = t[i].left + \"\" + t[i].top] || (n[e] = t[i]);\n          }\n\n          var o = [];\n\n          for (e in n) {\n            o.push(n[e]);\n          }\n\n          return o;\n        },\n        render: function render(t) {\n          var e,\n              i,\n              r = this.canvas.contextTop;\n\n          for (r.fillStyle = this.color, this._saveAndTransform(r), e = 0, i = t.length; e < i; e++) {\n            var n = t[e];\n            void 0 !== n.opacity && (r.globalAlpha = n.opacity), r.fillRect(n.x, n.y, n.width, n.width);\n          }\n\n          r.restore();\n        },\n        _render: function _render() {\n          var t,\n              e,\n              i = this.canvas.contextTop;\n\n          for (i.fillStyle = this.color, this._saveAndTransform(i), t = 0, e = this.sprayChunks.length; t < e; t++) {\n            this.render(this.sprayChunks[t]);\n          }\n\n          i.restore();\n        },\n        addSprayChunk: function addSprayChunk(t) {\n          this.sprayChunkPoints = [];\n          var e,\n              i,\n              r,\n              n,\n              o = this.width / 2;\n\n          for (n = 0; n < this.density; n++) {\n            e = A.util.getRandomInt(t.x - o, t.x + o), i = A.util.getRandomInt(t.y - o, t.y + o), r = this.dotWidthVariance ? A.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth;\n            var s = new A.Point(e, i);\n            s.width = r, this.randomOpacity && (s.opacity = A.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(s);\n          }\n\n          this.sprayChunks.push(this.sprayChunkPoints);\n        }\n      }), A.PatternBrush = A.util.createClass(A.PencilBrush, {\n        getPatternSrc: function getPatternSrc() {\n          var t = A.util.createCanvasElement(),\n              e = t.getContext(\"2d\");\n          return t.width = t.height = 25, e.fillStyle = this.color, e.beginPath(), e.arc(10, 10, 10, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), t;\n        },\n        getPatternSrcFunction: function getPatternSrcFunction() {\n          return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n        },\n        getPattern: function getPattern() {\n          return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n        },\n        _setBrushStyles: function _setBrushStyles() {\n          this.callSuper(\"_setBrushStyles\"), this.canvas.contextTop.strokeStyle = this.getPattern();\n        },\n        createPath: function createPath(t) {\n          var e = this.callSuper(\"createPath\", t),\n              i = e._getLeftTopCoords().scalarAdd(e.strokeWidth / 2);\n\n          return e.stroke = new A.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -i.x,\n            offsetY: -i.y\n          }), e;\n        }\n      }), function () {\n        var t = A.util.getPointer,\n            e = A.util.degreesToRadians,\n            i = A.util.radiansToDegrees,\n            r = Math.atan2,\n            n = Math.abs,\n            o = A.StaticCanvas.supports(\"setLineDash\");\n\n        for (var s in A.Canvas = A.util.createClass(A.StaticCanvas, {\n          initialize: function initialize(t, e) {\n            e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e), this._initInteractive(), this._createCacheCanvas();\n          },\n          uniScaleTransform: !1,\n          uniScaleKey: \"shiftKey\",\n          centeredScaling: !1,\n          centeredRotation: !1,\n          centeredKey: \"altKey\",\n          altActionKey: \"shiftKey\",\n          interactive: !0,\n          selection: !0,\n          selectionKey: \"shiftKey\",\n          altSelectionKey: null,\n          selectionColor: \"rgba(100, 100, 255, 0.3)\",\n          selectionDashArray: [],\n          selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n          selectionLineWidth: 1,\n          selectionFullyContained: !1,\n          hoverCursor: \"move\",\n          moveCursor: \"move\",\n          defaultCursor: \"default\",\n          freeDrawingCursor: \"crosshair\",\n          rotationCursor: \"crosshair\",\n          notAllowedCursor: \"not-allowed\",\n          containerClass: \"canvas-container\",\n          perPixelTargetFind: !1,\n          targetFindTolerance: 0,\n          skipTargetFind: !1,\n          isDrawingMode: !1,\n          preserveObjectStacking: !1,\n          snapAngle: 0,\n          snapThreshold: null,\n          stopContextMenu: !1,\n          fireRightClick: !1,\n          fireMiddleClick: !1,\n          _initInteractive: function _initInteractive() {\n            this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = A.PencilBrush && new A.PencilBrush(this), this.calcOffset();\n          },\n          _chooseObjectsToRender: function _chooseObjectsToRender() {\n            var t,\n                e,\n                i,\n                r = this.getActiveObjects();\n\n            if (0 < r.length && !this.preserveObjectStacking) {\n              e = [], i = [];\n\n              for (var n = 0, o = this._objects.length; n < o; n++) {\n                t = this._objects[n], -1 === r.indexOf(t) ? e.push(t) : i.push(t);\n              }\n\n              1 < r.length && (this._activeObject._objects = i), e.push.apply(e, i);\n            } else e = this._objects;\n\n            return e;\n          },\n          renderAll: function renderAll() {\n            !this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && this.renderTopLayer(this.contextTop);\n            var t = this.contextContainer;\n            return this.renderCanvas(t, this._chooseObjectsToRender()), this;\n          },\n          renderTopLayer: function renderTopLayer(t) {\n            this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0);\n          },\n          renderTop: function renderTop() {\n            var t = this.contextTop;\n            return this.clearContext(t), this.renderTopLayer(t), this.fire(\"after:render\"), this;\n          },\n          _resetCurrentTransform: function _resetCurrentTransform() {\n            var t = this._currentTransform;\n            t.target.set({\n              scaleX: t.original.scaleX,\n              scaleY: t.original.scaleY,\n              skewX: t.original.skewX,\n              skewY: t.original.skewY,\n              left: t.original.left,\n              top: t.original.top\n            }), this._shouldCenterTransform(t.target) ? (\"center\" !== t.originX && (\"right\" === t.originX ? t.mouseXSign = -1 : t.mouseXSign = 1), \"center\" !== t.originY && (\"bottom\" === t.originY ? t.mouseYSign = -1 : t.mouseYSign = 1), t.originX = \"center\", t.originY = \"center\") : (t.originX = t.original.originX, t.originY = t.original.originY);\n          },\n          containsPoint: function containsPoint(t, e, i) {\n            var r,\n                n = i || this.getPointer(t, !0);\n            return r = e.group && e.group === this._activeObject && \"activeSelection\" === e.group.type ? this._normalizePointer(e.group, n) : {\n              x: n.x,\n              y: n.y\n            }, e.containsPoint(r) || e._findTargetCorner(n);\n          },\n          _normalizePointer: function _normalizePointer(t, e) {\n            var i = t.calcTransformMatrix(),\n                r = A.util.invertTransform(i),\n                n = this.restorePointerVpt(e);\n            return A.util.transformPoint(n, r);\n          },\n          isTargetTransparent: function isTargetTransparent(t, e, i) {\n            if (t.shouldCache() && t._cacheCanvas) {\n              var r = this._normalizePointer(t, {\n                x: e,\n                y: i\n              }),\n                  n = t.cacheTranslationX + r.x * t.zoomX,\n                  o = t.cacheTranslationY + r.y * t.zoomY;\n\n              return A.util.isTransparent(t._cacheContext, n, o, this.targetFindTolerance);\n            }\n\n            var s = this.contextCache,\n                a = t.selectionBackgroundColor,\n                h = this.viewportTransform;\n            return t.selectionBackgroundColor = \"\", this.clearContext(s), s.save(), s.transform(h[0], h[1], h[2], h[3], h[4], h[5]), t.render(s), s.restore(), t === this._activeObject && t._renderControls(s, {\n              hasBorders: !1,\n              transparentCorners: !1\n            }, {\n              hasBorders: !1\n            }), t.selectionBackgroundColor = a, A.util.isTransparent(s, e, i, this.targetFindTolerance);\n          },\n          _isSelectionKeyPressed: function _isSelectionKeyPressed(t) {\n            return \"[object Array]\" === Object.prototype.toString.call(this.selectionKey) ? !!this.selectionKey.find(function (e) {\n              return !0 === t[e];\n            }) : t[this.selectionKey];\n          },\n          _shouldClearSelection: function _shouldClearSelection(t, e) {\n            var i = this.getActiveObjects(),\n                r = this._activeObject;\n            return !e || e && r && 1 < i.length && -1 === i.indexOf(e) && r !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && r && r !== e;\n          },\n          _shouldCenterTransform: function _shouldCenterTransform(t) {\n            if (t) {\n              var e,\n                  i = this._currentTransform;\n              return \"scale\" === i.action || \"scaleX\" === i.action || \"scaleY\" === i.action ? e = this.centeredScaling || t.centeredScaling : \"rotate\" === i.action && (e = this.centeredRotation || t.centeredRotation), e ? !i.altKey : i.altKey;\n            }\n          },\n          _getOriginFromCorner: function _getOriginFromCorner(t, e) {\n            var i = {\n              x: t.originX,\n              y: t.originY\n            };\n            return \"ml\" === e || \"tl\" === e || \"bl\" === e ? i.x = \"right\" : \"mr\" !== e && \"tr\" !== e && \"br\" !== e || (i.x = \"left\"), \"tl\" === e || \"mt\" === e || \"tr\" === e ? i.y = \"bottom\" : \"bl\" !== e && \"mb\" !== e && \"br\" !== e || (i.y = \"top\"), i;\n          },\n          _getActionFromCorner: function _getActionFromCorner(t, e, i) {\n            if (!e) return \"drag\";\n\n            switch (e) {\n              case \"mtr\":\n                return \"rotate\";\n\n              case \"ml\":\n              case \"mr\":\n                return i[this.altActionKey] ? \"skewY\" : \"scaleX\";\n\n              case \"mt\":\n              case \"mb\":\n                return i[this.altActionKey] ? \"skewX\" : \"scaleY\";\n\n              default:\n                return \"scale\";\n            }\n          },\n          _setupCurrentTransform: function _setupCurrentTransform(t, i) {\n            if (i) {\n              var r = this.getPointer(t),\n                  n = i._findTargetCorner(this.getPointer(t, !0)),\n                  o = this._getActionFromCorner(i, n, t),\n                  s = this._getOriginFromCorner(i, n);\n\n              this._currentTransform = {\n                target: i,\n                action: o,\n                corner: n,\n                scaleX: i.scaleX,\n                scaleY: i.scaleY,\n                skewX: i.skewX,\n                skewY: i.skewY,\n                offsetX: r.x - i.left,\n                offsetY: r.y - i.top,\n                originX: s.x,\n                originY: s.y,\n                ex: r.x,\n                ey: r.y,\n                lastX: r.x,\n                lastY: r.y,\n                theta: e(i.angle),\n                width: i.width * i.scaleX,\n                mouseXSign: 1,\n                mouseYSign: 1,\n                shiftKey: t.shiftKey,\n                altKey: t[this.centeredKey],\n                original: A.util.saveObjectTransform(i)\n              }, this._currentTransform.original.originX = s.x, this._currentTransform.original.originY = s.y, this._resetCurrentTransform(), this._beforeTransform(t);\n            }\n          },\n          _translateObject: function _translateObject(t, e) {\n            var i = this._currentTransform,\n                r = i.target,\n                n = t - i.offsetX,\n                o = e - i.offsetY,\n                s = !r.get(\"lockMovementX\") && r.left !== n,\n                a = !r.get(\"lockMovementY\") && r.top !== o;\n            return s && r.set(\"left\", n), a && r.set(\"top\", o), s || a;\n          },\n          _changeSkewTransformOrigin: function _changeSkewTransformOrigin(t, e, i) {\n            var r = \"originX\",\n                n = {\n              0: \"center\"\n            },\n                o = e.target.skewX,\n                s = \"left\",\n                a = \"right\",\n                h = \"mt\" === e.corner || \"ml\" === e.corner ? 1 : -1,\n                c = 1;\n            t = 0 < t ? 1 : -1, \"y\" === i && (o = e.target.skewY, s = \"top\", a = \"bottom\", r = \"originY\"), n[-1] = s, n[1] = a, e.target.flipX && (c *= -1), e.target.flipY && (c *= -1), e[r] = 0 === o ? (e.skewSign = -h * t * c, n[-t]) : (o = 0 < o ? 1 : -1, n[(e.skewSign = o) * h * c]);\n          },\n          _skewObject: function _skewObject(t, e, i) {\n            var r,\n                n = this._currentTransform,\n                o = n.target,\n                s = o.get(\"lockSkewingX\"),\n                a = o.get(\"lockSkewingY\");\n            if (s && \"x\" === i || a && \"y\" === i) return !1;\n\n            var h,\n                c,\n                l = o.getCenterPoint(),\n                u = o.toLocalPoint(new A.Point(t, e), \"center\", \"center\")[i],\n                f = o.toLocalPoint(new A.Point(n.lastX, n.lastY), \"center\", \"center\")[i],\n                d = o._getTransformedDimensions();\n\n            return this._changeSkewTransformOrigin(u - f, n, i), h = o.toLocalPoint(new A.Point(t, e), n.originX, n.originY)[i], c = o.translateToOriginPoint(l, n.originX, n.originY), r = this._setObjectSkew(h, n, i, d), n.lastX = t, n.lastY = e, o.setPositionByOrigin(c, n.originX, n.originY), r;\n          },\n          _setObjectSkew: function _setObjectSkew(t, e, i, r) {\n            var n,\n                o,\n                s,\n                a,\n                h,\n                c,\n                l,\n                u,\n                f,\n                d,\n                g = e.target,\n                p = e.skewSign;\n            return d = \"x\" === i ? (h = \"y\", c = \"Y\", l = \"X\", f = 0, g.skewY) : (h = \"x\", c = \"X\", l = \"Y\", f = g.skewX, 0), a = g._getTransformedDimensions(f, d), n = (u = 2 * Math.abs(t) - a[i]) <= 2 ? 0 : (n = p * Math.atan(u / g[\"scale\" + l] / (a[h] / g[\"scale\" + c])), A.util.radiansToDegrees(n)), o = g[\"skew\" + l] !== n, g.set(\"skew\" + l, n), 0 !== g[\"skew\" + c] && (s = g._getTransformedDimensions(), n = r[h] / s[h] * g[\"scale\" + c], g.set(\"scale\" + c, n)), o;\n          },\n          _scaleObject: function _scaleObject(t, e, i) {\n            var r = this._currentTransform,\n                n = r.target,\n                o = n.lockScalingX,\n                s = n.lockScalingY,\n                a = n.lockScalingFlip;\n            if (o && s) return !1;\n\n            var h,\n                c = n.translateToOriginPoint(n.getCenterPoint(), r.originX, r.originY),\n                l = n.toLocalPoint(new A.Point(t, e), r.originX, r.originY),\n                u = n._getTransformedDimensions();\n\n            return this._setLocalMouse(l, r), h = this._setObjectScale(l, r, o, s, i, a, u), n.setPositionByOrigin(c, r.originX, r.originY), h;\n          },\n          _setObjectScale: function _setObjectScale(t, e, i, r, n, o, s) {\n            var a,\n                h,\n                c,\n                l,\n                u = e.target,\n                f = !1,\n                d = !1,\n                g = !1;\n            return c = t.x * u.scaleX / s.x, l = t.y * u.scaleY / s.y, a = u.scaleX !== c, h = u.scaleY !== l, o && c <= 0 && c < u.scaleX && (f = !0, t.x = 0), o && l <= 0 && l < u.scaleY && (d = !0, t.y = 0), \"equally\" !== n || i || r ? n ? \"x\" !== n || u.get(\"lockUniScaling\") ? \"y\" !== n || u.get(\"lockUniScaling\") || d || r || u.set(\"scaleY\", l) && (g = g || h) : f || i || u.set(\"scaleX\", c) && (g = g || a) : (f || i || u.set(\"scaleX\", c) && (g = g || a), d || r || u.set(\"scaleY\", l) && (g = g || h)) : g = this._scaleObjectEqually(t, u, e, s), e.newScaleX = c, e.newScaleY = l, f || d || this._flipObject(e, n), g;\n          },\n          _scaleObjectEqually: function _scaleObjectEqually(t, e, i, r) {\n            var n,\n                o = t.y + t.x,\n                s = r.y * i.original.scaleY / e.scaleY + r.x * i.original.scaleX / e.scaleX,\n                a = t.x < 0 ? -1 : 1,\n                h = t.y < 0 ? -1 : 1;\n            return i.newScaleX = a * Math.abs(i.original.scaleX * o / s), i.newScaleY = h * Math.abs(i.original.scaleY * o / s), n = i.newScaleX !== e.scaleX || i.newScaleY !== e.scaleY, e.set(\"scaleX\", i.newScaleX), e.set(\"scaleY\", i.newScaleY), n;\n          },\n          _flipObject: function _flipObject(t, e) {\n            t.newScaleX < 0 && \"y\" !== e && (\"left\" === t.originX ? t.originX = \"right\" : \"right\" === t.originX && (t.originX = \"left\")), t.newScaleY < 0 && \"x\" !== e && (\"top\" === t.originY ? t.originY = \"bottom\" : \"bottom\" === t.originY && (t.originY = \"top\"));\n          },\n          _setLocalMouse: function _setLocalMouse(t, e) {\n            var i = e.target,\n                r = this.getZoom(),\n                o = i.padding / r;\n            \"right\" === e.originX ? t.x *= -1 : \"center\" === e.originX && (t.x *= 2 * e.mouseXSign, t.x < 0 && (e.mouseXSign = -e.mouseXSign)), \"bottom\" === e.originY ? t.y *= -1 : \"center\" === e.originY && (t.y *= 2 * e.mouseYSign, t.y < 0 && (e.mouseYSign = -e.mouseYSign)), n(t.x) > o ? t.x < 0 ? t.x += o : t.x -= o : t.x = 0, n(t.y) > o ? t.y < 0 ? t.y += o : t.y -= o : t.y = 0;\n          },\n          _rotateObject: function _rotateObject(t, e) {\n            var n = this._currentTransform,\n                o = n.target,\n                s = o.translateToOriginPoint(o.getCenterPoint(), n.originX, n.originY);\n            if (o.lockRotation) return !1;\n            var a = r(n.ey - s.y, n.ex - s.x),\n                h = r(e - s.y, t - s.x),\n                c = i(h - a + n.theta),\n                l = !0;\n\n            if (0 < o.snapAngle) {\n              var u = o.snapAngle,\n                  f = o.snapThreshold || u,\n                  d = Math.ceil(c / u) * u,\n                  g = Math.floor(c / u) * u;\n              Math.abs(c - g) < f ? c = g : Math.abs(c - d) < f && (c = d);\n            }\n\n            return c < 0 && (c = 360 + c), c %= 360, o.angle === c ? l = !1 : (o.angle = c, o.setPositionByOrigin(s, n.originX, n.originY)), l;\n          },\n          setCursor: function setCursor(t) {\n            this.upperCanvasEl.style.cursor = t;\n          },\n          _drawSelection: function _drawSelection(t) {\n            var e = this._groupSelector,\n                i = e.left,\n                r = e.top,\n                s = n(i),\n                a = n(r);\n            if (this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(e.ex - (0 < i ? 0 : -i), e.ey - (0 < r ? 0 : -r), s, a)), this.selectionLineWidth && this.selectionBorderColor) if (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, 1 < this.selectionDashArray.length && !o) {\n              var h = e.ex + .5 - (0 < i ? 0 : s),\n                  c = e.ey + .5 - (0 < r ? 0 : a);\n              t.beginPath(), A.util.drawDashedLine(t, h, c, h + s, c, this.selectionDashArray), A.util.drawDashedLine(t, h, c + a - 1, h + s, c + a - 1, this.selectionDashArray), A.util.drawDashedLine(t, h, c, h, c + a, this.selectionDashArray), A.util.drawDashedLine(t, h + s - 1, c, h + s - 1, c + a, this.selectionDashArray), t.closePath(), t.stroke();\n            } else A.Object.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(e.ex + .5 - (0 < i ? 0 : s), e.ey + .5 - (0 < r ? 0 : a), s, a);\n          },\n          findTarget: function findTarget(t, e) {\n            if (!this.skipTargetFind) {\n              var i,\n                  r,\n                  n = this.getPointer(t, !0),\n                  o = this._activeObject,\n                  s = this.getActiveObjects();\n              if (this.targets = [], 1 < s.length && !e && o === this._searchPossibleTargets([o], n)) return o;\n              if (1 === s.length && o._findTargetCorner(n)) return o;\n\n              if (1 === s.length && o === this._searchPossibleTargets([o], n)) {\n                if (!this.preserveObjectStacking) return o;\n                i = o, r = this.targets, this.targets = [];\n              }\n\n              var a = this._searchPossibleTargets(this._objects, n);\n\n              return t[this.altSelectionKey] && a && i && a !== i && (a = i, this.targets = r), a;\n            }\n          },\n          _checkTarget: function _checkTarget(t, e, i) {\n            if (e && e.visible && e.evented && this.containsPoint(null, e, t)) {\n              if (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing) return !0;\n              if (!this.isTargetTransparent(e, i.x, i.y)) return !0;\n            }\n          },\n          _searchPossibleTargets: function _searchPossibleTargets(t, e) {\n            for (var i, r, n = t.length; n--;) {\n              var o = t[n],\n                  s = o.group && \"activeSelection\" !== o.group.type ? this._normalizePointer(o.group, e) : e;\n\n              if (this._checkTarget(s, o, e)) {\n                (i = t[n]).subTargetCheck && i instanceof A.Group && (r = this._searchPossibleTargets(i._objects, e)) && this.targets.push(r);\n                break;\n              }\n            }\n\n            return i;\n          },\n          restorePointerVpt: function restorePointerVpt(t) {\n            return A.util.transformPoint(t, A.util.invertTransform(this.viewportTransform));\n          },\n          getPointer: function getPointer(e, i) {\n            if (this._absolutePointer && !i) return this._absolutePointer;\n            if (this._pointer && i) return this._pointer;\n            var r,\n                n = t(e),\n                o = this.upperCanvasEl,\n                s = o.getBoundingClientRect(),\n                a = s.width || 0,\n                h = s.height || 0;\n            return a && h || (\"top\" in s && \"bottom\" in s && (h = Math.abs(s.top - s.bottom)), \"right\" in s && \"left\" in s && (a = Math.abs(s.right - s.left))), this.calcOffset(), n.x = n.x - this._offset.left, n.y = n.y - this._offset.top, i || (n = this.restorePointerVpt(n)), r = 0 === a || 0 === h ? {\n              width: 1,\n              height: 1\n            } : {\n              width: o.width / a,\n              height: o.height / h\n            }, {\n              x: n.x * r.width,\n              y: n.y * r.height\n            };\n          },\n          _createUpperCanvas: function _createUpperCanvas() {\n            var t = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\");\n            this.upperCanvasEl ? this.upperCanvasEl.className = \"\" : this.upperCanvasEl = this._createCanvasElement(), A.util.addClass(this.upperCanvasEl, \"upper-canvas \" + t), this.wrapperEl.appendChild(this.upperCanvasEl), this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl), this._applyCanvasStyle(this.upperCanvasEl), this.contextTop = this.upperCanvasEl.getContext(\"2d\");\n          },\n          _createCacheCanvas: function _createCacheCanvas() {\n            this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute(\"width\", this.width), this.cacheCanvasEl.setAttribute(\"height\", this.height), this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n          },\n          _initWrapperElement: function _initWrapperElement() {\n            this.wrapperEl = A.util.wrapElement(this.lowerCanvasEl, \"div\", {\n              class: this.containerClass\n            }), A.util.setStyle(this.wrapperEl, {\n              width: this.width + \"px\",\n              height: this.height + \"px\",\n              position: \"relative\"\n            }), A.util.makeElementUnselectable(this.wrapperEl);\n          },\n          _applyCanvasStyle: function _applyCanvasStyle(t) {\n            var e = this.width || t.width,\n                i = this.height || t.height;\n            A.util.setStyle(t, {\n              position: \"absolute\",\n              width: e + \"px\",\n              height: i + \"px\",\n              left: 0,\n              top: 0,\n              \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            }), t.width = e, t.height = i, A.util.makeElementUnselectable(t);\n          },\n          _copyCanvasStyle: function _copyCanvasStyle(t, e) {\n            e.style.cssText = t.style.cssText;\n          },\n          getSelectionContext: function getSelectionContext() {\n            return this.contextTop;\n          },\n          getSelectionElement: function getSelectionElement() {\n            return this.upperCanvasEl;\n          },\n          getActiveObject: function getActiveObject() {\n            return this._activeObject;\n          },\n          getActiveObjects: function getActiveObjects() {\n            var t = this._activeObject;\n            return t ? \"activeSelection\" === t.type && t._objects ? t._objects.slice(0) : [t] : [];\n          },\n          _onObjectRemoved: function _onObjectRemoved(t) {\n            t === this._activeObject && (this.fire(\"before:selection:cleared\", {\n              target: t\n            }), this._discardActiveObject(), this.fire(\"selection:cleared\", {\n              target: t\n            }), t.fire(\"deselected\")), this._hoveredTarget === t && (this._hoveredTarget = null), this.callSuper(\"_onObjectRemoved\", t);\n          },\n          _fireSelectionEvents: function _fireSelectionEvents(t, e) {\n            var i = !1,\n                r = this.getActiveObjects(),\n                n = [],\n                o = [],\n                s = {\n              e: e\n            };\n            t.forEach(function (t) {\n              -1 === r.indexOf(t) && (i = !0, t.fire(\"deselected\", s), o.push(t));\n            }), r.forEach(function (e) {\n              -1 === t.indexOf(e) && (i = !0, e.fire(\"selected\", s), n.push(e));\n            }), 0 < t.length && 0 < r.length ? (s.selected = n, s.deselected = o, s.updated = n[0] || o[0], s.target = this._activeObject, i && this.fire(\"selection:updated\", s)) : 0 < r.length ? (1 === r.length && (s.target = n[0], this.fire(\"object:selected\", s)), s.selected = n, s.target = this._activeObject, this.fire(\"selection:created\", s)) : 0 < t.length && (s.deselected = o, this.fire(\"selection:cleared\", s));\n          },\n          setActiveObject: function setActiveObject(t, e) {\n            var i = this.getActiveObjects();\n            return this._setActiveObject(t, e), this._fireSelectionEvents(i, e), this;\n          },\n          _setActiveObject: function _setActiveObject(t, e) {\n            return this._activeObject !== t && !!this._discardActiveObject(e, t) && !t.onSelect({\n              e: e\n            }) && (this._activeObject = t, !0);\n          },\n          _discardActiveObject: function _discardActiveObject(t, e) {\n            var i = this._activeObject;\n\n            if (i) {\n              if (i.onDeselect({\n                e: t,\n                object: e\n              })) return !1;\n              this._activeObject = null;\n            }\n\n            return !0;\n          },\n          discardActiveObject: function discardActiveObject(t) {\n            var e = this.getActiveObjects();\n            return e.length && this.fire(\"before:selection:cleared\", {\n              target: e[0],\n              e: t\n            }), this._discardActiveObject(t), this._fireSelectionEvents(e, t), this;\n          },\n          dispose: function dispose() {\n            var t = this.wrapperEl;\n            return this.removeListeners(), t.removeChild(this.upperCanvasEl), t.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, [\"upperCanvasEl\", \"cacheCanvasEl\"].forEach(function (t) {\n              A.util.cleanUpJsdomNode(this[t]), this[t] = void 0;\n            }.bind(this)), t.parentNode && t.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, A.StaticCanvas.prototype.dispose.call(this), this;\n          },\n          clear: function clear() {\n            return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper(\"clear\");\n          },\n          drawControls: function drawControls(t) {\n            var e = this._activeObject;\n            e && e._renderControls(t);\n          },\n          _toObject: function _toObject(t, e, i) {\n            var r = this._realizeGroupTransformOnObject(t),\n                n = this.callSuper(\"_toObject\", t, e, i);\n\n            return this._unwindGroupTransformOnObject(t, r), n;\n          },\n          _realizeGroupTransformOnObject: function _realizeGroupTransformOnObject(t) {\n            if (t.group && \"activeSelection\" === t.group.type && this._activeObject === t.group) {\n              var e = {};\n              return [\"angle\", \"flipX\", \"flipY\", \"left\", \"scaleX\", \"scaleY\", \"skewX\", \"skewY\", \"top\"].forEach(function (i) {\n                e[i] = t[i];\n              }), this._activeObject.realizeTransform(t), e;\n            }\n\n            return null;\n          },\n          _unwindGroupTransformOnObject: function _unwindGroupTransformOnObject(t, e) {\n            e && t.set(e);\n          },\n          _setSVGObject: function _setSVGObject(t, e, i) {\n            var r = this._realizeGroupTransformOnObject(e);\n\n            this.callSuper(\"_setSVGObject\", t, e, i), this._unwindGroupTransformOnObject(e, r);\n          },\n          setViewportTransform: function setViewportTransform(t) {\n            this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), A.StaticCanvas.prototype.setViewportTransform.call(this, t);\n          }\n        }), A.StaticCanvas) {\n          \"prototype\" !== s && (A.Canvas[s] = A.StaticCanvas[s]);\n        }\n\n        A.isTouchSupported && (A.Canvas.prototype._setCursorFromEvent = function () {});\n      }(), function () {\n        var t = {\n          mt: 0,\n          tr: 1,\n          mr: 2,\n          br: 3,\n          mb: 4,\n          bl: 5,\n          ml: 6,\n          tl: 7\n        },\n            e = A.util.addListener,\n            i = A.util.removeListener,\n            r = {\n          passive: !1\n        };\n\n        function n(t, e) {\n          return \"which\" in t ? t.which === e : t.button === e - 1;\n        }\n\n        A.util.object.extend(A.Canvas.prototype, {\n          cursorMap: [\"n-resize\", \"ne-resize\", \"e-resize\", \"se-resize\", \"s-resize\", \"sw-resize\", \"w-resize\", \"nw-resize\"],\n          _initEventListeners: function _initEventListeners() {\n            this.removeListeners(), this._bindEvents(), this.addOrRemove(e, \"add\");\n          },\n          addOrRemove: function addOrRemove(t, e) {\n            t(A.window, \"resize\", this._onResize), t(this.upperCanvasEl, \"mousedown\", this._onMouseDown), t(this.upperCanvasEl, \"mousemove\", this._onMouseMove, r), t(this.upperCanvasEl, \"mouseout\", this._onMouseOut), t(this.upperCanvasEl, \"mouseenter\", this._onMouseEnter), t(this.upperCanvasEl, \"wheel\", this._onMouseWheel), t(this.upperCanvasEl, \"contextmenu\", this._onContextMenu), t(this.upperCanvasEl, \"dblclick\", this._onDoubleClick), t(this.upperCanvasEl, \"touchstart\", this._onMouseDown, r), t(this.upperCanvasEl, \"touchmove\", this._onMouseMove, r), t(this.upperCanvasEl, \"dragover\", this._onDragOver), t(this.upperCanvasEl, \"dragenter\", this._onDragEnter), t(this.upperCanvasEl, \"dragleave\", this._onDragLeave), t(this.upperCanvasEl, \"drop\", this._onDrop), \"undefined\" != typeof eventjs && e in eventjs && (eventjs[e](this.upperCanvasEl, \"gesture\", this._onGesture), eventjs[e](this.upperCanvasEl, \"drag\", this._onDrag), eventjs[e](this.upperCanvasEl, \"orientation\", this._onOrientationChange), eventjs[e](this.upperCanvasEl, \"shake\", this._onShake), eventjs[e](this.upperCanvasEl, \"longpress\", this._onLongPress));\n          },\n          removeListeners: function removeListeners() {\n            this.addOrRemove(i, \"remove\"), i(A.document, \"mouseup\", this._onMouseUp), i(A.document, \"touchend\", this._onMouseUp, r), i(A.document, \"mousemove\", this._onMouseMove, r), i(A.document, \"touchmove\", this._onMouseMove, r);\n          },\n          _bindEvents: function _bindEvents() {\n            this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\"), this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\"), this._onDrop = this._simpleEventHandler.bind(this, \"drop\"), this.eventsBound = !0);\n          },\n          _onGesture: function _onGesture(t, e) {\n            this.__onTransformGesture && this.__onTransformGesture(t, e);\n          },\n          _onDrag: function _onDrag(t, e) {\n            this.__onDrag && this.__onDrag(t, e);\n          },\n          _onMouseWheel: function _onMouseWheel(t) {\n            this.__onMouseWheel(t);\n          },\n          _onMouseOut: function _onMouseOut(t) {\n            var e = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n              target: e,\n              e: t\n            }), this._hoveredTarget = null, e && e.fire(\"mouseout\", {\n              e: t\n            }), this._iTextInstances && this._iTextInstances.forEach(function (t) {\n              t.isEditing && t.hiddenTextarea.focus();\n            });\n          },\n          _onMouseEnter: function _onMouseEnter(t) {\n            this.findTarget(t) || (this.fire(\"mouse:over\", {\n              target: null,\n              e: t\n            }), this._hoveredTarget = null);\n          },\n          _onOrientationChange: function _onOrientationChange(t, e) {\n            this.__onOrientationChange && this.__onOrientationChange(t, e);\n          },\n          _onShake: function _onShake(t, e) {\n            this.__onShake && this.__onShake(t, e);\n          },\n          _onLongPress: function _onLongPress(t, e) {\n            this.__onLongPress && this.__onLongPress(t, e);\n          },\n          _onDragOver: function _onDragOver(t) {\n            t.preventDefault();\n\n            var e = this._simpleEventHandler(\"dragover\", t);\n\n            this._fireEnterLeaveEvents(e, t);\n          },\n          _onContextMenu: function _onContextMenu(t) {\n            return this.stopContextMenu && (t.stopPropagation(), t.preventDefault()), !1;\n          },\n          _onDoubleClick: function _onDoubleClick(t) {\n            this._cacheTransformEventData(t), this._handleEvent(t, \"dblclick\"), this._resetTransformEventData(t);\n          },\n          _onMouseDown: function _onMouseDown(t) {\n            this.__onMouseDown(t), this._resetTransformEventData(), e(A.document, \"touchend\", this._onMouseUp, r), e(A.document, \"touchmove\", this._onMouseMove, r), i(this.upperCanvasEl, \"mousemove\", this._onMouseMove, r), i(this.upperCanvasEl, \"touchmove\", this._onMouseMove, r), \"touchstart\" === t.type ? i(this.upperCanvasEl, \"mousedown\", this._onMouseDown) : (e(A.document, \"mouseup\", this._onMouseUp), e(A.document, \"mousemove\", this._onMouseMove, r));\n          },\n          _onMouseUp: function _onMouseUp(t) {\n            if (this.__onMouseUp(t), this._resetTransformEventData(), i(A.document, \"mouseup\", this._onMouseUp), i(A.document, \"touchend\", this._onMouseUp, r), i(A.document, \"mousemove\", this._onMouseMove, r), i(A.document, \"touchmove\", this._onMouseMove, r), e(this.upperCanvasEl, \"mousemove\", this._onMouseMove, r), e(this.upperCanvasEl, \"touchmove\", this._onMouseMove, r), \"touchend\" === t.type) {\n              var n = this;\n              setTimeout(function () {\n                e(n.upperCanvasEl, \"mousedown\", n._onMouseDown);\n              }, 400);\n            }\n          },\n          _onMouseMove: function _onMouseMove(t) {\n            !this.allowTouchScrolling && t.preventDefault && t.preventDefault(), this.__onMouseMove(t);\n          },\n          _onResize: function _onResize() {\n            this.calcOffset();\n          },\n          _shouldRender: function _shouldRender(t) {\n            var e = this._activeObject;\n            return !!(!!e != !!t || e && t && e !== t) || (e && e.isEditing, !1);\n          },\n          __onMouseUp: function __onMouseUp(t) {\n            var e,\n                i = this._currentTransform,\n                r = this._groupSelector,\n                o = !1,\n                s = !r || 0 === r.left && 0 === r.top;\n            if (this._cacheTransformEventData(t), e = this._target, this._handleEvent(t, \"up:before\"), !n(t, 3)) return n(t, 2) ? (this.fireMiddleClick && this._handleEvent(t, \"up\", 2, s), void this._resetTransformEventData()) : void (this.isDrawingMode && this._isCurrentlyDrawing ? this._onMouseUpInDrawingMode(t) : (i && (this._finalizeCurrentTransform(t), o = i.actionPerformed), s || (this._maybeGroupObjects(t), o || (o = this._shouldRender(e))), e && (e.isMoving = !1), this._setCursorFromEvent(t, e), this._handleEvent(t, \"up\", 1, s), this._groupSelector = null, this._currentTransform = null, e && (e.__corner = 0), o ? this.requestRenderAll() : s || this.renderTop()));\n            this.fireRightClick && this._handleEvent(t, \"up\", 3, s);\n          },\n          _simpleEventHandler: function _simpleEventHandler(t, e) {\n            var i = this.findTarget(e),\n                r = this.targets,\n                n = {\n              e: e,\n              target: i,\n              subTargets: r\n            };\n            if (this.fire(t, n), i && i.fire(t, n), !r) return i;\n\n            for (var o = 0; o < r.length; o++) {\n              r[o].fire(t, n);\n            }\n\n            return i;\n          },\n          _handleEvent: function _handleEvent(t, e, i, r) {\n            var n = this._target,\n                o = this.targets || [],\n                s = {\n              e: t,\n              target: n,\n              subTargets: o,\n              button: i || 1,\n              isClick: r || !1,\n              pointer: this._pointer,\n              absolutePointer: this._absolutePointer,\n              transform: this._currentTransform\n            };\n            this.fire(\"mouse:\" + e, s), n && n.fire(\"mouse\" + e, s);\n\n            for (var a = 0; a < o.length; a++) {\n              o[a].fire(\"mouse\" + e, s);\n            }\n          },\n          _finalizeCurrentTransform: function _finalizeCurrentTransform(t) {\n            var e,\n                i = this._currentTransform,\n                r = i.target,\n                n = {\n              e: t,\n              target: r,\n              transform: i\n            };\n            r._scaling && (r._scaling = !1), r.setCoords(), (i.actionPerformed || this.stateful && r.hasStateChanged()) && (i.actionPerformed && (e = this._addEventOptions(n, i), this._fire(e, n)), this._fire(\"modified\", n));\n          },\n          _addEventOptions: function _addEventOptions(t, e) {\n            var i, r;\n\n            switch (e.action) {\n              case \"scaleX\":\n                i = \"scaled\", r = \"x\";\n                break;\n\n              case \"scaleY\":\n                i = \"scaled\", r = \"y\";\n                break;\n\n              case \"skewX\":\n                i = \"skewed\", r = \"x\";\n                break;\n\n              case \"skewY\":\n                i = \"skewed\", r = \"y\";\n                break;\n\n              case \"scale\":\n                i = \"scaled\", r = \"equally\";\n                break;\n\n              case \"rotate\":\n                i = \"rotated\";\n                break;\n\n              case \"drag\":\n                i = \"moved\";\n            }\n\n            return t.by = r, i;\n          },\n          _onMouseDownInDrawingMode: function _onMouseDownInDrawingMode(t) {\n            this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(t).requestRenderAll(), this.clipTo && A.util.clipContext(this, this.contextTop);\n            var e = this.getPointer(t);\n            this.freeDrawingBrush.onMouseDown(e), this._handleEvent(t, \"down\");\n          },\n          _onMouseMoveInDrawingMode: function _onMouseMoveInDrawingMode(t) {\n            if (this._isCurrentlyDrawing) {\n              var e = this.getPointer(t);\n              this.freeDrawingBrush.onMouseMove(e);\n            }\n\n            this.setCursor(this.freeDrawingCursor), this._handleEvent(t, \"move\");\n          },\n          _onMouseUpInDrawingMode: function _onMouseUpInDrawingMode(t) {\n            this._isCurrentlyDrawing = !1, this.clipTo && this.contextTop.restore(), this.freeDrawingBrush.onMouseUp(), this._handleEvent(t, \"up\");\n          },\n          __onMouseDown: function __onMouseDown(t) {\n            this._cacheTransformEventData(t), this._handleEvent(t, \"down:before\");\n            var e = this._target;\n            if (n(t, 3)) this.fireRightClick && this._handleEvent(t, \"down\", 3);else if (n(t, 2)) this.fireMiddleClick && this._handleEvent(t, \"down\", 2);else if (this.isDrawingMode) this._onMouseDownInDrawingMode(t);else if (!this._currentTransform) {\n              var i = this._pointer;\n              this._previousPointer = i;\n\n              var r = this._shouldRender(e),\n                  o = this._shouldGroup(t, e);\n\n              this._shouldClearSelection(t, e) ? this.discardActiveObject(t) : o && (this._handleGrouping(t, e), e = this._activeObject), !this.selection || e && (e.selectable || e.isEditing || e === this._activeObject) || (this._groupSelector = {\n                ex: i.x,\n                ey: i.y,\n                top: 0,\n                left: 0\n              }), e && (e.selectable && this.setActiveObject(e, t), e !== this._activeObject || !e.__corner && o || this._setupCurrentTransform(t, e)), this._handleEvent(t, \"down\"), (r || o) && this.requestRenderAll();\n            }\n          },\n          _resetTransformEventData: function _resetTransformEventData() {\n            this._target = null, this._pointer = null, this._absolutePointer = null;\n          },\n          _cacheTransformEventData: function _cacheTransformEventData(t) {\n            this._resetTransformEventData(), this._pointer = this.getPointer(t, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t) || null;\n          },\n          _beforeTransform: function _beforeTransform(t) {\n            var e = this._currentTransform;\n            this.stateful && e.target.saveState(), this.fire(\"before:transform\", {\n              e: t,\n              transform: e\n            }), e.corner && this.onBeforeScaleRotate(e.target);\n          },\n          __onMouseMove: function __onMouseMove(t) {\n            var e, i;\n            if (this._handleEvent(t, \"move:before\"), this._cacheTransformEventData(t), this.isDrawingMode) this._onMouseMoveInDrawingMode(t);else if (!(void 0 !== t.touches && 1 < t.touches.length)) {\n              var r = this._groupSelector;\n              r ? (i = this._pointer, r.left = i.x - r.ex, r.top = i.y - r.ey, this.renderTop()) : this._currentTransform ? this._transformObject(t) : (e = this.findTarget(t) || null, this._setCursorFromEvent(t, e), this._fireOverOutEvents(e, t)), this._handleEvent(t, \"move\"), this._resetTransformEventData();\n            }\n          },\n          _fireOverOutEvents: function _fireOverOutEvents(t, e) {\n            this.fireSynteticInOutEvents(t, e, {\n              targetName: \"_hoveredTarget\",\n              canvasEvtOut: \"mouse:out\",\n              evtOut: \"mouseout\",\n              canvasEvtIn: \"mouse:over\",\n              evtIn: \"mouseover\"\n            });\n          },\n          _fireEnterLeaveEvents: function _fireEnterLeaveEvents(t, e) {\n            this.fireSynteticInOutEvents(t, e, {\n              targetName: \"_draggedoverTarget\",\n              evtOut: \"dragleave\",\n              evtIn: \"dragenter\"\n            });\n          },\n          fireSynteticInOutEvents: function fireSynteticInOutEvents(t, e, i) {\n            var r,\n                n,\n                o,\n                s = this[i.targetName],\n                a = s !== t,\n                h = i.canvasEvtIn,\n                c = i.canvasEvtOut;\n            a && (r = {\n              e: e,\n              target: t,\n              previousTarget: s\n            }, n = {\n              e: e,\n              target: s,\n              nextTarget: t\n            }, this[i.targetName] = t), o = t && a, s && a && (c && this.fire(c, n), s.fire(i.evtOut, n)), o && (h && this.fire(h, r), t.fire(i.evtIn, r));\n          },\n          __onMouseWheel: function __onMouseWheel(t) {\n            this._cacheTransformEventData(t), this._handleEvent(t, \"wheel\"), this._resetTransformEventData();\n          },\n          _transformObject: function _transformObject(t) {\n            var e = this.getPointer(t),\n                i = this._currentTransform;\n            i.reset = !1, i.target.isMoving = !0, i.shiftKey = t.shiftKey, i.altKey = t[this.centeredKey], this._beforeScaleTransform(t, i), this._performTransformAction(t, i, e), i.actionPerformed && this.requestRenderAll();\n          },\n          _performTransformAction: function _performTransformAction(t, e, i) {\n            var r = i.x,\n                n = i.y,\n                o = e.action,\n                s = !1,\n                a = {\n              target: e.target,\n              e: t,\n              transform: e,\n              pointer: i\n            };\n            \"rotate\" === o ? (s = this._rotateObject(r, n)) && this._fire(\"rotating\", a) : \"scale\" === o ? (s = this._onScale(t, e, r, n)) && this._fire(\"scaling\", a) : \"scaleX\" === o ? (s = this._scaleObject(r, n, \"x\")) && this._fire(\"scaling\", a) : \"scaleY\" === o ? (s = this._scaleObject(r, n, \"y\")) && this._fire(\"scaling\", a) : \"skewX\" === o ? (s = this._skewObject(r, n, \"x\")) && this._fire(\"skewing\", a) : \"skewY\" === o ? (s = this._skewObject(r, n, \"y\")) && this._fire(\"skewing\", a) : (s = this._translateObject(r, n)) && (this._fire(\"moving\", a), this.setCursor(a.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || s;\n          },\n          _fire: function _fire(t, e) {\n            this.fire(\"object:\" + t, e), e.target.fire(t, e);\n          },\n          _beforeScaleTransform: function _beforeScaleTransform(t, e) {\n            if (\"scale\" === e.action || \"scaleX\" === e.action || \"scaleY\" === e.action) {\n              var i = this._shouldCenterTransform(e.target);\n\n              (i && (\"center\" !== e.originX || \"center\" !== e.originY) || !i && \"center\" === e.originX && \"center\" === e.originY) && (this._resetCurrentTransform(), e.reset = !0);\n            }\n          },\n          _onScale: function _onScale(t, e, i, r) {\n            return this._isUniscalePossible(t, e.target) ? (e.currentAction = \"scale\", this._scaleObject(i, r)) : (e.reset || \"scale\" !== e.currentAction || this._resetCurrentTransform(), e.currentAction = \"scaleEqually\", this._scaleObject(i, r, \"equally\"));\n          },\n          _isUniscalePossible: function _isUniscalePossible(t, e) {\n            return (t[this.uniScaleKey] || this.uniScaleTransform) && !e.get(\"lockUniScaling\");\n          },\n          _setCursorFromEvent: function _setCursorFromEvent(t, e) {\n            if (!e) return this.setCursor(this.defaultCursor), !1;\n\n            var i = e.hoverCursor || this.hoverCursor,\n                r = this._activeObject && \"activeSelection\" === this._activeObject.type ? this._activeObject : null,\n                n = (!r || !r.contains(e)) && e._findTargetCorner(this.getPointer(t, !0));\n\n            n ? this.setCursor(this.getCornerCursor(n, e, t)) : this.setCursor(i);\n          },\n          getCornerCursor: function getCornerCursor(e, i, r) {\n            return this.actionIsDisabled(e, i, r) ? this.notAllowedCursor : e in t ? this._getRotatedCornerCursor(e, i, r) : \"mtr\" === e && i.hasRotatingPoint ? this.rotationCursor : this.defaultCursor;\n          },\n          actionIsDisabled: function actionIsDisabled(t, e, i) {\n            return \"mt\" === t || \"mb\" === t ? i[this.altActionKey] ? e.lockSkewingX : e.lockScalingY : \"ml\" === t || \"mr\" === t ? i[this.altActionKey] ? e.lockSkewingY : e.lockScalingX : \"mtr\" === t ? e.lockRotation : this._isUniscalePossible(i, e) ? e.lockScalingX && e.lockScalingY : e.lockScalingX || e.lockScalingY;\n          },\n          _getRotatedCornerCursor: function _getRotatedCornerCursor(e, i, r) {\n            var n = Math.round(i.angle % 360 / 45);\n            return n < 0 && (n += 8), n += t[e], r[this.altActionKey] && t[e] % 2 == 0 && (n += 2), n %= 8, this.cursorMap[n];\n          }\n        });\n      }(), v = Math.min, m = Math.max, A.util.object.extend(A.Canvas.prototype, {\n        _shouldGroup: function _shouldGroup(t, e) {\n          var i = this._activeObject;\n          return i && this._isSelectionKeyPressed(t) && e && e.selectable && this.selection && (i !== e || \"activeSelection\" === i.type) && !e.onSelect({\n            e: t\n          });\n        },\n        _handleGrouping: function _handleGrouping(t, e) {\n          var i = this._activeObject;\n          i.__corner || (e !== i || (e = this.findTarget(t, !0)) && e.selectable) && (i && \"activeSelection\" === i.type ? this._updateActiveSelection(e, t) : this._createActiveSelection(e, t));\n        },\n        _updateActiveSelection: function _updateActiveSelection(t, e) {\n          var i = this._activeObject,\n              r = i._objects.slice(0);\n\n          i.contains(t) ? (i.removeWithUpdate(t), this._hoveredTarget = t, 1 === i.size() && this._setActiveObject(i.item(0), e)) : (i.addWithUpdate(t), this._hoveredTarget = i), this._fireSelectionEvents(r, e);\n        },\n        _createActiveSelection: function _createActiveSelection(t, e) {\n          var i = this.getActiveObjects(),\n              r = this._createGroup(t);\n\n          this._hoveredTarget = r, this._setActiveObject(r, e), this._fireSelectionEvents(i, e);\n        },\n        _createGroup: function _createGroup(t) {\n          var e = this._objects,\n              i = e.indexOf(this._activeObject) < e.indexOf(t) ? [this._activeObject, t] : [t, this._activeObject];\n          return this._activeObject.isEditing && this._activeObject.exitEditing(), new A.ActiveSelection(i, {\n            canvas: this\n          });\n        },\n        _groupSelectedObjects: function _groupSelectedObjects(t) {\n          var e,\n              i = this._collectObjects(t);\n\n          1 === i.length ? this.setActiveObject(i[0], t) : 1 < i.length && (e = new A.ActiveSelection(i.reverse(), {\n            canvas: this\n          }), this.setActiveObject(e, t));\n        },\n        _collectObjects: function _collectObjects(t) {\n          for (var e, i = [], r = this._groupSelector.ex, n = this._groupSelector.ey, o = r + this._groupSelector.left, s = n + this._groupSelector.top, a = new A.Point(v(r, o), v(n, s)), h = new A.Point(m(r, o), m(n, s)), c = !this.selectionFullyContained, l = r === o && n === s, u = this._objects.length; u-- && !((e = this._objects[u]) && e.selectable && e.visible && !e.onSelect({\n            e: t\n          }) && (c && e.intersectsWithRect(a, h) || e.isContainedWithinRect(a, h) || c && e.containsPoint(a) || c && e.containsPoint(h)) && (i.push(e), l));) {\n            ;\n          }\n\n          return i;\n        },\n        _maybeGroupObjects: function _maybeGroupObjects(t) {\n          this.selection && this._groupSelector && this._groupSelectedObjects(t), this.setCursor(this.defaultCursor), this._groupSelector = null;\n        }\n      }), y = A.StaticCanvas.supports(\"toDataURLWithQuality\"), A.util.object.extend(A.StaticCanvas.prototype, {\n        toDataURL: function toDataURL(t) {\n          t || (t = {});\n          var e = t.format || \"png\",\n              i = t.quality || 1,\n              r = (t.multiplier || 1) * (t.enableRetinaScaling ? 1 : 1 / this.getRetinaScaling()),\n              n = {\n            left: t.left || 0,\n            top: t.top || 0,\n            width: t.width || 0,\n            height: t.height || 0\n          };\n          return this.__toDataURLWithMultiplier(e, i, n, r);\n        },\n        __toDataURLWithMultiplier: function __toDataURLWithMultiplier(t, e, i, r) {\n          var n = this.width,\n              o = this.height,\n              s = (i.width || this.width) * r,\n              a = (i.height || this.height) * r,\n              h = this.getZoom() * r,\n              c = this.viewportTransform,\n              l = [h, 0, 0, h, (c[4] - i.left) * r, (c[5] - i.top) * r],\n              u = this.interactive,\n              f = this.skipOffscreen,\n              d = n !== s || o !== a;\n          this.viewportTransform = l, this.skipOffscreen = !1, this.interactive = !1, d && this.setDimensions({\n            width: s,\n            height: a\n          }, {\n            backstoreOnly: !0\n          }), this.renderAll();\n\n          var g = this.__toDataURL(t, e, i);\n\n          return this.interactive = u, this.skipOffscreen = f, this.viewportTransform = c, d && this.setDimensions({\n            width: n,\n            height: o\n          }, {\n            backstoreOnly: !0\n          }), this.renderAll(), g;\n        },\n        __toDataURL: function __toDataURL(t, e) {\n          var i = this.contextContainer.canvas;\n          return y ? i.toDataURL(\"image/\" + t, e) : i.toDataURL(\"image/\" + t);\n        }\n      }), A.util.object.extend(A.StaticCanvas.prototype, {\n        loadFromDatalessJSON: function loadFromDatalessJSON(t, e, i) {\n          return this.loadFromJSON(t, e, i);\n        },\n        loadFromJSON: function loadFromJSON(t, e, i) {\n          if (t) {\n            var r = \"string\" == typeof t ? JSON.parse(t) : A.util.object.clone(t),\n                n = this,\n                o = this.renderOnAddRemove;\n            return this.renderOnAddRemove = !1, this._enlivenObjects(r.objects, function (t) {\n              n.clear(), n._setBgOverlay(r, function () {\n                t.forEach(function (t, e) {\n                  n.insertAt(t, e);\n                }), n.renderOnAddRemove = o, delete r.objects, delete r.backgroundImage, delete r.overlayImage, delete r.background, delete r.overlay, n._setOptions(r), n.renderAll(), e && e();\n              });\n            }, i), this;\n          }\n        },\n        _setBgOverlay: function _setBgOverlay(t, e) {\n          var i = {\n            backgroundColor: !1,\n            overlayColor: !1,\n            backgroundImage: !1,\n            overlayImage: !1\n          };\n\n          if (t.backgroundImage || t.overlayImage || t.background || t.overlay) {\n            var r = function r() {\n              i.backgroundImage && i.overlayImage && i.backgroundColor && i.overlayColor && e && e();\n            };\n\n            this.__setBgOverlay(\"backgroundImage\", t.backgroundImage, i, r), this.__setBgOverlay(\"overlayImage\", t.overlayImage, i, r), this.__setBgOverlay(\"backgroundColor\", t.background, i, r), this.__setBgOverlay(\"overlayColor\", t.overlay, i, r);\n          } else e && e();\n        },\n        __setBgOverlay: function __setBgOverlay(t, e, i, r) {\n          var n = this;\n          if (!e) return i[t] = !0, void (r && r());\n          \"backgroundImage\" === t || \"overlayImage\" === t ? A.util.enlivenObjects([e], function (e) {\n            n[t] = e[0], i[t] = !0, r && r();\n          }) : this[\"set\" + A.util.string.capitalize(t, !0)](e, function () {\n            i[t] = !0, r && r();\n          });\n        },\n        _enlivenObjects: function _enlivenObjects(t, e, i) {\n          t && 0 !== t.length ? A.util.enlivenObjects(t, function (t) {\n            e && e(t);\n          }, null, i) : e && e([]);\n        },\n        _toDataURL: function _toDataURL(t, e) {\n          this.clone(function (i) {\n            e(i.toDataURL(t));\n          });\n        },\n        _toDataURLWithMultiplier: function _toDataURLWithMultiplier(t, e, i) {\n          this.clone(function (r) {\n            i(r.toDataURLWithMultiplier(t, e));\n          });\n        },\n        clone: function clone(t, e) {\n          var i = JSON.stringify(this.toJSON(e));\n          this.cloneWithoutData(function (e) {\n            e.loadFromJSON(i, function () {\n              t && t(e);\n            });\n          });\n        },\n        cloneWithoutData: function cloneWithoutData(t) {\n          var e = A.util.createCanvasElement();\n          e.width = this.width, e.height = this.height;\n          var i = new A.Canvas(e);\n          i.clipTo = this.clipTo, this.backgroundImage ? (i.setBackgroundImage(this.backgroundImage.src, function () {\n            i.renderAll(), t && t(i);\n          }), i.backgroundImageOpacity = this.backgroundImageOpacity, i.backgroundImageStretch = this.backgroundImageStretch) : t && t(i);\n        }\n      }), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.util.object.clone,\n            n = e.util.toFixed,\n            o = e.util.string.capitalize,\n            s = e.util.degreesToRadians,\n            a = e.StaticCanvas.supports(\"setLineDash\"),\n            h = !e.isLikelyNode;\n        e.Object || (e.Object = e.util.createClass(e.CommonMethods, {\n          type: \"object\",\n          originX: \"left\",\n          originY: \"top\",\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0,\n          scaleX: 1,\n          scaleY: 1,\n          flipX: !1,\n          flipY: !1,\n          opacity: 1,\n          angle: 0,\n          skewX: 0,\n          skewY: 0,\n          cornerSize: 13,\n          transparentCorners: !0,\n          hoverCursor: null,\n          moveCursor: null,\n          padding: 0,\n          borderColor: \"rgba(102,153,255,0.75)\",\n          borderDashArray: null,\n          cornerColor: \"rgba(102,153,255,0.5)\",\n          cornerStrokeColor: null,\n          cornerStyle: \"rect\",\n          cornerDashArray: null,\n          centeredScaling: !1,\n          centeredRotation: !0,\n          fill: \"rgb(0,0,0)\",\n          fillRule: \"nonzero\",\n          globalCompositeOperation: \"source-over\",\n          backgroundColor: \"\",\n          selectionBackgroundColor: \"\",\n          stroke: null,\n          strokeWidth: 1,\n          strokeDashArray: null,\n          strokeLineCap: \"butt\",\n          strokeLineJoin: \"miter\",\n          strokeMiterLimit: 4,\n          shadow: null,\n          borderOpacityWhenMoving: .4,\n          borderScaleFactor: 1,\n          transformMatrix: null,\n          minScaleLimit: 0,\n          selectable: !0,\n          evented: !0,\n          visible: !0,\n          hasControls: !0,\n          hasBorders: !0,\n          hasRotatingPoint: !0,\n          rotatingPointOffset: 40,\n          perPixelTargetFind: !1,\n          includeDefaultValues: !0,\n          clipTo: null,\n          lockMovementX: !1,\n          lockMovementY: !1,\n          lockRotation: !1,\n          lockScalingX: !1,\n          lockScalingY: !1,\n          lockUniScaling: !1,\n          lockSkewingX: !1,\n          lockSkewingY: !1,\n          lockScalingFlip: !1,\n          excludeFromExport: !1,\n          objectCaching: h,\n          statefullCache: !1,\n          noScaleCache: !0,\n          dirty: !0,\n          __corner: 0,\n          paintFirst: \"fill\",\n          stateProperties: \"top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor skewX skewY fillRule paintFirst\".split(\" \"),\n          cacheProperties: \"fill stroke strokeWidth strokeDashArray width height paintFirst strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor\".split(\" \"),\n          clipPath: void 0,\n          inverted: !1,\n          absolutePositioned: !1,\n          initialize: function initialize(t) {\n            t && this.setOptions(t);\n          },\n          _createCacheCanvas: function _createCacheCanvas() {\n            this._cacheProperties = {}, this._cacheCanvas = e.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext(\"2d\"), this._updateCacheCanvas(), this.dirty = !0;\n          },\n          _limitCacheSize: function _limitCacheSize(t) {\n            var i = e.perfLimitSizeTotal,\n                r = t.width,\n                n = t.height,\n                o = e.maxCacheSideLimit,\n                s = e.minCacheSideLimit;\n            if (r <= o && n <= o && r * n <= i) return r < s && (t.width = s), n < s && (t.height = s), t;\n            var a = r / n,\n                h = e.util.limitDimsByArea(a, i),\n                c = e.util.capValue,\n                l = c(s, h.x, o),\n                u = c(s, h.y, o);\n            return l < r && (t.zoomX /= r / l, t.width = l, t.capped = !0), u < n && (t.zoomY /= n / u, t.height = u, t.capped = !0), t;\n          },\n          _getCacheCanvasDimensions: function _getCacheCanvasDimensions() {\n            var t = this.getTotalObjectScaling(),\n                e = this._getNonTransformedDimensions(),\n                i = t.scaleX,\n                r = t.scaleY;\n\n            return {\n              width: e.x * i + 2,\n              height: e.y * r + 2,\n              zoomX: i,\n              zoomY: r,\n              x: e.x,\n              y: e.y\n            };\n          },\n          _updateCacheCanvas: function _updateCacheCanvas() {\n            var t = this.canvas;\n\n            if (this.noScaleCache && t && t._currentTransform) {\n              var i = t._currentTransform.target,\n                  r = t._currentTransform.action;\n              if (this === i && r.slice && \"scale\" === r.slice(0, 5)) return !1;\n            }\n\n            var n,\n                o,\n                s = this._cacheCanvas,\n                a = this._limitCacheSize(this._getCacheCanvasDimensions()),\n                h = e.minCacheSideLimit,\n                c = a.width,\n                l = a.height,\n                u = a.zoomX,\n                f = a.zoomY,\n                d = c !== this.cacheWidth || l !== this.cacheHeight,\n                g = this.zoomX !== u || this.zoomY !== f,\n                p = d || g,\n                v = 0,\n                m = 0,\n                y = !1;\n\n            if (d) {\n              var _ = this._cacheCanvas.width,\n                  b = this._cacheCanvas.height,\n                  x = _ < c || b < l;\n              y = x || (c < .9 * _ || l < .9 * b) && h < _ && h < b, x && !a.capped && (h < c || h < l) && (v = .1 * c, m = .1 * l);\n            }\n\n            return !!p && (y ? (s.width = Math.ceil(c + v), s.height = Math.ceil(l + m)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, s.width, s.height)), n = a.x * u / 2, o = a.y * f / 2, this.cacheTranslationX = Math.round(s.width / 2 - n) + n, this.cacheTranslationY = Math.round(s.height / 2 - o) + o, this.cacheWidth = c, this.cacheHeight = l, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(u, f), this.zoomX = u, this.zoomY = f, !0);\n          },\n          setOptions: function setOptions(t) {\n            this._setOptions(t), this._initGradient(t.fill, \"fill\"), this._initGradient(t.stroke, \"stroke\"), this._initClipping(t), this._initPattern(t.fill, \"fill\"), this._initPattern(t.stroke, \"stroke\");\n          },\n          transform: function transform(t) {\n            var e;\n            e = this.group && !this.group._transformDone ? this.calcTransformMatrix() : this.calcOwnMatrix(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n          },\n          toObject: function toObject(t) {\n            var i = e.Object.NUM_FRACTION_DIGITS,\n                r = {\n              type: this.type,\n              version: e.version,\n              originX: this.originX,\n              originY: this.originY,\n              left: n(this.left, i),\n              top: n(this.top, i),\n              width: n(this.width, i),\n              height: n(this.height, i),\n              fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n              stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n              strokeWidth: n(this.strokeWidth, i),\n              strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n              strokeLineCap: this.strokeLineCap,\n              strokeLineJoin: this.strokeLineJoin,\n              strokeMiterLimit: n(this.strokeMiterLimit, i),\n              scaleX: n(this.scaleX, i),\n              scaleY: n(this.scaleY, i),\n              angle: n(this.angle, i),\n              flipX: this.flipX,\n              flipY: this.flipY,\n              opacity: n(this.opacity, i),\n              shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n              visible: this.visible,\n              clipTo: this.clipTo && String(this.clipTo),\n              backgroundColor: this.backgroundColor,\n              fillRule: this.fillRule,\n              paintFirst: this.paintFirst,\n              globalCompositeOperation: this.globalCompositeOperation,\n              transformMatrix: this.transformMatrix ? this.transformMatrix.concat() : null,\n              skewX: n(this.skewX, i),\n              skewY: n(this.skewY, i)\n            };\n            return this.clipPath && (r.clipPath = this.clipPath.toObject(t), r.clipPath.inverted = this.clipPath.inverted, r.clipPath.absolutePositioned = this.clipPath.absolutePositioned), e.util.populateWithProperties(this, r, t), this.includeDefaultValues || (r = this._removeDefaultValues(r)), r;\n          },\n          toDatalessObject: function toDatalessObject(t) {\n            return this.toObject(t);\n          },\n          _removeDefaultValues: function _removeDefaultValues(t) {\n            var i = e.util.getKlass(t.type).prototype;\n            return i.stateProperties.forEach(function (e) {\n              t[e] === i[e] && delete t[e], \"[object Array]\" === Object.prototype.toString.call(t[e]) && \"[object Array]\" === Object.prototype.toString.call(i[e]) && 0 === t[e].length && 0 === i[e].length && delete t[e];\n            }), t;\n          },\n          toString: function toString() {\n            return \"#<fabric.\" + o(this.type) + \">\";\n          },\n          getObjectScaling: function getObjectScaling() {\n            var t = this.scaleX,\n                e = this.scaleY;\n\n            if (this.group) {\n              var i = this.group.getObjectScaling();\n              t *= i.scaleX, e *= i.scaleY;\n            }\n\n            return {\n              scaleX: t,\n              scaleY: e\n            };\n          },\n          getTotalObjectScaling: function getTotalObjectScaling() {\n            var t = this.getObjectScaling(),\n                e = t.scaleX,\n                i = t.scaleY;\n\n            if (this.canvas) {\n              var r = this.canvas.getZoom(),\n                  n = this.canvas.getRetinaScaling();\n              e *= r * n, i *= r * n;\n            }\n\n            return {\n              scaleX: e,\n              scaleY: i\n            };\n          },\n          getObjectOpacity: function getObjectOpacity() {\n            var t = this.opacity;\n            return this.group && (t *= this.group.getObjectOpacity()), t;\n          },\n          _set: function _set(t, i) {\n            var r = \"scaleX\" === t || \"scaleY\" === t,\n                n = this[t] !== i,\n                o = !1;\n            return r && (i = this._constrainScale(i)), \"scaleX\" === t && i < 0 ? (this.flipX = !this.flipX, i *= -1) : \"scaleY\" === t && i < 0 ? (this.flipY = !this.flipY, i *= -1) : \"shadow\" !== t || !i || i instanceof e.Shadow ? \"dirty\" === t && this.group && this.group.set(\"dirty\", i) : i = new e.Shadow(i), this[t] = i, n && (o = this.group && this.group.isOnACache(), -1 < this.cacheProperties.indexOf(t) ? (this.dirty = !0, o && this.group.set(\"dirty\", !0)) : o && -1 < this.stateProperties.indexOf(t) && this.group.set(\"dirty\", !0)), this;\n          },\n          setOnGroup: function setOnGroup() {},\n          getViewportTransform: function getViewportTransform() {\n            return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e.iMatrix.concat();\n          },\n          isNotVisible: function isNotVisible() {\n            return 0 === this.opacity || 0 === this.width && 0 === this.height || !this.visible;\n          },\n          render: function render(t) {\n            this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t, this), this.transformMatrix && t.transform.apply(t, this.transformMatrix), this.clipTo && e.util.clipContext(this, t), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(t), this.objectCaching && this.statefullCache && this.saveState({\n              propertySet: \"cacheProperties\"\n            })), this.clipTo && t.restore(), t.restore());\n          },\n          renderCache: function renderCache(t) {\n            t = t || {}, this._cacheCanvas || this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({\n              propertySet: \"cacheProperties\"\n            }), this.drawObject(this._cacheContext, t.forClipping), this.dirty = !1);\n          },\n          _removeCacheCanvas: function _removeCacheCanvas() {\n            this._cacheCanvas = null, this.cacheWidth = 0, this.cacheHeight = 0;\n          },\n          needsItsOwnCache: function needsItsOwnCache() {\n            return \"stroke\" === this.paintFirst && \"object\" == typeof this.shadow || !!this.clipPath;\n          },\n          shouldCache: function shouldCache() {\n            return this.ownCaching = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache()), this.ownCaching;\n          },\n          willDrawShadow: function willDrawShadow() {\n            return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY);\n          },\n          drawClipPathOnCache: function drawClipPathOnCache(t) {\n            var i = this.clipPath;\n\n            if (t.save(), i.inverted ? t.globalCompositeOperation = \"destination-out\" : t.globalCompositeOperation = \"destination-in\", i.absolutePositioned) {\n              var r = e.util.invertTransform(this.calcTransformMatrix());\n              t.transform(r[0], r[1], r[2], r[3], r[4], r[5]);\n            }\n\n            i.transform(t), t.scale(1 / i.zoomX, 1 / i.zoomY), t.drawImage(i._cacheCanvas, -i.cacheTranslationX, -i.cacheTranslationY), t.restore();\n          },\n          drawObject: function drawObject(t, e) {\n            e ? this._setClippingProperties(t) : (this._renderBackground(t), this._setStrokeStyles(t, this), this._setFillStyles(t, this)), this._render(t), this._drawClipPath(t);\n          },\n          _drawClipPath: function _drawClipPath(t) {\n            var e = this.clipPath;\n            e && (e.canvas = this.canvas, e.shouldCache(), e._transformDone = !0, e.renderCache({\n              forClipping: !0\n            }), this.drawClipPathOnCache(t));\n          },\n          drawCacheOnCanvas: function drawCacheOnCanvas(t) {\n            t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n          },\n          isCacheDirty: function isCacheDirty(t) {\n            if (this.isNotVisible()) return !1;\n            if (this._cacheCanvas && !t && this._updateCacheCanvas()) return !0;\n\n            if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n              if (this._cacheCanvas && !t) {\n                var e = this.cacheWidth / this.zoomX,\n                    i = this.cacheHeight / this.zoomY;\n\n                this._cacheContext.clearRect(-e / 2, -i / 2, e, i);\n              }\n\n              return !0;\n            }\n\n            return !1;\n          },\n          _renderBackground: function _renderBackground(t) {\n            if (this.backgroundColor) {\n              var e = this._getNonTransformedDimensions();\n\n              t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t);\n            }\n          },\n          _setOpacity: function _setOpacity(t) {\n            this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity;\n          },\n          _setStrokeStyles: function _setStrokeStyles(t, e) {\n            e.stroke && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, t.strokeStyle = e.stroke.toLive ? e.stroke.toLive(t, this) : e.stroke);\n          },\n          _setFillStyles: function _setFillStyles(t, e) {\n            e.fill && (t.fillStyle = e.fill.toLive ? e.fill.toLive(t, this) : e.fill);\n          },\n          _setClippingProperties: function _setClippingProperties(t) {\n            t.globalAlpha = 1, t.strokeStyle = \"transparent\", t.fillStyle = \"#000000\";\n          },\n          _setLineDash: function _setLineDash(t, e, i) {\n            e && (1 & e.length && e.push.apply(e, e), a ? t.setLineDash(e) : i && i(t));\n          },\n          _renderControls: function _renderControls(t, i) {\n            var r,\n                n,\n                o,\n                a = this.getViewportTransform(),\n                h = this.calcTransformMatrix();\n            n = void 0 !== (i = i || {}).hasBorders ? i.hasBorders : this.hasBorders, o = void 0 !== i.hasControls ? i.hasControls : this.hasControls, h = e.util.multiplyTransformMatrices(a, h), r = e.util.qrDecompose(h), t.save(), t.translate(r.translateX, r.translateY), t.lineWidth = 1 * this.borderScaleFactor, this.group || (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), i.forActiveSelection ? (t.rotate(s(r.angle)), n && this.drawBordersInGroup(t, r, i)) : (t.rotate(s(this.angle)), n && this.drawBorders(t, i)), o && this.drawControls(t, i), t.restore();\n          },\n          _setShadow: function _setShadow(t) {\n            if (this.shadow) {\n              var i = this.canvas && this.canvas.viewportTransform[0] || 1,\n                  r = this.canvas && this.canvas.viewportTransform[3] || 1,\n                  n = this.getObjectScaling();\n              this.canvas && this.canvas._isRetinaScaling() && (i *= e.devicePixelRatio, r *= e.devicePixelRatio), t.shadowColor = this.shadow.color, t.shadowBlur = this.shadow.blur * e.browserShadowBlurConstant * (i + r) * (n.scaleX + n.scaleY) / 4, t.shadowOffsetX = this.shadow.offsetX * i * n.scaleX, t.shadowOffsetY = this.shadow.offsetY * r * n.scaleY;\n            }\n          },\n          _removeShadow: function _removeShadow(t) {\n            this.shadow && (t.shadowColor = \"\", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0);\n          },\n          _applyPatternGradientTransform: function _applyPatternGradientTransform(t, e) {\n            if (!e || !e.toLive) return {\n              offsetX: 0,\n              offsetY: 0\n            };\n            var i = e.gradientTransform || e.patternTransform,\n                r = -this.width / 2 + e.offsetX || 0,\n                n = -this.height / 2 + e.offsetY || 0;\n            return t.translate(r, n), i && t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), {\n              offsetX: r,\n              offsetY: n\n            };\n          },\n          _renderPaintInOrder: function _renderPaintInOrder(t) {\n            \"stroke\" === this.paintFirst ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t));\n          },\n          _renderFill: function _renderFill(t) {\n            this.fill && (t.save(), this._applyPatternGradientTransform(t, this.fill), \"evenodd\" === this.fillRule ? t.fill(\"evenodd\") : t.fill(), t.restore());\n          },\n          _renderStroke: function _renderStroke(t) {\n            this.stroke && 0 !== this.strokeWidth && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray, this._renderDashedStroke), this._applyPatternGradientTransform(t, this.stroke), t.stroke(), t.restore());\n          },\n          _findCenterFromElement: function _findCenterFromElement() {\n            return {\n              x: this.left + this.width / 2,\n              y: this.top + this.height / 2\n            };\n          },\n          _assignTransformMatrixProps: function _assignTransformMatrixProps() {\n            if (this.transformMatrix) {\n              var t = e.util.qrDecompose(this.transformMatrix);\n              this.flipX = !1, this.flipY = !1, this.set(\"scaleX\", t.scaleX), this.set(\"scaleY\", t.scaleY), this.angle = t.angle, this.skewX = t.skewX, this.skewY = 0;\n            }\n          },\n          _removeTransformMatrix: function _removeTransformMatrix(t) {\n            var i = this._findCenterFromElement();\n\n            this.transformMatrix && (this._assignTransformMatrixProps(), i = e.util.transformPoint(i, this.transformMatrix)), this.transformMatrix = null, t && (this.scaleX *= t.scaleX, this.scaleY *= t.scaleY, this.cropX = t.cropX, this.cropY = t.cropY, i.x += t.offsetLeft, i.y += t.offsetTop, this.width = t.width, this.height = t.height), this.setPositionByOrigin(i, \"center\", \"center\");\n          },\n          clone: function clone(t, i) {\n            var r = this.toObject(i);\n            this.constructor.fromObject ? this.constructor.fromObject(r, t) : e.Object._fromObject(\"Object\", r, t);\n          },\n          cloneAsImage: function cloneAsImage(t, i) {\n            var r = this.toDataURL(i);\n            return e.util.loadImage(r, function (i) {\n              t && t(new e.Image(i));\n            }), this;\n          },\n          toDataURL: function toDataURL(t) {\n            t || (t = {});\n            var i = e.util,\n                r = i.saveObjectTransform(this),\n                n = this.shadow,\n                o = Math.abs;\n            t.withoutTransform && i.resetObjectTransform(this), t.withoutShadow && (this.shadow = null);\n            var s,\n                a,\n                h = e.util.createCanvasElement(),\n                c = this.getBoundingRect(!0, !0),\n                l = this.shadow,\n                u = {\n              x: 0,\n              y: 0\n            };\n            l && (a = l.blur, s = this.getObjectScaling(), u.x = 2 * Math.round((o(l.offsetX) + a) * o(s.scaleX)), u.y = 2 * Math.round((o(l.offsetY) + a) * o(s.scaleY))), h.width = c.width + u.x, h.height = c.height + u.y, h.width += h.width % 2 ? 2 - h.width % 2 : 0, h.height += h.height % 2 ? 2 - h.height % 2 : 0;\n            var f = new e.StaticCanvas(h, {\n              enableRetinaScaling: t.enableRetinaScaling,\n              renderOnAddRemove: !1,\n              skipOffscreen: !1\n            });\n            \"jpeg\" === t.format && (f.backgroundColor = \"#fff\"), this.setPositionByOrigin(new e.Point(f.width / 2, f.height / 2), \"center\", \"center\");\n            var d = this.canvas;\n            f.add(this);\n            var g = f.toDataURL(t);\n            return this.shadow = n, this.set(r).setCoords(), this.canvas = d, f._objects = [], f.dispose(), f = null, g;\n          },\n          isType: function isType(t) {\n            return this.type === t;\n          },\n          complexity: function complexity() {\n            return 1;\n          },\n          toJSON: function toJSON(t) {\n            return this.toObject(t);\n          },\n          setGradient: function setGradient(t, i) {\n            i || (i = {});\n            var r = {\n              colorStops: []\n            };\n            return r.type = i.type || (i.r1 || i.r2 ? \"radial\" : \"linear\"), r.coords = {\n              x1: i.x1,\n              y1: i.y1,\n              x2: i.x2,\n              y2: i.y2\n            }, (i.r1 || i.r2) && (r.coords.r1 = i.r1, r.coords.r2 = i.r2), r.gradientTransform = i.gradientTransform, e.Gradient.prototype.addColorStop.call(r, i.colorStops), this.set(t, e.Gradient.forObject(this, r));\n          },\n          setPatternFill: function setPatternFill(t, i) {\n            return this.set(\"fill\", new e.Pattern(t, i));\n          },\n          setShadow: function setShadow(t) {\n            return this.set(\"shadow\", t ? new e.Shadow(t) : null);\n          },\n          setColor: function setColor(t) {\n            return this.set(\"fill\", t), this;\n          },\n          rotate: function rotate(t) {\n            var e = (\"center\" !== this.originX || \"center\" !== this.originY) && this.centeredRotation;\n            return e && this._setOriginToCenter(), this.set(\"angle\", t), e && this._resetOrigin(), this;\n          },\n          centerH: function centerH() {\n            return this.canvas && this.canvas.centerObjectH(this), this;\n          },\n          viewportCenterH: function viewportCenterH() {\n            return this.canvas && this.canvas.viewportCenterObjectH(this), this;\n          },\n          centerV: function centerV() {\n            return this.canvas && this.canvas.centerObjectV(this), this;\n          },\n          viewportCenterV: function viewportCenterV() {\n            return this.canvas && this.canvas.viewportCenterObjectV(this), this;\n          },\n          center: function center() {\n            return this.canvas && this.canvas.centerObject(this), this;\n          },\n          viewportCenter: function viewportCenter() {\n            return this.canvas && this.canvas.viewportCenterObject(this), this;\n          },\n          getLocalPointer: function getLocalPointer(t, i) {\n            i = i || this.canvas.getPointer(t);\n\n            var r = new e.Point(i.x, i.y),\n                n = this._getLeftTopCoords();\n\n            return this.angle && (r = e.util.rotatePoint(r, n, s(-this.angle))), {\n              x: r.x - n.x,\n              y: r.y - n.y\n            };\n          },\n          _setupCompositeOperation: function _setupCompositeOperation(t) {\n            this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation);\n          }\n        }), e.util.createAccessors && e.util.createAccessors(e.Object), i(e.Object.prototype, e.Observable), e.Object.NUM_FRACTION_DIGITS = 2, e.Object._fromObject = function (t, i, n, o) {\n          var s = e[t];\n          i = r(i, !0), e.util.enlivenPatterns([i.fill, i.stroke], function (t) {\n            void 0 !== t[0] && (i.fill = t[0]), void 0 !== t[1] && (i.stroke = t[1]), e.util.enlivenObjects([i.clipPath], function (t) {\n              i.clipPath = t[0];\n              var e = o ? new s(i[o], i) : new s(i);\n              n && n(e);\n            });\n          });\n        }, e.Object.__uid = 0);\n      }(e), _ = A.util.degreesToRadians, b = {\n        left: -.5,\n        center: 0,\n        right: .5\n      }, x = {\n        top: -.5,\n        center: 0,\n        bottom: .5\n      }, A.util.object.extend(A.Object.prototype, {\n        translateToGivenOrigin: function translateToGivenOrigin(t, e, i, r, n) {\n          var o,\n              s,\n              a,\n              h = t.x,\n              c = t.y;\n          return \"string\" == typeof e ? e = b[e] : e -= .5, \"string\" == typeof r ? r = b[r] : r -= .5, \"string\" == typeof i ? i = x[i] : i -= .5, \"string\" == typeof n ? n = x[n] : n -= .5, s = n - i, ((o = r - e) || s) && (a = this._getTransformedDimensions(), h = t.x + o * a.x, c = t.y + s * a.y), new A.Point(h, c);\n        },\n        translateToCenterPoint: function translateToCenterPoint(t, e, i) {\n          var r = this.translateToGivenOrigin(t, e, i, \"center\", \"center\");\n          return this.angle ? A.util.rotatePoint(r, t, _(this.angle)) : r;\n        },\n        translateToOriginPoint: function translateToOriginPoint(t, e, i) {\n          var r = this.translateToGivenOrigin(t, \"center\", \"center\", e, i);\n          return this.angle ? A.util.rotatePoint(r, t, _(this.angle)) : r;\n        },\n        getCenterPoint: function getCenterPoint() {\n          var t = new A.Point(this.left, this.top);\n          return this.translateToCenterPoint(t, this.originX, this.originY);\n        },\n        getPointByOrigin: function getPointByOrigin(t, e) {\n          var i = this.getCenterPoint();\n          return this.translateToOriginPoint(i, t, e);\n        },\n        toLocalPoint: function toLocalPoint(t, e, i) {\n          var r,\n              n,\n              o = this.getCenterPoint();\n          return r = void 0 !== e && void 0 !== i ? this.translateToGivenOrigin(o, \"center\", \"center\", e, i) : new A.Point(this.left, this.top), n = new A.Point(t.x, t.y), this.angle && (n = A.util.rotatePoint(n, o, -_(this.angle))), n.subtractEquals(r);\n        },\n        setPositionByOrigin: function setPositionByOrigin(t, e, i) {\n          var r = this.translateToCenterPoint(t, e, i),\n              n = this.translateToOriginPoint(r, this.originX, this.originY);\n          this.set(\"left\", n.x), this.set(\"top\", n.y);\n        },\n        adjustPosition: function adjustPosition(t) {\n          var e,\n              i,\n              r = _(this.angle),\n              n = this.getScaledWidth(),\n              o = A.util.cos(r) * n,\n              s = A.util.sin(r) * n;\n\n          e = \"string\" == typeof this.originX ? b[this.originX] : this.originX - .5, i = \"string\" == typeof t ? b[t] : t - .5, this.left += o * (i - e), this.top += s * (i - e), this.setCoords(), this.originX = t;\n        },\n        _setOriginToCenter: function _setOriginToCenter() {\n          this._originalOriginX = this.originX, this._originalOriginY = this.originY;\n          var t = this.getCenterPoint();\n          this.originX = \"center\", this.originY = \"center\", this.left = t.x, this.top = t.y;\n        },\n        _resetOrigin: function _resetOrigin() {\n          var t = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n          this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = t.x, this.top = t.y, this._originalOriginX = null, this._originalOriginY = null;\n        },\n        _getLeftTopCoords: function _getLeftTopCoords() {\n          return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n      }), C = A.util.degreesToRadians, S = A.util.multiplyTransformMatrices, w = A.util.transformPoint, A.util.object.extend(A.Object.prototype, {\n        oCoords: null,\n        aCoords: null,\n        ownMatrixCache: null,\n        matrixCache: null,\n        getCoords: function getCoords(t, e) {\n          this.oCoords || this.setCoords();\n          var i,\n              r = t ? this.aCoords : this.oCoords;\n          return i = e ? this.calcCoords(t) : r, [new A.Point(i.tl.x, i.tl.y), new A.Point(i.tr.x, i.tr.y), new A.Point(i.br.x, i.br.y), new A.Point(i.bl.x, i.bl.y)];\n        },\n        intersectsWithRect: function intersectsWithRect(t, e, i, r) {\n          var n = this.getCoords(i, r);\n          return \"Intersection\" === A.Intersection.intersectPolygonRectangle(n, t, e).status;\n        },\n        intersectsWithObject: function intersectsWithObject(t, e, i) {\n          return \"Intersection\" === A.Intersection.intersectPolygonPolygon(this.getCoords(e, i), t.getCoords(e, i)).status || t.isContainedWithinObject(this, e, i) || this.isContainedWithinObject(t, e, i);\n        },\n        isContainedWithinObject: function isContainedWithinObject(t, e, i) {\n          for (var r = this.getCoords(e, i), n = 0, o = t._getImageLines(i ? t.calcCoords(e) : e ? t.aCoords : t.oCoords); n < 4; n++) {\n            if (!t.containsPoint(r[n], o)) return !1;\n          }\n\n          return !0;\n        },\n        isContainedWithinRect: function isContainedWithinRect(t, e, i, r) {\n          var n = this.getBoundingRect(i, r);\n          return n.left >= t.x && n.left + n.width <= e.x && n.top >= t.y && n.top + n.height <= e.y;\n        },\n        containsPoint: function containsPoint(t, e, i, r) {\n          e = e || this._getImageLines(r ? this.calcCoords(i) : i ? this.aCoords : this.oCoords);\n\n          var n = this._findCrossPoints(t, e);\n\n          return 0 !== n && n % 2 == 1;\n        },\n        isOnScreen: function isOnScreen(t) {\n          if (!this.canvas) return !1;\n\n          for (var e, i = this.canvas.vptCoords.tl, r = this.canvas.vptCoords.br, n = this.getCoords(!0, t), o = 0; o < 4; o++) {\n            if ((e = n[o]).x <= r.x && e.x >= i.x && e.y <= r.y && e.y >= i.y) return !0;\n          }\n\n          return !!this.intersectsWithRect(i, r, !0, t) || this._containsCenterOfCanvas(i, r, t);\n        },\n        _containsCenterOfCanvas: function _containsCenterOfCanvas(t, e, i) {\n          var r = {\n            x: (t.x + e.x) / 2,\n            y: (t.y + e.y) / 2\n          };\n          return !!this.containsPoint(r, null, !0, i);\n        },\n        isPartiallyOnScreen: function isPartiallyOnScreen(t) {\n          if (!this.canvas) return !1;\n          var e = this.canvas.vptCoords.tl,\n              i = this.canvas.vptCoords.br;\n          return !!this.intersectsWithRect(e, i, !0, t) || this._containsCenterOfCanvas(e, i, t);\n        },\n        _getImageLines: function _getImageLines(t) {\n          return {\n            topline: {\n              o: t.tl,\n              d: t.tr\n            },\n            rightline: {\n              o: t.tr,\n              d: t.br\n            },\n            bottomline: {\n              o: t.br,\n              d: t.bl\n            },\n            leftline: {\n              o: t.bl,\n              d: t.tl\n            }\n          };\n        },\n        _findCrossPoints: function _findCrossPoints(t, e) {\n          var i,\n              r,\n              n = 0;\n\n          for (var o in e) {\n            if (!((r = e[o]).o.y < t.y && r.d.y < t.y || r.o.y >= t.y && r.d.y >= t.y || ((r.o.x === r.d.x && r.o.x >= t.x ? r.o.x : (i = (r.d.y - r.o.y) / (r.d.x - r.o.x), -(t.y - 0 * t.x - (r.o.y - i * r.o.x)) / (0 - i))) >= t.x && (n += 1), 2 !== n))) break;\n          }\n\n          return n;\n        },\n        getBoundingRect: function getBoundingRect(t, e) {\n          var i = this.getCoords(t, e);\n          return A.util.makeBoundingBoxFromPoints(i);\n        },\n        getScaledWidth: function getScaledWidth() {\n          return this._getTransformedDimensions().x;\n        },\n        getScaledHeight: function getScaledHeight() {\n          return this._getTransformedDimensions().y;\n        },\n        _constrainScale: function _constrainScale(t) {\n          return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : 0 === t ? 1e-4 : t;\n        },\n        scale: function scale(t) {\n          return this._set(\"scaleX\", t), this._set(\"scaleY\", t), this.setCoords();\n        },\n        scaleToWidth: function scaleToWidth(t, e) {\n          var i = this.getBoundingRect(e).width / this.getScaledWidth();\n          return this.scale(t / this.width / i);\n        },\n        scaleToHeight: function scaleToHeight(t, e) {\n          var i = this.getBoundingRect(e).height / this.getScaledHeight();\n          return this.scale(t / this.height / i);\n        },\n        calcCoords: function calcCoords(t) {\n          var e = this._calcRotateMatrix(),\n              i = this._calcTranslateMatrix(),\n              r = S(i, e),\n              n = this.getViewportTransform(),\n              o = t ? r : S(n, r),\n              s = this._getTransformedDimensions(),\n              a = s.x / 2,\n              h = s.y / 2,\n              c = w({\n            x: -a,\n            y: -h\n          }, o),\n              l = w({\n            x: a,\n            y: -h\n          }, o),\n              u = w({\n            x: -a,\n            y: h\n          }, o),\n              f = w({\n            x: a,\n            y: h\n          }, o);\n\n          if (!t) {\n            var d = this.padding,\n                g = C(this.angle),\n                p = A.util.cos(g),\n                v = A.util.sin(g),\n                m = p * d,\n                y = v * d,\n                _ = m + y,\n                b = m - y;\n\n            d && (c.x -= b, c.y -= _, l.x += _, l.y -= b, u.x -= _, u.y += b, f.x += b, f.y += _);\n            var x = new A.Point((c.x + u.x) / 2, (c.y + u.y) / 2),\n                T = new A.Point((l.x + c.x) / 2, (l.y + c.y) / 2),\n                O = new A.Point((f.x + l.x) / 2, (f.y + l.y) / 2),\n                E = new A.Point((f.x + u.x) / 2, (f.y + u.y) / 2),\n                k = new A.Point(T.x + v * this.rotatingPointOffset, T.y - p * this.rotatingPointOffset);\n          }\n\n          var P = {\n            tl: c,\n            tr: l,\n            br: f,\n            bl: u\n          };\n          return t || (P.ml = x, P.mt = T, P.mr = O, P.mb = E, P.mtr = k), P;\n        },\n        setCoords: function setCoords(t, e) {\n          return this.oCoords = this.calcCoords(t), e || (this.aCoords = this.calcCoords(!0)), t || this._setCornerCoords && this._setCornerCoords(), this;\n        },\n        _calcRotateMatrix: function _calcRotateMatrix() {\n          if (this.angle) {\n            var t = C(this.angle),\n                e = A.util.cos(t),\n                i = A.util.sin(t);\n            return [e, i, -i, e, 0, 0];\n          }\n\n          return A.iMatrix.concat();\n        },\n        _calcTranslateMatrix: function _calcTranslateMatrix() {\n          var t = this.getCenterPoint();\n          return [1, 0, 0, 1, t.x, t.y];\n        },\n        transformMatrixKey: function transformMatrixKey(t) {\n          var e = \"_\",\n              i = \"\";\n          return !t && this.group && (i = this.group.transformMatrixKey(t) + e), i + this.top + e + this.left + e + this.scaleX + e + this.scaleY + e + this.skewX + e + this.skewY + e + this.angle + e + this.originX + e + this.originY + e + this.width + e + this.height + e + this.strokeWidth + this.flipX + this.flipY;\n        },\n        calcTransformMatrix: function calcTransformMatrix(t) {\n          if (t) return this.calcOwnMatrix();\n          var e = this.transformMatrixKey(),\n              i = this.matrixCache || (this.matrixCache = {});\n          if (i.key === e) return i.value;\n          var r = this.calcOwnMatrix();\n          return this.group && (r = S(this.group.calcTransformMatrix(), r)), i.key = e, i.value = r;\n        },\n        calcOwnMatrix: function calcOwnMatrix() {\n          var t = this.transformMatrixKey(!0),\n              e = this.ownMatrixCache || (this.ownMatrixCache = {});\n          if (e.key === t) return e.value;\n\n          var i,\n              r = this._calcTranslateMatrix(),\n              n = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, !0);\n\n          return this.angle && (i = this._calcRotateMatrix(), r = S(r, i)), r = S(r, n), e.key = t, e.value = r;\n        },\n        _calcDimensionsTransformMatrix: function _calcDimensionsTransformMatrix(t, e, i) {\n          var r,\n              n = [this.scaleX * (i && this.flipX ? -1 : 1), 0, 0, this.scaleY * (i && this.flipY ? -1 : 1), 0, 0];\n          return t && (r = [1, 0, Math.tan(C(t)), 1], n = S(n, r, !0)), e && (r = [1, Math.tan(C(e)), 0, 1], n = S(n, r, !0)), n;\n        },\n        _getNonTransformedDimensions: function _getNonTransformedDimensions() {\n          var t = this.strokeWidth;\n          return {\n            x: this.width + t,\n            y: this.height + t\n          };\n        },\n        _getTransformedDimensions: function _getTransformedDimensions(t, e) {\n          void 0 === t && (t = this.skewX), void 0 === e && (e = this.skewY);\n\n          var i = this._getNonTransformedDimensions();\n\n          if (0 === t && 0 === e) return {\n            x: i.x * this.scaleX,\n            y: i.y * this.scaleY\n          };\n\n          var r,\n              n,\n              o = i.x / 2,\n              s = i.y / 2,\n              a = [{\n            x: -o,\n            y: -s\n          }, {\n            x: o,\n            y: -s\n          }, {\n            x: -o,\n            y: s\n          }, {\n            x: o,\n            y: s\n          }],\n              h = this._calcDimensionsTransformMatrix(t, e, !1);\n\n          for (r = 0; r < a.length; r++) {\n            a[r] = A.util.transformPoint(a[r], h);\n          }\n\n          return {\n            x: (n = A.util.makeBoundingBoxFromPoints(a)).width,\n            y: n.height\n          };\n        },\n        _calculateCurrentDimensions: function _calculateCurrentDimensions() {\n          var t = this.getViewportTransform(),\n              e = this._getTransformedDimensions();\n\n          return A.util.transformPoint(e, t, !0).scalarAdd(2 * this.padding);\n        }\n      }), A.util.object.extend(A.Object.prototype, {\n        sendToBack: function sendToBack() {\n          return this.group ? A.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas.sendToBack(this), this;\n        },\n        bringToFront: function bringToFront() {\n          return this.group ? A.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas.bringToFront(this), this;\n        },\n        sendBackwards: function sendBackwards(t) {\n          return this.group ? A.StaticCanvas.prototype.sendBackwards.call(this.group, this, t) : this.canvas.sendBackwards(this, t), this;\n        },\n        bringForward: function bringForward(t) {\n          return this.group ? A.StaticCanvas.prototype.bringForward.call(this.group, this, t) : this.canvas.bringForward(this, t), this;\n        },\n        moveTo: function moveTo(t) {\n          return this.group && \"activeSelection\" !== this.group.type ? A.StaticCanvas.prototype.moveTo.call(this.group, this, t) : this.canvas.moveTo(this, t), this;\n        }\n      }), function () {\n        function t(t, e) {\n          if (e) {\n            if (e.toLive) return t + \": url(#SVGID_\" + e.id + \"); \";\n            var i = new A.Color(e),\n                r = t + \": \" + i.toRgb() + \"; \",\n                n = i.getAlpha();\n            return 1 !== n && (r += t + \"-opacity: \" + n.toString() + \"; \"), r;\n          }\n\n          return t + \": none; \";\n        }\n\n        var e = A.util.toFixed;\n        A.util.object.extend(A.Object.prototype, {\n          getSvgStyles: function getSvgStyles(e) {\n            var i = this.fillRule ? this.fillRule : \"nonzero\",\n                r = this.strokeWidth ? this.strokeWidth : \"0\",\n                n = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\",\n                o = this.strokeLineCap ? this.strokeLineCap : \"butt\",\n                s = this.strokeLineJoin ? this.strokeLineJoin : \"miter\",\n                a = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\",\n                h = void 0 !== this.opacity ? this.opacity : \"1\",\n                c = this.visible ? \"\" : \" visibility: hidden;\",\n                l = e ? \"\" : this.getSvgFilter(),\n                u = t(\"fill\", this.fill);\n            return [t(\"stroke\", this.stroke), \"stroke-width: \", r, \"; \", \"stroke-dasharray: \", n, \"; \", \"stroke-linecap: \", o, \"; \", \"stroke-linejoin: \", s, \"; \", \"stroke-miterlimit: \", a, \"; \", u, \"fill-rule: \", i, \"; \", \"opacity: \", h, \";\", l, c].join(\"\");\n          },\n          getSvgSpanStyles: function getSvgSpanStyles(e, i) {\n            var r = \"; \",\n                n = e.fontFamily ? \"font-family: \" + (-1 === e.fontFamily.indexOf(\"'\") && -1 === e.fontFamily.indexOf('\"') ? \"'\" + e.fontFamily + \"'\" : e.fontFamily) + r : \"\",\n                o = e.strokeWidth ? \"stroke-width: \" + e.strokeWidth + r : \"\",\n                s = (n = n, e.fontSize ? \"font-size: \" + e.fontSize + \"px\" + r : \"\"),\n                a = e.fontStyle ? \"font-style: \" + e.fontStyle + r : \"\",\n                h = e.fontWeight ? \"font-weight: \" + e.fontWeight + r : \"\",\n                c = e.fill ? t(\"fill\", e.fill) : \"\",\n                l = e.stroke ? t(\"stroke\", e.stroke) : \"\",\n                u = this.getSvgTextDecoration(e);\n            return u && (u = \"text-decoration: \" + u + r), [l, o, n, s, a, h, u, c, e.deltaY ? \"baseline-shift: \" + -e.deltaY + \"; \" : \"\", i ? \"white-space: pre; \" : \"\"].join(\"\");\n          },\n          getSvgTextDecoration: function getSvgTextDecoration(t) {\n            return \"overline\" in t || \"underline\" in t || \"linethrough\" in t ? (t.overline ? \"overline \" : \"\") + (t.underline ? \"underline \" : \"\") + (t.linethrough ? \"line-through \" : \"\") : \"\";\n          },\n          getSvgFilter: function getSvgFilter() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n          },\n          getSvgCommons: function getSvgCommons() {\n            return [this.id ? 'id=\"' + this.id + '\" ' : \"\", this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"].join(\"\");\n          },\n          getSvgTransform: function getSvgTransform(t, i) {\n            return 'transform=\"matrix(' + (t ? this.calcTransformMatrix() : this.calcOwnMatrix()).map(function (t) {\n              return e(t, A.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\" + (i || \"\") + this.getSvgTransformMatrix() + '\" ';\n          },\n          getSvgTransformMatrix: function getSvgTransformMatrix() {\n            return this.transformMatrix ? \" matrix(\" + this.transformMatrix.join(\" \") + \")\" : \"\";\n          },\n          _setSVGBg: function _setSVGBg(t) {\n            if (this.backgroundColor) {\n              var i = A.Object.NUM_FRACTION_DIGITS;\n              t.push(\"\\t\\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', e(-this.width / 2, i), '\" y=\"', e(-this.height / 2, i), '\" width=\"', e(this.width, i), '\" height=\"', e(this.height, i), '\"></rect>\\n');\n            }\n          },\n          toSVG: function toSVG(t) {\n            return this._createBaseSVGMarkup(this._toSVG(), {\n              reviver: t\n            });\n          },\n          toClipPathSVG: function toClipPathSVG(t) {\n            return \"\\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n              reviver: t\n            });\n          },\n          _createBaseClipPathSVGMarkup: function _createBaseClipPathSVGMarkup(t, e) {\n            var i = (e = e || {}).reviver,\n                r = e.additionalTransform || \"\",\n                n = [this.getSvgTransform(!0, r), this.getSvgCommons()].join(\"\");\n            return t[t.indexOf(\"COMMON_PARTS\")] = n, i ? i(t.join(\"\")) : t.join(\"\");\n          },\n          _createBaseSVGMarkup: function _createBaseSVGMarkup(t, e) {\n            var i,\n                r,\n                n = (e = e || {}).noStyle,\n                o = e.withShadow,\n                s = e.reviver,\n                a = n ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ',\n                h = o ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\",\n                c = this.clipPath,\n                l = this.clipPath && this.clipPath.absolutePositioned,\n                u = [],\n                f = t.indexOf(\"COMMON_PARTS\");\n            return c && (c.clipPathId = \"CLIPPATH_\" + A.Object.__uid++, r = '<clipPath id=\"' + c.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(s) + \"</clipPath>\\n\"), l && u.push(\"<g \", h, this.getSvgCommons(), \" >\\n\"), u.push(\"<g \", this.getSvgTransform(!1), l ? \"\" : h + this.getSvgCommons(), \" >\\n\"), i = [a, n ? \"\" : this.addPaintOrder(), \" \"].join(\"\"), t[f] = i, this.fill && this.fill.toLive && u.push(this.fill.toSVG(this, !1)), this.stroke && this.stroke.toLive && u.push(this.stroke.toSVG(this, !1)), this.shadow && u.push(this.shadow.toSVG(this)), c && u.push(r), u.push(t.join(\"\")), u.push(\"</g>\\n\"), l && u.push(\"</g>\\n\"), s ? s(u.join(\"\")) : u.join(\"\");\n          },\n          addPaintOrder: function addPaintOrder() {\n            return \"fill\" !== this.paintFirst ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n          }\n        });\n      }(), function () {\n        var t = A.util.object.extend,\n            e = \"stateProperties\";\n\n        function i(e, i, r) {\n          var n = {};\n          r.forEach(function (t) {\n            n[t] = e[t];\n          }), t(e[i], n, !0);\n        }\n\n        A.util.object.extend(A.Object.prototype, {\n          hasStateChanged: function hasStateChanged(t) {\n            var i = \"_\" + (t = t || e);\n            return Object.keys(this[i]).length < this[t].length || !function t(e, i, r) {\n              if (e === i) return !0;\n\n              if (Array.isArray(e)) {\n                if (!Array.isArray(i) || e.length !== i.length) return !1;\n\n                for (var n = 0, o = e.length; n < o; n++) {\n                  if (!t(e[n], i[n])) return !1;\n                }\n\n                return !0;\n              }\n\n              if (e && \"object\" == typeof e) {\n                var s,\n                    a = Object.keys(e);\n                if (!i || \"object\" != typeof i || !r && a.length !== Object.keys(i).length) return !1;\n\n                for (n = 0, o = a.length; n < o; n++) {\n                  if (!t(e[s = a[n]], i[s])) return !1;\n                }\n\n                return !0;\n              }\n            }(this[i], this, !0);\n          },\n          saveState: function saveState(t) {\n            var r = t && t.propertySet || e,\n                n = \"_\" + r;\n            return this[n] ? (i(this, n, this[r]), t && t.stateProperties && i(this, n, t.stateProperties), this) : this.setupState(t);\n          },\n          setupState: function setupState(t) {\n            var i = (t = t || {}).propertySet || e;\n            return this[\"_\" + (t.propertySet = i)] = {}, this.saveState(t), this;\n          }\n        });\n      }(), T = A.util.degreesToRadians, A.util.object.extend(A.Object.prototype, {\n        _controlsVisibility: null,\n        _findTargetCorner: function _findTargetCorner(t) {\n          if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1;\n          var e,\n              i,\n              r = t.x,\n              n = t.y;\n\n          for (var o in this.__corner = 0, this.oCoords) {\n            if (this.isControlVisible(o) && (\"mtr\" !== o || this.hasRotatingPoint) && (!this.get(\"lockUniScaling\") || \"mt\" !== o && \"mr\" !== o && \"mb\" !== o && \"ml\" !== o) && (i = this._getImageLines(this.oCoords[o].corner), 0 !== (e = this._findCrossPoints({\n              x: r,\n              y: n\n            }, i)) && e % 2 == 1)) return this.__corner = o;\n          }\n\n          return !1;\n        },\n        _setCornerCoords: function _setCornerCoords() {\n          var t,\n              e,\n              i = this.oCoords,\n              r = T(45 - this.angle),\n              n = .707106 * this.cornerSize,\n              o = n * A.util.cos(r),\n              s = n * A.util.sin(r);\n\n          for (var a in i) {\n            t = i[a].x, e = i[a].y, i[a].corner = {\n              tl: {\n                x: t - s,\n                y: e - o\n              },\n              tr: {\n                x: t + o,\n                y: e - s\n              },\n              bl: {\n                x: t - o,\n                y: e + s\n              },\n              br: {\n                x: t + s,\n                y: e + o\n              }\n            };\n          }\n        },\n        drawSelectionBackground: function drawSelectionBackground(t) {\n          if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this;\n          t.save();\n\n          var e = this.getCenterPoint(),\n              i = this._calculateCurrentDimensions(),\n              r = this.canvas.viewportTransform;\n\n          return t.translate(e.x, e.y), t.scale(1 / r[0], 1 / r[3]), t.rotate(T(this.angle)), t.fillStyle = this.selectionBackgroundColor, t.fillRect(-i.x / 2, -i.y / 2, i.x, i.y), t.restore(), this;\n        },\n        drawBorders: function drawBorders(t, e) {\n          e = e || {};\n\n          var i = this._calculateCurrentDimensions(),\n              r = 1 / this.borderScaleFactor,\n              n = i.x + r,\n              o = i.y + r,\n              s = void 0 !== e.hasRotatingPoint ? e.hasRotatingPoint : this.hasRotatingPoint,\n              a = void 0 !== e.hasControls ? e.hasControls : this.hasControls,\n              h = void 0 !== e.rotatingPointOffset ? e.rotatingPointOffset : this.rotatingPointOffset;\n\n          if (t.save(), t.strokeStyle = e.borderColor || this.borderColor, this._setLineDash(t, e.borderDashArray || this.borderDashArray, null), t.strokeRect(-n / 2, -o / 2, n, o), s && this.isControlVisible(\"mtr\") && a) {\n            var c = -o / 2;\n            t.beginPath(), t.moveTo(0, c), t.lineTo(0, c - h), t.stroke();\n          }\n\n          return t.restore(), this;\n        },\n        drawBordersInGroup: function drawBordersInGroup(t, e, i) {\n          i = i || {};\n\n          var r = this._getNonTransformedDimensions(),\n              n = A.util.customTransformMatrix(e.scaleX, e.scaleY, e.skewX),\n              o = A.util.transformPoint(r, n),\n              s = 1 / this.borderScaleFactor,\n              a = o.x + s,\n              h = o.y + s;\n\n          return t.save(), this._setLineDash(t, i.borderDashArray || this.borderDashArray, null), t.strokeStyle = i.borderColor || this.borderColor, t.strokeRect(-a / 2, -h / 2, a, h), t.restore(), this;\n        },\n        drawControls: function drawControls(t, e) {\n          e = e || {};\n\n          var i = this._calculateCurrentDimensions(),\n              r = i.x,\n              n = i.y,\n              o = e.cornerSize || this.cornerSize,\n              s = -(r + o) / 2,\n              a = -(n + o) / 2,\n              h = void 0 !== e.transparentCorners ? e.transparentCorners : this.transparentCorners,\n              c = void 0 !== e.hasRotatingPoint ? e.hasRotatingPoint : this.hasRotatingPoint,\n              l = h ? \"stroke\" : \"fill\";\n\n          return t.save(), t.strokeStyle = t.fillStyle = e.cornerColor || this.cornerColor, this.transparentCorners || (t.strokeStyle = e.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(t, e.cornerDashArray || this.cornerDashArray, null), this._drawControl(\"tl\", t, l, s, a, e), this._drawControl(\"tr\", t, l, s + r, a, e), this._drawControl(\"bl\", t, l, s, a + n, e), this._drawControl(\"br\", t, l, s + r, a + n, e), this.get(\"lockUniScaling\") || (this._drawControl(\"mt\", t, l, s + r / 2, a, e), this._drawControl(\"mb\", t, l, s + r / 2, a + n, e), this._drawControl(\"mr\", t, l, s + r, a + n / 2, e), this._drawControl(\"ml\", t, l, s, a + n / 2, e)), c && this._drawControl(\"mtr\", t, l, s + r / 2, a - this.rotatingPointOffset, e), t.restore(), this;\n        },\n        _drawControl: function _drawControl(t, e, i, r, n, o) {\n          if (o = o || {}, this.isControlVisible(t)) {\n            var s = this.cornerSize,\n                a = !this.transparentCorners && this.cornerStrokeColor;\n\n            switch (o.cornerStyle || this.cornerStyle) {\n              case \"circle\":\n                e.beginPath(), e.arc(r + s / 2, n + s / 2, s / 2, 0, 2 * Math.PI, !1), e[i](), a && e.stroke();\n                break;\n\n              default:\n                this.transparentCorners || e.clearRect(r, n, s, s), e[i + \"Rect\"](r, n, s, s), a && e.strokeRect(r, n, s, s);\n            }\n          }\n        },\n        isControlVisible: function isControlVisible(t) {\n          return this._getControlsVisibility()[t];\n        },\n        setControlVisible: function setControlVisible(t, e) {\n          return this._getControlsVisibility()[t] = e, this;\n        },\n        setControlsVisibility: function setControlsVisibility(t) {\n          for (var e in t || (t = {}), t) {\n            this.setControlVisible(e, t[e]);\n          }\n\n          return this;\n        },\n        _getControlsVisibility: function _getControlsVisibility() {\n          return this._controlsVisibility || (this._controlsVisibility = {\n            tl: !0,\n            tr: !0,\n            br: !0,\n            bl: !0,\n            ml: !0,\n            mt: !0,\n            mr: !0,\n            mb: !0,\n            mtr: !0\n          }), this._controlsVisibility;\n        },\n        onDeselect: function onDeselect() {},\n        onSelect: function onSelect() {}\n      }), A.util.object.extend(A.StaticCanvas.prototype, {\n        FX_DURATION: 500,\n        fxCenterObjectH: function fxCenterObjectH(t, e) {\n          var i = function i() {},\n              r = (e = e || {}).onComplete || i,\n              n = e.onChange || i,\n              o = this;\n\n          return A.util.animate({\n            startValue: t.left,\n            endValue: this.getCenter().left,\n            duration: this.FX_DURATION,\n            onChange: function onChange(e) {\n              t.set(\"left\", e), o.requestRenderAll(), n();\n            },\n            onComplete: function onComplete() {\n              t.setCoords(), r();\n            }\n          }), this;\n        },\n        fxCenterObjectV: function fxCenterObjectV(t, e) {\n          var i = function i() {},\n              r = (e = e || {}).onComplete || i,\n              n = e.onChange || i,\n              o = this;\n\n          return A.util.animate({\n            startValue: t.top,\n            endValue: this.getCenter().top,\n            duration: this.FX_DURATION,\n            onChange: function onChange(e) {\n              t.set(\"top\", e), o.requestRenderAll(), n();\n            },\n            onComplete: function onComplete() {\n              t.setCoords(), r();\n            }\n          }), this;\n        },\n        fxRemove: function fxRemove(t, e) {\n          var i = function i() {},\n              r = (e = e || {}).onComplete || i,\n              n = e.onChange || i,\n              o = this;\n\n          return A.util.animate({\n            startValue: t.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function onChange(e) {\n              t.set(\"opacity\", e), o.requestRenderAll(), n();\n            },\n            onComplete: function onComplete() {\n              o.remove(t), r();\n            }\n          }), this;\n        }\n      }), A.util.object.extend(A.Object.prototype, {\n        animate: function animate() {\n          if (arguments[0] && \"object\" == typeof arguments[0]) {\n            var t,\n                e,\n                i = [];\n\n            for (t in arguments[0]) {\n              i.push(t);\n            }\n\n            for (var r = 0, n = i.length; r < n; r++) {\n              t = i[r], e = r !== n - 1, this._animate(t, arguments[0][t], arguments[1], e);\n            }\n          } else this._animate.apply(this, arguments);\n\n          return this;\n        },\n        _animate: function _animate(t, e, i, r) {\n          var n,\n              o = this;\n          e = e.toString(), i = i ? A.util.object.clone(i) : {}, ~t.indexOf(\".\") && (n = t.split(\".\"));\n          var s = n ? this.get(n[0])[n[1]] : this.get(t);\n          \"from\" in i || (i.from = s), e = ~e.indexOf(\"=\") ? s + parseFloat(e.replace(\"=\", \"\")) : parseFloat(e), A.util.animate({\n            startValue: i.from,\n            endValue: e,\n            byValue: i.by,\n            easing: i.easing,\n            duration: i.duration,\n            abort: i.abort && function () {\n              return i.abort.call(o);\n            },\n            onChange: function onChange(e, s, a) {\n              n ? o[n[0]][n[1]] = e : o.set(t, e), r || i.onChange && i.onChange(e, s, a);\n            },\n            onComplete: function onComplete(t, e, n) {\n              r || (o.setCoords(), i.onComplete && i.onComplete(t, e, n));\n            }\n          });\n        }\n      }), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.util.object.clone,\n            n = {\n          x1: 1,\n          x2: 1,\n          y1: 1,\n          y2: 1\n        },\n            o = e.StaticCanvas.supports(\"setLineDash\");\n\n        function s(t, e) {\n          var i = t.origin,\n              r = t.axis1,\n              n = t.axis2,\n              o = t.dimension,\n              s = e.nearest,\n              a = e.center,\n              h = e.farthest;\n          return function () {\n            switch (this.get(i)) {\n              case s:\n                return Math.min(this.get(r), this.get(n));\n\n              case a:\n                return Math.min(this.get(r), this.get(n)) + .5 * this.get(o);\n\n              case h:\n                return Math.max(this.get(r), this.get(n));\n            }\n          };\n        }\n\n        e.Line ? e.warn(\"fabric.Line is already defined\") : (e.Line = e.util.createClass(e.Object, {\n          type: \"line\",\n          x1: 0,\n          y1: 0,\n          x2: 0,\n          y2: 0,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n          initialize: function initialize(t, e) {\n            t || (t = [0, 0, 0, 0]), this.callSuper(\"initialize\", e), this.set(\"x1\", t[0]), this.set(\"y1\", t[1]), this.set(\"x2\", t[2]), this.set(\"y2\", t[3]), this._setWidthHeight(e);\n          },\n          _setWidthHeight: function _setWidthHeight(t) {\n            t || (t = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = \"left\" in t ? t.left : this._getLeftToOriginX(), this.top = \"top\" in t ? t.top : this._getTopToOriginY();\n          },\n          _set: function _set(t, e) {\n            return this.callSuper(\"_set\", t, e), void 0 !== n[t] && this._setWidthHeight(), this;\n          },\n          _getLeftToOriginX: s({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n          }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n          }),\n          _getTopToOriginY: s({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n          }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n          }),\n          _render: function _render(t) {\n            if (t.beginPath(), !this.strokeDashArray || this.strokeDashArray && o) {\n              var e = this.calcLinePoints();\n              t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2);\n            }\n\n            t.lineWidth = this.strokeWidth;\n            var i = t.strokeStyle;\n            t.strokeStyle = this.stroke || t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = i;\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            var i = this.calcLinePoints();\n            t.beginPath(), e.util.drawDashedLine(t, i.x1, i.y1, i.x2, i.y2, this.strokeDashArray), t.closePath();\n          },\n          _findCenterFromElement: function _findCenterFromElement() {\n            return {\n              x: (this.x1 + this.x2) / 2,\n              y: (this.y1 + this.y2) / 2\n            };\n          },\n          toObject: function toObject(t) {\n            return i(this.callSuper(\"toObject\", t), this.calcLinePoints());\n          },\n          _getNonTransformedDimensions: function _getNonTransformedDimensions() {\n            var t = this.callSuper(\"_getNonTransformedDimensions\");\n            return \"butt\" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t;\n          },\n          calcLinePoints: function calcLinePoints() {\n            var t = this.x1 <= this.x2 ? -1 : 1,\n                e = this.y1 <= this.y2 ? -1 : 1,\n                i = t * this.width * .5,\n                r = e * this.height * .5;\n            return {\n              x1: i,\n              x2: t * this.width * -.5,\n              y1: r,\n              y2: e * this.height * -.5\n            };\n          },\n          _toSVG: function _toSVG() {\n            var t = this.calcLinePoints();\n            return [\"<line \", \"COMMON_PARTS\", 'x1=\"', t.x1, '\" y1=\"', t.y1, '\" x2=\"', t.x2, '\" y2=\"', t.y2, '\" />\\n'];\n          }\n        }), e.Line.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \")), e.Line.fromElement = function (t, r, n) {\n          n = n || {};\n          var o = e.parseAttributes(t, e.Line.ATTRIBUTE_NAMES),\n              s = [o.x1 || 0, o.y1 || 0, o.x2 || 0, o.y2 || 0];\n          r(new e.Line(s, i(o, n)));\n        }, e.Line.fromObject = function (t, i) {\n          var n = r(t, !0);\n          n.points = [t.x1, t.y1, t.x2, t.y2], e.Object._fromObject(\"Line\", n, function (t) {\n            delete t.points, i && i(t);\n          }, \"points\");\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = Math.PI;\n        e.Circle ? e.warn(\"fabric.Circle is already defined.\") : (e.Circle = e.util.createClass(e.Object, {\n          type: \"circle\",\n          radius: 0,\n          startAngle: 0,\n          endAngle: 2 * i,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n          _set: function _set(t, e) {\n            return this.callSuper(\"_set\", t, e), \"radius\" === t && this.setRadius(e), this;\n          },\n          toObject: function toObject(t) {\n            return this.callSuper(\"toObject\", [\"radius\", \"startAngle\", \"endAngle\"].concat(t));\n          },\n          _toSVG: function _toSVG() {\n            var t,\n                r = (this.endAngle - this.startAngle) % (2 * i);\n            if (0 === r) t = [\"<circle \", \"COMMON_PARTS\", 'cx=\"0\" cy=\"0\" ', 'r=\"', this.radius, '\" />\\n'];else {\n              var n = e.util.cos(this.startAngle) * this.radius,\n                  o = e.util.sin(this.startAngle) * this.radius,\n                  s = e.util.cos(this.endAngle) * this.radius,\n                  a = e.util.sin(this.endAngle) * this.radius,\n                  h = i < r ? \"1\" : \"0\";\n              t = ['<path d=\"M ' + n + \" \" + o, \" A \" + this.radius + \" \" + this.radius, \" 0 \", +h + \" 1\", \" \" + s + \" \" + a, '\"', \"COMMON_PARTS\", \" />\\n\"];\n            }\n            return t;\n          },\n          _render: function _render(t) {\n            t.beginPath(), t.arc(0, 0, this.radius, this.startAngle, this.endAngle, !1), this._renderPaintInOrder(t);\n          },\n          getRadiusX: function getRadiusX() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n          },\n          getRadiusY: function getRadiusY() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n          },\n          setRadius: function setRadius(t) {\n            return this.radius = t, this.set(\"width\", 2 * t).set(\"height\", 2 * t);\n          }\n        }), e.Circle.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \")), e.Circle.fromElement = function (t, i) {\n          var r,\n              n = e.parseAttributes(t, e.Circle.ATTRIBUTE_NAMES);\n          if (!(\"radius\" in (r = n) && 0 <= r.radius)) throw new Error(\"value of `r` attribute is required and can not be negative\");\n          n.left = (n.left || 0) - n.radius, n.top = (n.top || 0) - n.radius, i(new e.Circle(n));\n        }, e.Circle.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Circle\", t, i);\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n        e.Triangle ? e.warn(\"fabric.Triangle is already defined\") : (e.Triangle = e.util.createClass(e.Object, {\n          type: \"triangle\",\n          width: 100,\n          height: 100,\n          _render: function _render(t) {\n            var e = this.width / 2,\n                i = this.height / 2;\n            t.beginPath(), t.moveTo(-e, i), t.lineTo(0, -i), t.lineTo(e, i), t.closePath(), this._renderPaintInOrder(t);\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            var i = this.width / 2,\n                r = this.height / 2;\n            t.beginPath(), e.util.drawDashedLine(t, -i, r, 0, -r, this.strokeDashArray), e.util.drawDashedLine(t, 0, -r, i, r, this.strokeDashArray), e.util.drawDashedLine(t, i, r, -i, r, this.strokeDashArray), t.closePath();\n          },\n          _toSVG: function _toSVG() {\n            var t = this.width / 2,\n                e = this.height / 2;\n            return [\"<polygon \", \"COMMON_PARTS\", 'points=\"', [-t + \" \" + e, \"0 \" + -e, t + \" \" + e].join(\",\"), '\" />'];\n          }\n        }), e.Triangle.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Triangle\", t, i);\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = 2 * Math.PI;\n        e.Ellipse ? e.warn(\"fabric.Ellipse is already defined.\") : (e.Ellipse = e.util.createClass(e.Object, {\n          type: \"ellipse\",\n          rx: 0,\n          ry: 0,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n          initialize: function initialize(t) {\n            this.callSuper(\"initialize\", t), this.set(\"rx\", t && t.rx || 0), this.set(\"ry\", t && t.ry || 0);\n          },\n          _set: function _set(t, e) {\n            switch (this.callSuper(\"_set\", t, e), t) {\n              case \"rx\":\n                this.rx = e, this.set(\"width\", 2 * e);\n                break;\n\n              case \"ry\":\n                this.ry = e, this.set(\"height\", 2 * e);\n            }\n\n            return this;\n          },\n          getRx: function getRx() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n          },\n          getRy: function getRy() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n          },\n          toObject: function toObject(t) {\n            return this.callSuper(\"toObject\", [\"rx\", \"ry\"].concat(t));\n          },\n          _toSVG: function _toSVG() {\n            return [\"<ellipse \", \"COMMON_PARTS\", 'cx=\"0\" cy=\"0\" ', 'rx=\"', this.rx, '\" ry=\"', this.ry, '\" />\\n'];\n          },\n          _render: function _render(t) {\n            t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, i, !1), t.restore(), this._renderPaintInOrder(t);\n          }\n        }), e.Ellipse.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \")), e.Ellipse.fromElement = function (t, i) {\n          var r = e.parseAttributes(t, e.Ellipse.ATTRIBUTE_NAMES);\n          r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, i(new e.Ellipse(r));\n        }, e.Ellipse.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Ellipse\", t, i);\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend;\n        e.Rect ? e.warn(\"fabric.Rect is already defined\") : (e.Rect = e.util.createClass(e.Object, {\n          stateProperties: e.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n          type: \"rect\",\n          rx: 0,\n          ry: 0,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n          initialize: function initialize(t) {\n            this.callSuper(\"initialize\", t), this._initRxRy();\n          },\n          _initRxRy: function _initRxRy() {\n            this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry);\n          },\n          _render: function _render(t) {\n            var e = this.rx ? Math.min(this.rx, this.width / 2) : 0,\n                i = this.ry ? Math.min(this.ry, this.height / 2) : 0,\n                r = this.width,\n                n = this.height,\n                o = -this.width / 2,\n                s = -this.height / 2,\n                a = 0 !== e || 0 !== i,\n                h = .4477152502;\n            t.beginPath(), t.moveTo(o + e, s), t.lineTo(o + r - e, s), a && t.bezierCurveTo(o + r - h * e, s, o + r, s + h * i, o + r, s + i), t.lineTo(o + r, s + n - i), a && t.bezierCurveTo(o + r, s + n - h * i, o + r - h * e, s + n, o + r - e, s + n), t.lineTo(o + e, s + n), a && t.bezierCurveTo(o + h * e, s + n, o, s + n - h * i, o, s + n - i), t.lineTo(o, s + i), a && t.bezierCurveTo(o, s + h * i, o + h * e, s, o + e, s), t.closePath(), this._renderPaintInOrder(t);\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            var i = -this.width / 2,\n                r = -this.height / 2,\n                n = this.width,\n                o = this.height;\n            t.beginPath(), e.util.drawDashedLine(t, i, r, i + n, r, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r, i + n, r + o, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r + o, i, r + o, this.strokeDashArray), e.util.drawDashedLine(t, i, r + o, i, r, this.strokeDashArray), t.closePath();\n          },\n          toObject: function toObject(t) {\n            return this.callSuper(\"toObject\", [\"rx\", \"ry\"].concat(t));\n          },\n          _toSVG: function _toSVG() {\n            return [\"<rect \", \"COMMON_PARTS\", 'x=\"', -this.width / 2, '\" y=\"', -this.height / 2, '\" rx=\"', this.rx, '\" ry=\"', this.ry, '\" width=\"', this.width, '\" height=\"', this.height, '\" />\\n'];\n          }\n        }), e.Rect.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \")), e.Rect.fromElement = function (t, r, n) {\n          if (!t) return r(null);\n          n = n || {};\n          var o = e.parseAttributes(t, e.Rect.ATTRIBUTE_NAMES);\n          o.left = o.left || 0, o.top = o.top || 0;\n          var s = new e.Rect(i(n ? e.util.object.clone(n) : {}, o));\n          s.visible = s.visible && 0 < s.width && 0 < s.height, r(s);\n        }, e.Rect.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Rect\", t, i);\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.util.array.min,\n            n = e.util.array.max,\n            o = e.util.toFixed;\n        e.Polyline ? e.warn(\"fabric.Polyline is already defined\") : (e.Polyline = e.util.createClass(e.Object, {\n          type: \"polyline\",\n          points: null,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"points\"),\n          initialize: function initialize(t, e) {\n            e = e || {}, this.points = t || [], this.callSuper(\"initialize\", e);\n\n            var i = this._calcDimensions();\n\n            void 0 === e.left && (this.left = i.left), void 0 === e.top && (this.top = i.top), this.width = i.width, this.height = i.height, this.pathOffset = {\n              x: i.left + this.width / 2,\n              y: i.top + this.height / 2\n            };\n          },\n          _calcDimensions: function _calcDimensions() {\n            var t = this.points,\n                e = r(t, \"x\") || 0,\n                i = r(t, \"y\") || 0;\n            return {\n              left: e,\n              top: i,\n              width: (n(t, \"x\") || 0) - e,\n              height: (n(t, \"y\") || 0) - i\n            };\n          },\n          toObject: function toObject(t) {\n            return i(this.callSuper(\"toObject\", t), {\n              points: this.points.concat()\n            });\n          },\n          _toSVG: function _toSVG() {\n            for (var t = [], i = this.pathOffset.x, r = this.pathOffset.y, n = e.Object.NUM_FRACTION_DIGITS, s = 0, a = this.points.length; s < a; s++) {\n              t.push(o(this.points[s].x - i, n), \",\", o(this.points[s].y - r, n), \" \");\n            }\n\n            return [\"<\" + this.type + \" \", \"COMMON_PARTS\", 'points=\"', t.join(\"\"), '\" />\\n'];\n          },\n          commonRender: function commonRender(t) {\n            var e,\n                i = this.points.length,\n                r = this.pathOffset.x,\n                n = this.pathOffset.y;\n            if (!i || isNaN(this.points[i - 1].y)) return !1;\n            t.beginPath(), t.moveTo(this.points[0].x - r, this.points[0].y - n);\n\n            for (var o = 0; o < i; o++) {\n              e = this.points[o], t.lineTo(e.x - r, e.y - n);\n            }\n\n            return !0;\n          },\n          _render: function _render(t) {\n            this.commonRender(t) && this._renderPaintInOrder(t);\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            var i, r;\n            t.beginPath();\n\n            for (var n = 0, o = this.points.length; n < o; n++) {\n              i = this.points[n], r = this.points[n + 1] || i, e.util.drawDashedLine(t, i.x, i.y, r.x, r.y, this.strokeDashArray);\n            }\n          },\n          complexity: function complexity() {\n            return this.get(\"points\").length;\n          }\n        }), e.Polyline.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polyline.fromElement = function (t, i, r) {\n          if (!t) return i(null);\n          r || (r = {});\n          var n = e.parsePointsAttribute(t.getAttribute(\"points\")),\n              o = e.parseAttributes(t, e.Polyline.ATTRIBUTE_NAMES);\n          i(new e.Polyline(n, e.util.object.extend(o, r)));\n        }, e.Polyline.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Polyline\", t, i, \"points\");\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend;\n        e.Polygon ? e.warn(\"fabric.Polygon is already defined\") : (e.Polygon = e.util.createClass(e.Polyline, {\n          type: \"polygon\",\n          _render: function _render(t) {\n            this.commonRender(t) && (t.closePath(), this._renderPaintInOrder(t));\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            this.callSuper(\"_renderDashedStroke\", t), t.closePath();\n          }\n        }), e.Polygon.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polygon.fromElement = function (t, r, n) {\n          if (!t) return r(null);\n          n || (n = {});\n          var o = e.parsePointsAttribute(t.getAttribute(\"points\")),\n              s = e.parseAttributes(t, e.Polygon.ATTRIBUTE_NAMES);\n          r(new e.Polygon(o, i(s, n)));\n        }, e.Polygon.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Polygon\", t, i, \"points\");\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.array.min,\n            r = e.util.array.max,\n            n = e.util.object.extend,\n            o = Object.prototype.toString,\n            s = e.util.drawArc,\n            a = e.util.toFixed,\n            h = {\n          m: 2,\n          l: 2,\n          h: 1,\n          v: 1,\n          c: 6,\n          s: 4,\n          q: 4,\n          t: 2,\n          a: 7\n        },\n            c = {\n          m: \"l\",\n          M: \"L\"\n        };\n        e.Path ? e.warn(\"fabric.Path is already defined\") : (e.Path = e.util.createClass(e.Object, {\n          type: \"path\",\n          path: null,\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n          stateProperties: e.Object.prototype.stateProperties.concat(\"path\"),\n          initialize: function initialize(t, e) {\n            e = e || {}, this.callSuper(\"initialize\", e), t || (t = []);\n            var i = \"[object Array]\" === o.call(t);\n            this.path = i ? t : t.match && t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi), this.path && (i || (this.path = this._parsePath()), this._setPositionDimensions(e));\n          },\n          _setPositionDimensions: function _setPositionDimensions(t) {\n            var e = this._parseDimensions();\n\n            this.width = e.width, this.height = e.height, void 0 === t.left && (this.left = e.left), void 0 === t.top && (this.top = e.top), this.pathOffset = this.pathOffset || {\n              x: e.left + this.width / 2,\n              y: e.top + this.height / 2\n            };\n          },\n          _renderPathCommands: function _renderPathCommands(t) {\n            var e,\n                i,\n                r,\n                n = null,\n                o = 0,\n                a = 0,\n                h = 0,\n                c = 0,\n                l = 0,\n                u = 0,\n                f = -this.pathOffset.x,\n                d = -this.pathOffset.y;\n            t.beginPath();\n\n            for (var g = 0, p = this.path.length; g < p; ++g) {\n              switch ((e = this.path[g])[0]) {\n                case \"l\":\n                  h += e[1], c += e[2], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"L\":\n                  h = e[1], c = e[2], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"h\":\n                  h += e[1], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"H\":\n                  h = e[1], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"v\":\n                  c += e[1], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"V\":\n                  c = e[1], t.lineTo(h + f, c + d);\n                  break;\n\n                case \"m\":\n                  o = h += e[1], a = c += e[2], t.moveTo(h + f, c + d);\n                  break;\n\n                case \"M\":\n                  o = h = e[1], a = c = e[2], t.moveTo(h + f, c + d);\n                  break;\n\n                case \"c\":\n                  i = h + e[5], r = c + e[6], l = h + e[3], u = c + e[4], t.bezierCurveTo(h + e[1] + f, c + e[2] + d, l + f, u + d, i + f, r + d), h = i, c = r;\n                  break;\n\n                case \"C\":\n                  h = e[5], c = e[6], l = e[3], u = e[4], t.bezierCurveTo(e[1] + f, e[2] + d, l + f, u + d, h + f, c + d);\n                  break;\n\n                case \"s\":\n                  i = h + e[3], r = c + e[4], u = null === n[0].match(/[CcSs]/) ? (l = h, c) : (l = 2 * h - l, 2 * c - u), t.bezierCurveTo(l + f, u + d, h + e[1] + f, c + e[2] + d, i + f, r + d), l = h + e[1], u = c + e[2], h = i, c = r;\n                  break;\n\n                case \"S\":\n                  i = e[3], r = e[4], u = null === n[0].match(/[CcSs]/) ? (l = h, c) : (l = 2 * h - l, 2 * c - u), t.bezierCurveTo(l + f, u + d, e[1] + f, e[2] + d, i + f, r + d), h = i, c = r, l = e[1], u = e[2];\n                  break;\n\n                case \"q\":\n                  i = h + e[3], r = c + e[4], l = h + e[1], u = c + e[2], t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r;\n                  break;\n\n                case \"Q\":\n                  i = e[3], r = e[4], t.quadraticCurveTo(e[1] + f, e[2] + d, i + f, r + d), h = i, c = r, l = e[1], u = e[2];\n                  break;\n\n                case \"t\":\n                  i = h + e[1], r = c + e[2], u = null === n[0].match(/[QqTt]/) ? (l = h, c) : (l = 2 * h - l, 2 * c - u), t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r;\n                  break;\n\n                case \"T\":\n                  i = e[1], r = e[2], u = null === n[0].match(/[QqTt]/) ? (l = h, c) : (l = 2 * h - l, 2 * c - u), t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r;\n                  break;\n\n                case \"a\":\n                  s(t, h + f, c + d, [e[1], e[2], e[3], e[4], e[5], e[6] + h + f, e[7] + c + d]), h += e[6], c += e[7];\n                  break;\n\n                case \"A\":\n                  s(t, h + f, c + d, [e[1], e[2], e[3], e[4], e[5], e[6] + f, e[7] + d]), h = e[6], c = e[7];\n                  break;\n\n                case \"z\":\n                case \"Z\":\n                  h = o, c = a, t.closePath();\n              }\n\n              n = e;\n            }\n          },\n          _render: function _render(t) {\n            this._renderPathCommands(t), this._renderPaintInOrder(t);\n          },\n          toString: function toString() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n          },\n          toObject: function toObject(t) {\n            return n(this.callSuper(\"toObject\", t), {\n              path: this.path.map(function (t) {\n                return t.slice();\n              }),\n              top: this.top,\n              left: this.left\n            });\n          },\n          toDatalessObject: function toDatalessObject(t) {\n            var e = this.toObject([\"sourcePath\"].concat(t));\n            return e.sourcePath && delete e.path, e;\n          },\n          _toSVG: function _toSVG() {\n            var t = this._getOffsetTransform();\n\n            return [\"<path \", \"COMMON_PARTS\", 'd=\"', this.path.map(function (t) {\n              return t.join(\" \");\n            }).join(\" \"), '\" stroke-linecap=\"round\" ', 'transform=\"' + t + '\" ', \"/>\\n\"];\n          },\n          _getOffsetTransform: function _getOffsetTransform() {\n            var t = e.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + a(-this.pathOffset.x, t) + \", \" + a(-this.pathOffset.y, t) + \")\";\n          },\n          toClipPathSVG: function toClipPathSVG(t) {\n            var e = this._getOffsetTransform();\n\n            return \"\\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n              reviver: t,\n              additionalTransform: e\n            });\n          },\n          complexity: function complexity() {\n            return this.path.length;\n          },\n          _parsePath: function _parsePath() {\n            for (var t, e, i, r, n, o = [], s = [], a = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/gi, l = 0, u = this.path.length; l < u; l++) {\n              for (r = (t = this.path[l]).slice(1).trim(), s.length = 0; i = a.exec(r);) {\n                s.push(i[0]);\n              }\n\n              n = [t.charAt(0)];\n\n              for (var f = 0, d = s.length; f < d; f++) {\n                e = parseFloat(s[f]), isNaN(e) || n.push(e);\n              }\n\n              var g = n[0],\n                  p = h[g.toLowerCase()],\n                  v = c[g] || g;\n              if (n.length - 1 > p) for (var m = 1, y = n.length; m < y; m += p) {\n                o.push([g].concat(n.slice(m, m + p))), g = v;\n              } else o.push(n);\n            }\n\n            return o;\n          },\n          _parseDimensions: function _parseDimensions() {\n            for (var t, n, o, s, a = [], h = [], c = null, l = 0, u = 0, f = 0, d = 0, g = 0, p = 0, v = 0, m = this.path.length; v < m; ++v) {\n              switch ((t = this.path[v])[0]) {\n                case \"l\":\n                  f += t[1], d += t[2], s = [];\n                  break;\n\n                case \"L\":\n                  f = t[1], d = t[2], s = [];\n                  break;\n\n                case \"h\":\n                  f += t[1], s = [];\n                  break;\n\n                case \"H\":\n                  f = t[1], s = [];\n                  break;\n\n                case \"v\":\n                  d += t[1], s = [];\n                  break;\n\n                case \"V\":\n                  d = t[1], s = [];\n                  break;\n\n                case \"m\":\n                  l = f += t[1], u = d += t[2], s = [];\n                  break;\n\n                case \"M\":\n                  l = f = t[1], u = d = t[2], s = [];\n                  break;\n\n                case \"c\":\n                  n = f + t[5], o = d + t[6], g = f + t[3], p = d + t[4], s = e.util.getBoundsOfCurve(f, d, f + t[1], d + t[2], g, p, n, o), f = n, d = o;\n                  break;\n\n                case \"C\":\n                  g = t[3], p = t[4], s = e.util.getBoundsOfCurve(f, d, t[1], t[2], g, p, t[5], t[6]), f = t[5], d = t[6];\n                  break;\n\n                case \"s\":\n                  n = f + t[3], o = d + t[4], p = null === c[0].match(/[CcSs]/) ? (g = f, d) : (g = 2 * f - g, 2 * d - p), s = e.util.getBoundsOfCurve(f, d, g, p, f + t[1], d + t[2], n, o), g = f + t[1], p = d + t[2], f = n, d = o;\n                  break;\n\n                case \"S\":\n                  n = t[3], o = t[4], p = null === c[0].match(/[CcSs]/) ? (g = f, d) : (g = 2 * f - g, 2 * d - p), s = e.util.getBoundsOfCurve(f, d, g, p, t[1], t[2], n, o), f = n, d = o, g = t[1], p = t[2];\n                  break;\n\n                case \"q\":\n                  n = f + t[3], o = d + t[4], g = f + t[1], p = d + t[2], s = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, o), f = n, d = o;\n                  break;\n\n                case \"Q\":\n                  g = t[1], p = t[2], s = e.util.getBoundsOfCurve(f, d, g, p, g, p, t[3], t[4]), f = t[3], d = t[4];\n                  break;\n\n                case \"t\":\n                  n = f + t[1], o = d + t[2], p = null === c[0].match(/[QqTt]/) ? (g = f, d) : (g = 2 * f - g, 2 * d - p), s = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, o), f = n, d = o;\n                  break;\n\n                case \"T\":\n                  n = t[1], o = t[2], p = null === c[0].match(/[QqTt]/) ? (g = f, d) : (g = 2 * f - g, 2 * d - p), s = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, o), f = n, d = o;\n                  break;\n\n                case \"a\":\n                  s = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6] + f, t[7] + d), f += t[6], d += t[7];\n                  break;\n\n                case \"A\":\n                  s = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6], t[7]), f = t[6], d = t[7];\n                  break;\n\n                case \"z\":\n                case \"Z\":\n                  f = l, d = u;\n              }\n\n              c = t, s.forEach(function (t) {\n                a.push(t.x), h.push(t.y);\n              }), a.push(f), h.push(d);\n            }\n\n            var y = i(a) || 0,\n                _ = i(h) || 0;\n\n            return {\n              left: y,\n              top: _,\n              width: (r(a) || 0) - y,\n              height: (r(h) || 0) - _\n            };\n          }\n        }), e.Path.fromObject = function (t, i) {\n          if (\"string\" == typeof t.sourcePath) {\n            var r = t.sourcePath;\n            e.loadSVGFromURL(r, function (e) {\n              var r = e[0];\n              r.setOptions(t), i && i(r);\n            });\n          } else e.Object._fromObject(\"Path\", t, i, \"path\");\n        }, e.Path.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat([\"d\"]), e.Path.fromElement = function (t, i, r) {\n          var o = e.parseAttributes(t, e.Path.ATTRIBUTE_NAMES);\n          i(new e.Path(o.d, n(o, r)));\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.array.min,\n            r = e.util.array.max;\n        e.Group || (e.Group = e.util.createClass(e.Object, e.Collection, {\n          type: \"group\",\n          strokeWidth: 0,\n          subTargetCheck: !1,\n          cacheProperties: [],\n          useSetOnGroup: !1,\n          initialize: function initialize(t, e, i) {\n            e = e || {}, this._objects = [], i && this.callSuper(\"initialize\", e), this._objects = t || [];\n\n            for (var r = this._objects.length; r--;) {\n              this._objects[r].group = this;\n            }\n\n            if (i) this._updateObjectsACoords();else {\n              var n = e && e.centerPoint;\n              void 0 !== e.originX && (this.originX = e.originX), void 0 !== e.originY && (this.originY = e.originY), n || this._calcBounds(), this._updateObjectsCoords(n), delete e.centerPoint, this.callSuper(\"initialize\", e);\n            }\n            this.setCoords();\n          },\n          _updateObjectsACoords: function _updateObjectsACoords() {\n            for (var t = this._objects.length; t--;) {\n              this._objects[t].setCoords(!0, !0);\n            }\n          },\n          _updateObjectsCoords: function _updateObjectsCoords(t) {\n            t = t || this.getCenterPoint();\n\n            for (var e = this._objects.length; e--;) {\n              this._updateObjectCoords(this._objects[e], t);\n            }\n          },\n          _updateObjectCoords: function _updateObjectCoords(t, e) {\n            var i = t.left,\n                r = t.top;\n            t.set({\n              left: i - e.x,\n              top: r - e.y\n            }), t.group = this, t.setCoords(!0, !0);\n          },\n          toString: function toString() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n          },\n          addWithUpdate: function addWithUpdate(t) {\n            return this._restoreObjectsState(), e.util.resetObjectTransform(this), t && (this._objects.push(t), t.group = this, t._set(\"canvas\", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this;\n          },\n          removeWithUpdate: function removeWithUpdate(t) {\n            return this._restoreObjectsState(), e.util.resetObjectTransform(this), this.remove(t), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this;\n          },\n          _onObjectAdded: function _onObjectAdded(t) {\n            this.dirty = !0, t.group = this, t._set(\"canvas\", this.canvas);\n          },\n          _onObjectRemoved: function _onObjectRemoved(t) {\n            this.dirty = !0, delete t.group;\n          },\n          _set: function _set(t, i) {\n            var r = this._objects.length;\n            if (this.useSetOnGroup) for (; r--;) {\n              this._objects[r].setOnGroup(t, i);\n            }\n            if (\"canvas\" === t) for (; r--;) {\n              this._objects[r]._set(t, i);\n            }\n\n            e.Object.prototype._set.call(this, t, i);\n          },\n          toObject: function toObject(t) {\n            var i = this.includeDefaultValues,\n                r = this._objects.map(function (e) {\n              var r = e.includeDefaultValues;\n              e.includeDefaultValues = i;\n              var n = e.toObject(t);\n              return e.includeDefaultValues = r, n;\n            }),\n                n = e.Object.prototype.toObject.call(this, t);\n\n            return n.objects = r, n;\n          },\n          toDatalessObject: function toDatalessObject(t) {\n            var i,\n                r = this.sourcePath;\n            if (r) i = r;else {\n              var n = this.includeDefaultValues;\n              i = this._objects.map(function (e) {\n                var i = e.includeDefaultValues;\n                e.includeDefaultValues = n;\n                var r = e.toDatalessObject(t);\n                return e.includeDefaultValues = i, r;\n              });\n            }\n            var o = e.Object.prototype.toDatalessObject.call(this, t);\n            return o.objects = i, o;\n          },\n          render: function render(t) {\n            this._transformDone = !0, this.callSuper(\"render\", t), this._transformDone = !1;\n          },\n          shouldCache: function shouldCache() {\n            var t = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());\n            if (this.ownCaching = t) for (var e = 0, i = this._objects.length; e < i; e++) {\n              if (this._objects[e].willDrawShadow()) return this.ownCaching = !1;\n            }\n            return t;\n          },\n          willDrawShadow: function willDrawShadow() {\n            if (this.shadow) return e.Object.prototype.willDrawShadow.call(this);\n\n            for (var t = 0, i = this._objects.length; t < i; t++) {\n              if (this._objects[t].willDrawShadow()) return !0;\n            }\n\n            return !1;\n          },\n          isOnACache: function isOnACache() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n          },\n          drawObject: function drawObject(t) {\n            for (var e = 0, i = this._objects.length; e < i; e++) {\n              this._objects[e].render(t);\n            }\n\n            this._drawClipPath(t);\n          },\n          isCacheDirty: function isCacheDirty(t) {\n            if (this.callSuper(\"isCacheDirty\", t)) return !0;\n            if (!this.statefullCache) return !1;\n\n            for (var e = 0, i = this._objects.length; e < i; e++) {\n              if (this._objects[e].isCacheDirty(!0)) {\n                if (this._cacheCanvas) {\n                  var r = this.cacheWidth / this.zoomX,\n                      n = this.cacheHeight / this.zoomY;\n\n                  this._cacheContext.clearRect(-r / 2, -n / 2, r, n);\n                }\n\n                return !0;\n              }\n            }\n\n            return !1;\n          },\n          _restoreObjectsState: function _restoreObjectsState() {\n            return this._objects.forEach(this._restoreObjectState, this), this;\n          },\n          realizeTransform: function realizeTransform(t) {\n            var i = t.calcTransformMatrix(),\n                r = e.util.qrDecompose(i),\n                n = new e.Point(r.translateX, r.translateY);\n            return t.flipX = !1, t.flipY = !1, t.set(\"scaleX\", r.scaleX), t.set(\"scaleY\", r.scaleY), t.skewX = r.skewX, t.skewY = r.skewY, t.angle = r.angle, t.setPositionByOrigin(n, \"center\", \"center\"), t;\n          },\n          _restoreObjectState: function _restoreObjectState(t) {\n            return this.realizeTransform(t), t.setCoords(), delete t.group, this;\n          },\n          destroy: function destroy() {\n            return this._objects.forEach(function (t) {\n              t.set(\"dirty\", !0);\n            }), this._restoreObjectsState();\n          },\n          toActiveSelection: function toActiveSelection() {\n            if (this.canvas) {\n              var t = this._objects,\n                  i = this.canvas;\n              this._objects = [];\n              var r = this.toObject();\n              delete r.objects;\n              var n = new e.ActiveSelection([]);\n              return n.set(r), n.type = \"activeSelection\", i.remove(this), t.forEach(function (t) {\n                t.group = n, t.dirty = !0, i.add(t);\n              }), n.canvas = i, n._objects = t, (i._activeObject = n).setCoords(), n;\n            }\n          },\n          ungroupOnCanvas: function ungroupOnCanvas() {\n            return this._restoreObjectsState();\n          },\n          setObjectsCoords: function setObjectsCoords() {\n            return this.forEachObject(function (t) {\n              t.setCoords(!0, !0);\n            }), this;\n          },\n          _calcBounds: function _calcBounds(t) {\n            for (var e, i, r, n = [], o = [], s = [\"tr\", \"br\", \"bl\", \"tl\"], a = 0, h = this._objects.length, c = s.length; a < h; ++a) {\n              for ((e = this._objects[a]).setCoords(!0), r = 0; r < c; r++) {\n                i = s[r], n.push(e.oCoords[i].x), o.push(e.oCoords[i].y);\n              }\n            }\n\n            this._getBounds(n, o, t);\n          },\n          _getBounds: function _getBounds(t, n, o) {\n            var s = new e.Point(i(t), i(n)),\n                a = new e.Point(r(t), r(n)),\n                h = s.y || 0,\n                c = s.x || 0,\n                l = a.x - s.x || 0,\n                u = a.y - s.y || 0;\n            this.width = l, this.height = u, o || this.setPositionByOrigin({\n              x: c,\n              y: h\n            }, \"left\", \"top\");\n          },\n          toSVG: function toSVG(t) {\n            for (var e = [], i = 0, r = this._objects.length; i < r; i++) {\n              e.push(\"\\t\", this._objects[i].toSVG(t));\n            }\n\n            return this._createBaseSVGMarkup(e, {\n              reviver: t,\n              noStyle: !0,\n              withShadow: !0\n            });\n          },\n          toClipPathSVG: function toClipPathSVG(t) {\n            for (var e = [], i = 0, r = this._objects.length; i < r; i++) {\n              e.push(\"\\t\", this._objects[i].toClipPathSVG(t));\n            }\n\n            return this._createBaseClipPathSVGMarkup(e, {\n              reviver: t\n            });\n          }\n        }), e.Group.fromObject = function (t, i) {\n          e.util.enlivenObjects(t.objects, function (r) {\n            e.util.enlivenObjects([t.clipPath], function (n) {\n              var o = e.util.object.clone(t, !0);\n              o.clipPath = n[0], delete o.objects, i && i(new e.Group(r, o, !0));\n            });\n          });\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n        e.ActiveSelection || (e.ActiveSelection = e.util.createClass(e.Group, {\n          type: \"activeSelection\",\n          initialize: function initialize(t, i) {\n            i = i || {}, this._objects = t || [];\n\n            for (var r = this._objects.length; r--;) {\n              this._objects[r].group = this;\n            }\n\n            i.originX && (this.originX = i.originX), i.originY && (this.originY = i.originY), this._calcBounds(), this._updateObjectsCoords(), e.Object.prototype.initialize.call(this, i), this.setCoords();\n          },\n          toGroup: function toGroup() {\n            var t = this._objects.concat();\n\n            this._objects = [];\n            var i = e.Object.prototype.toObject.call(this),\n                r = new e.Group([]);\n            if (delete i.type, r.set(i), t.forEach(function (t) {\n              t.canvas.remove(t), t.group = r;\n            }), r._objects = t, !this.canvas) return r;\n            var n = this.canvas;\n            return n.add(r), (n._activeObject = r).setCoords(), r;\n          },\n          onDeselect: function onDeselect() {\n            return this.destroy(), !1;\n          },\n          toString: function toString() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n          },\n          shouldCache: function shouldCache() {\n            return !1;\n          },\n          isOnACache: function isOnACache() {\n            return !1;\n          },\n          _renderControls: function _renderControls(t, e, i) {\n            t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper(\"_renderControls\", t, e), void 0 === (i = i || {}).hasControls && (i.hasControls = !1), void 0 === i.hasRotatingPoint && (i.hasRotatingPoint = !1), i.forActiveSelection = !0;\n\n            for (var r = 0, n = this._objects.length; r < n; r++) {\n              this._objects[r]._renderControls(t, i);\n            }\n\n            t.restore();\n          }\n        }), e.ActiveSelection.fromObject = function (t, i) {\n          e.util.enlivenObjects(t.objects, function (r) {\n            delete t.objects, i && i(new e.ActiveSelection(r, t, !0));\n          });\n        });\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = A.util.object.extend;\n        t.fabric || (t.fabric = {}), t.fabric.Image ? A.warn(\"fabric.Image is already defined.\") : (A.Image = A.util.createClass(A.Object, {\n          type: \"image\",\n          crossOrigin: \"\",\n          strokeWidth: 0,\n          _lastScaleX: 1,\n          _lastScaleY: 1,\n          _filterScalingX: 1,\n          _filterScalingY: 1,\n          minimumScaleTrigger: .5,\n          stateProperties: A.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n          cacheKey: \"\",\n          cropX: 0,\n          cropY: 0,\n          initialize: function initialize(t, e) {\n            e || (e = {}), this.filters = [], this.cacheKey = \"texture\" + A.Object.__uid++, this.callSuper(\"initialize\", e), this._initElement(t, e);\n          },\n          getElement: function getElement() {\n            return this._element || {};\n          },\n          setElement: function setElement(t, e) {\n            return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + \"_filtered\"), this._element = t, this._originalElement = t, this._initConfig(e), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this;\n          },\n          removeTexture: function removeTexture(t) {\n            var e = A.filterBackend;\n            e && e.evictCachesForKey && e.evictCachesForKey(t);\n          },\n          dispose: function dispose() {\n            this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + \"_filtered\"), this._cacheContext = void 0, [\"_originalElement\", \"_element\", \"_filteredEl\", \"_cacheCanvas\"].forEach(function (t) {\n              A.util.cleanUpJsdomNode(this[t]), this[t] = void 0;\n            }.bind(this));\n          },\n          setCrossOrigin: function setCrossOrigin(t) {\n            return this.crossOrigin = t, this._element.crossOrigin = t, this;\n          },\n          getOriginalSize: function getOriginalSize() {\n            var t = this.getElement();\n            return {\n              width: t.naturalWidth || t.width,\n              height: t.naturalHeight || t.height\n            };\n          },\n          _stroke: function _stroke(t) {\n            if (this.stroke && 0 !== this.strokeWidth) {\n              var e = this.width / 2,\n                  i = this.height / 2;\n              t.beginPath(), t.moveTo(-e, -i), t.lineTo(e, -i), t.lineTo(e, i), t.lineTo(-e, i), t.lineTo(-e, -i), t.closePath();\n            }\n          },\n          _renderDashedStroke: function _renderDashedStroke(t) {\n            var e = -this.width / 2,\n                i = -this.height / 2,\n                r = this.width,\n                n = this.height;\n            t.save(), this._setStrokeStyles(t, this), t.beginPath(), A.util.drawDashedLine(t, e, i, e + r, i, this.strokeDashArray), A.util.drawDashedLine(t, e + r, i, e + r, i + n, this.strokeDashArray), A.util.drawDashedLine(t, e + r, i + n, e, i + n, this.strokeDashArray), A.util.drawDashedLine(t, e, i + n, e, i, this.strokeDashArray), t.closePath(), t.restore();\n          },\n          toObject: function toObject(t) {\n            var i = [];\n            this.filters.forEach(function (t) {\n              t && i.push(t.toObject());\n            });\n            var r = e(this.callSuper(\"toObject\", [\"crossOrigin\", \"cropX\", \"cropY\"].concat(t)), {\n              src: this.getSrc(),\n              filters: i\n            });\n            return this.resizeFilter && (r.resizeFilter = this.resizeFilter.toObject()), r;\n          },\n          hasCrop: function hasCrop() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n          },\n          _toSVG: function _toSVG() {\n            var t,\n                e = [],\n                i = [],\n                r = -this.width / 2,\n                n = -this.height / 2,\n                o = \"\";\n\n            if (this.hasCrop()) {\n              var s = A.Object.__uid++;\n              e.push('<clipPath id=\"imageCrop_' + s + '\">\\n', '\\t<rect x=\"' + r + '\" y=\"' + n + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\"), o = ' clip-path=\"url(#imageCrop_' + s + ')\" ';\n            }\n\n            if (i.push(\"\\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(!0), '\" x=\"', r - this.cropX, '\" y=\"', n - this.cropY, '\" width=\"', this._element.width || this._element.naturalWidth, '\" height=\"', this._element.height || this._element.height, '\"', o, \"></image>\\n\"), this.stroke || this.strokeDashArray) {\n              var a = this.fill;\n              this.fill = null, t = [\"\\t<rect \", 'x=\"', r, '\" y=\"', n, '\" width=\"', this.width, '\" height=\"', this.height, '\" style=\"', this.getSvgStyles(), '\"/>\\n'], this.fill = a;\n            }\n\n            return \"fill\" !== this.paintFirst ? e.concat(t, i) : e.concat(i, t);\n          },\n          getSrc: function getSrc(t) {\n            var e = t ? this._element : this._originalElement;\n            return e ? e.toDataURL ? e.toDataURL() : e.src : this.src || \"\";\n          },\n          setSrc: function setSrc(t, e, i) {\n            return A.util.loadImage(t, function (t) {\n              this.setElement(t, i), this._setWidthHeight(), e(this);\n            }, this, i && i.crossOrigin), this;\n          },\n          toString: function toString() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n          },\n          applyResizeFilters: function applyResizeFilters() {\n            var t = this.resizeFilter,\n                e = this.minimumScaleTrigger,\n                i = this.getTotalObjectScaling(),\n                r = i.scaleX,\n                n = i.scaleY,\n                o = this._filteredEl || this._originalElement;\n            if (this.group && this.set(\"dirty\", !0), !t || e < r && e < n) return this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void (this._lastScaleY = n);\n            A.filterBackend || (A.filterBackend = A.initFilterBackend());\n            var s = A.util.createCanvasElement(),\n                a = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey,\n                h = o.width,\n                c = o.height;\n            s.width = h, s.height = c, this._element = s, this._lastScaleX = t.scaleX = r, this._lastScaleY = t.scaleY = n, A.filterBackend.applyFilters([t], o, h, c, this._element, a), this._filterScalingX = s.width / this._originalElement.width, this._filterScalingY = s.height / this._originalElement.height;\n          },\n          applyFilters: function applyFilters(t) {\n            if (t = (t = t || this.filters || []).filter(function (t) {\n              return t && !t.isNeutralState();\n            }), this.set(\"dirty\", !0), this.removeTexture(this.cacheKey + \"_filtered\"), 0 === t.length) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this;\n            var e = this._originalElement,\n                i = e.naturalWidth || e.width,\n                r = e.naturalHeight || e.height;\n\n            if (this._element === this._originalElement) {\n              var n = A.util.createCanvasElement();\n              n.width = i, n.height = r, this._element = n, this._filteredEl = n;\n            } else this._element = this._filteredEl, this._filteredEl.getContext(\"2d\").clearRect(0, 0, i, r), this._lastScaleX = 1, this._lastScaleY = 1;\n\n            return A.filterBackend || (A.filterBackend = A.initFilterBackend()), A.filterBackend.applyFilters(t, this._originalElement, i, r, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this;\n          },\n          _render: function _render(t) {\n            !0 !== this.isMoving && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t);\n          },\n          shouldCache: function shouldCache() {\n            return this.ownCaching = this.objectCaching && this.needsItsOwnCache(), this.ownCaching;\n          },\n          _renderFill: function _renderFill(t) {\n            var e = this.width,\n                i = this.height,\n                r = e * this._filterScalingX,\n                n = i * this._filterScalingY,\n                o = -e / 2,\n                s = -i / 2,\n                a = this._element;\n            a && t.drawImage(a, this.cropX * this._filterScalingX, this.cropY * this._filterScalingY, r, n, o, s, e, i);\n          },\n          _needsResize: function _needsResize() {\n            var t = this.getTotalObjectScaling();\n            return t.scaleX !== this._lastScaleX || t.scaleY !== this._lastScaleY;\n          },\n          _resetWidthHeight: function _resetWidthHeight() {\n            this.set(this.getOriginalSize());\n          },\n          _initElement: function _initElement(t, e) {\n            this.setElement(A.util.getById(t), e), A.util.addClass(this.getElement(), A.Image.CSS_CANVAS);\n          },\n          _initConfig: function _initConfig(t) {\n            t || (t = {}), this.setOptions(t), this._setWidthHeight(t), this._element && this.crossOrigin && (this._element.crossOrigin = this.crossOrigin);\n          },\n          _initFilters: function _initFilters(t, e) {\n            t && t.length ? A.util.enlivenObjects(t, function (t) {\n              e && e(t);\n            }, \"fabric.Image.filters\") : e && e();\n          },\n          _setWidthHeight: function _setWidthHeight(t) {\n            t || (t = {});\n            var e = this.getElement();\n            this.width = t.width || e.naturalWidth || e.width || 0, this.height = t.height || e.naturalHeight || e.height || 0;\n          },\n          parsePreserveAspectRatioAttribute: function parsePreserveAspectRatioAttribute() {\n            var t,\n                e = A.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"),\n                i = this._element.width,\n                r = this._element.height,\n                n = 1,\n                o = 1,\n                s = 0,\n                a = 0,\n                h = 0,\n                c = 0,\n                l = this.width,\n                u = this.height,\n                f = {\n              width: l,\n              height: u\n            };\n            return !e || \"none\" === e.alignX && \"none\" === e.alignY ? (n = l / i, o = u / r) : (\"meet\" === e.meetOrSlice && (t = (l - i * (n = o = A.util.findScaleToFit(this._element, f))) / 2, \"Min\" === e.alignX && (s = -t), \"Max\" === e.alignX && (s = t), t = (u - r * o) / 2, \"Min\" === e.alignY && (a = -t), \"Max\" === e.alignY && (a = t)), \"slice\" === e.meetOrSlice && (t = i - l / (n = o = A.util.findScaleToCover(this._element, f)), \"Mid\" === e.alignX && (h = t / 2), \"Max\" === e.alignX && (h = t), t = r - u / o, \"Mid\" === e.alignY && (c = t / 2), \"Max\" === e.alignY && (c = t), i = l / n, r = u / o)), {\n              width: i,\n              height: r,\n              scaleX: n,\n              scaleY: o,\n              offsetLeft: s,\n              offsetTop: a,\n              cropX: h,\n              cropY: c\n            };\n          }\n        }), A.Image.CSS_CANVAS = \"canvas-img\", A.Image.prototype.getSvgSrc = A.Image.prototype.getSrc, A.Image.fromObject = function (t, e) {\n          var i = A.util.object.clone(t);\n          A.util.loadImage(i.src, function (t, r) {\n            r ? e && e(null, r) : A.Image.prototype._initFilters.call(i, i.filters, function (r) {\n              i.filters = r || [], A.Image.prototype._initFilters.call(i, [i.resizeFilter], function (r) {\n                i.resizeFilter = r[0], A.util.enlivenObjects([i.clipPath], function (r) {\n                  i.clipPath = r[0];\n                  var n = new A.Image(t, i);\n                  e(n);\n                });\n              });\n            });\n          }, null, i.crossOrigin);\n        }, A.Image.fromURL = function (t, e, i) {\n          A.util.loadImage(t, function (t) {\n            e && e(new A.Image(t, i));\n          }, null, i && i.crossOrigin);\n        }, A.Image.ATTRIBUTE_NAMES = A.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin\".split(\" \")), A.Image.fromElement = function (t, i, r) {\n          var n = A.parseAttributes(t, A.Image.ATTRIBUTE_NAMES);\n          A.Image.fromURL(n[\"xlink:href\"], i, e(r ? A.util.object.clone(r) : {}, n));\n        });\n      }(e), A.util.object.extend(A.Object.prototype, {\n        _getAngleValueForStraighten: function _getAngleValueForStraighten() {\n          var t = this.angle % 360;\n          return 0 < t ? 90 * Math.round((t - 1) / 90) : 90 * Math.round(t / 90);\n        },\n        straighten: function straighten() {\n          return this.rotate(this._getAngleValueForStraighten()), this;\n        },\n        fxStraighten: function fxStraighten(t) {\n          var e = function e() {},\n              i = (t = t || {}).onComplete || e,\n              r = t.onChange || e,\n              n = this;\n\n          return A.util.animate({\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function onChange(t) {\n              n.rotate(t), r();\n            },\n            onComplete: function onComplete() {\n              n.setCoords(), i();\n            }\n          }), this;\n        }\n      }), A.util.object.extend(A.StaticCanvas.prototype, {\n        straightenObject: function straightenObject(t) {\n          return t.straighten(), this.requestRenderAll(), this;\n        },\n        fxStraightenObject: function fxStraightenObject(t) {\n          return t.fxStraighten({\n            onChange: this.requestRenderAllBound\n          }), this;\n        }\n      }), function () {\n        \"use strict\";\n\n        A.isWebglSupported = function (t) {\n          if (A.isLikelyNode) return !1;\n          t = t || A.WebglFilterBackend.prototype.tileSize;\n          var e,\n              i,\n              r,\n              n = document.createElement(\"canvas\"),\n              o = n.getContext(\"webgl\") || n.getContext(\"experimental-webgl\"),\n              s = !1;\n\n          if (o) {\n            A.maxTextureSize = o.getParameter(o.MAX_TEXTURE_SIZE), s = A.maxTextureSize >= t;\n\n            for (var a = [\"highp\", \"mediump\", \"lowp\"], h = 0; h < 3; h++) {\n              if (i = \"precision \" + a[h] + \" float;\\nvoid main(){}\", r = (e = o).createShader(e.FRAGMENT_SHADER), e.shaderSource(r, i), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS)) {\n                A.webGlPrecision = a[h];\n                break;\n              }\n            }\n          }\n\n          return this.isSupported = s;\n        }, (A.WebglFilterBackend = function (t) {\n          t && t.tileSize && (this.tileSize = t.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo();\n        }).prototype = {\n          tileSize: 2048,\n          resources: {},\n          setupGLContext: function setupGLContext(t, e) {\n            this.dispose(), this.createWebGLCanvas(t, e), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(t, e);\n          },\n          chooseFastestCopyGLTo2DMethod: function chooseFastestCopyGLTo2DMethod(t, e) {\n            var i,\n                r = void 0 !== window.performance;\n\n            try {\n              new ImageData(1, 1), i = !0;\n            } catch (t) {\n              i = !1;\n            }\n\n            var n = \"undefined\" != typeof ArrayBuffer,\n                o = \"undefined\" != typeof Uint8ClampedArray;\n\n            if (r && i && n && o) {\n              var s,\n                  a,\n                  h,\n                  c = A.util.createCanvasElement(),\n                  l = new ArrayBuffer(t * e * 4),\n                  u = {\n                imageBuffer: l,\n                destinationWidth: t,\n                destinationHeight: e,\n                targetCanvas: c\n              };\n              c.width = t, c.height = e, s = window.performance.now(), D.call(u, this.gl, u), a = window.performance.now() - s, s = window.performance.now(), j.call(u, this.gl, u), h = window.performance.now() - s, this.copyGLTo2D = h < a ? (this.imageBuffer = l, j) : D;\n            }\n          },\n          createWebGLCanvas: function createWebGLCanvas(t, e) {\n            var i = A.util.createCanvasElement();\n            i.width = t, i.height = e;\n            var r = {\n              alpha: !0,\n              premultipliedAlpha: !1,\n              depth: !1,\n              stencil: !1,\n              antialias: !1\n            },\n                n = i.getContext(\"webgl\", r);\n            n || (n = i.getContext(\"experimental-webgl\", r)), n && (n.clearColor(0, 0, 0, 0), this.canvas = i, this.gl = n);\n          },\n          applyFilters: function applyFilters(t, e, i, r, n, o) {\n            var s,\n                a = this.gl;\n            o && (s = this.getCachedTexture(o, e));\n            var h,\n                c,\n                l,\n                u,\n                f,\n                d,\n                g = {\n              originalWidth: e.width || e.originalWidth,\n              originalHeight: e.height || e.originalHeight,\n              sourceWidth: i,\n              sourceHeight: r,\n              destinationWidth: i,\n              destinationHeight: r,\n              context: a,\n              sourceTexture: this.createTexture(a, i, r, !s && e),\n              targetTexture: this.createTexture(a, i, r),\n              originalTexture: s || this.createTexture(a, i, r, !s && e),\n              passes: t.length,\n              webgl: !0,\n              aPosition: this.aPosition,\n              programCache: this.programCache,\n              pass: 0,\n              filterBackend: this,\n              targetCanvas: n\n            },\n                p = a.createFramebuffer();\n            return a.bindFramebuffer(a.FRAMEBUFFER, p), t.forEach(function (t) {\n              t && t.applyTo(g);\n            }), l = (c = (h = g).targetCanvas).width, u = c.height, d = h.destinationHeight, l === (f = h.destinationWidth) && u === d || (c.width = f, c.height = d), this.copyGLTo2D(a, g), a.bindTexture(a.TEXTURE_2D, null), a.deleteTexture(g.sourceTexture), a.deleteTexture(g.targetTexture), a.deleteFramebuffer(p), n.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0), g;\n          },\n          applyFiltersDebug: function applyFiltersDebug(t, e, i, r, n, o) {\n            var s = this.gl,\n                a = this.applyFilters(t, e, i, r, n, o),\n                h = s.getError();\n            if (h === s.NO_ERROR) return a;\n            var c = this.glErrorToString(s, h),\n                l = new Error(\"WebGL Error \" + c);\n            throw l.glErrorCode = h, l;\n          },\n          glErrorToString: function glErrorToString(t, e) {\n            if (!t) return \"Context undefined for error code: \" + e;\n            if (\"number\" != typeof e) return \"Error code is not a number\";\n\n            switch (e) {\n              case t.NO_ERROR:\n                return \"NO_ERROR\";\n\n              case t.INVALID_ENUM:\n                return \"INVALID_ENUM\";\n\n              case t.INVALID_VALUE:\n                return \"INVALID_VALUE\";\n\n              case t.INVALID_OPERATION:\n                return \"INVALID_OPERATION\";\n\n              case t.INVALID_FRAMEBUFFER_OPERATION:\n                return \"INVALID_FRAMEBUFFER_OPERATION\";\n\n              case t.OUT_OF_MEMORY:\n                return \"OUT_OF_MEMORY\";\n\n              case t.CONTEXT_LOST_WEBGL:\n                return \"CONTEXT_LOST_WEBGL\";\n\n              default:\n                return \"UNKNOWN_ERROR\";\n            }\n          },\n          dispose: function dispose() {\n            this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();\n          },\n          clearWebGLCaches: function clearWebGLCaches() {\n            this.programCache = {}, this.textureCache = {};\n          },\n          createTexture: function createTexture(t, e, i, r) {\n            var n = t.createTexture();\n            return t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), r ? t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), n;\n          },\n          getCachedTexture: function getCachedTexture(t, e) {\n            if (this.textureCache[t]) return this.textureCache[t];\n            var i = this.createTexture(this.gl, e.width, e.height, e);\n            return this.textureCache[t] = i;\n          },\n          evictCachesForKey: function evictCachesForKey(t) {\n            this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t]);\n          },\n          copyGLTo2D: D,\n          captureGPUInfo: function captureGPUInfo() {\n            if (this.gpuInfo) return this.gpuInfo;\n            var t = this.gl,\n                e = t.getExtension(\"WEBGL_debug_renderer_info\"),\n                i = {\n              renderer: \"\",\n              vendor: \"\"\n            };\n\n            if (e) {\n              var r = t.getParameter(e.UNMASKED_RENDERER_WEBGL),\n                  n = t.getParameter(e.UNMASKED_VENDOR_WEBGL);\n              r && (i.renderer = r.toLowerCase()), n && (i.vendor = n.toLowerCase());\n            }\n\n            return this.gpuInfo = i;\n          }\n        };\n      }(), function () {\n        \"use strict\";\n\n        var t = function t() {};\n\n        (A.Canvas2dFilterBackend = function () {}).prototype = {\n          evictCachesForKey: t,\n          dispose: t,\n          clearWebGLCaches: t,\n          resources: {},\n          applyFilters: function applyFilters(t, e, i, r, n) {\n            var o = n.getContext(\"2d\");\n            o.drawImage(e, 0, 0, i, r);\n            var s = {\n              sourceWidth: i,\n              sourceHeight: r,\n              imageData: o.getImageData(0, 0, i, r),\n              originalEl: e,\n              originalImageData: o.getImageData(0, 0, i, r),\n              canvasEl: n,\n              ctx: o,\n              filterBackend: this\n            };\n            return t.forEach(function (t) {\n              t.applyTo(s);\n            }), s.imageData.width === i && s.imageData.height === r || (n.width = s.imageData.width, n.height = s.imageData.height), o.putImageData(s.imageData, 0, 0), s;\n          }\n        };\n      }(), A.Image = A.Image || {}, A.Image.filters = A.Image.filters || {}, A.Image.filters.BaseFilter = A.util.createClass({\n        type: \"BaseFilter\",\n        vertexSource: \"attribute vec2 aPosition;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvTexCoord = aPosition;\\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n}\",\n        fragmentSource: \"precision highp float;\\nvarying vec2 vTexCoord;\\nuniform sampler2D uTexture;\\nvoid main() {\\ngl_FragColor = texture2D(uTexture, vTexCoord);\\n}\",\n        initialize: function initialize(t) {\n          t && this.setOptions(t);\n        },\n        setOptions: function setOptions(t) {\n          for (var e in t) {\n            this[e] = t[e];\n          }\n        },\n        createProgram: function createProgram(t, e, i) {\n          e = e || this.fragmentSource, i = i || this.vertexSource, \"highp\" !== A.webGlPrecision && (e = e.replace(/precision highp float/g, \"precision \" + A.webGlPrecision + \" float\"));\n          var r = t.createShader(t.VERTEX_SHADER);\n          if (t.shaderSource(r, i), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) throw new Error(\"Vertex shader compile error for \" + this.type + \": \" + t.getShaderInfoLog(r));\n          var n = t.createShader(t.FRAGMENT_SHADER);\n          if (t.shaderSource(n, e), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) throw new Error(\"Fragment shader compile error for \" + this.type + \": \" + t.getShaderInfoLog(n));\n          var o = t.createProgram();\n          if (t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), !t.getProgramParameter(o, t.LINK_STATUS)) throw new Error('Shader link error for \"${this.type}\" ' + t.getProgramInfoLog(o));\n          var s = this.getAttributeLocations(t, o),\n              a = this.getUniformLocations(t, o) || {};\n          return a.uStepW = t.getUniformLocation(o, \"uStepW\"), a.uStepH = t.getUniformLocation(o, \"uStepH\"), {\n            program: o,\n            attributeLocations: s,\n            uniformLocations: a\n          };\n        },\n        getAttributeLocations: function getAttributeLocations(t, e) {\n          return {\n            aPosition: t.getAttribLocation(e, \"aPosition\")\n          };\n        },\n        getUniformLocations: function getUniformLocations() {\n          return {};\n        },\n        sendAttributeData: function sendAttributeData(t, e, i) {\n          var r = e.aPosition,\n              n = t.createBuffer();\n          t.bindBuffer(t.ARRAY_BUFFER, n), t.enableVertexAttribArray(r), t.vertexAttribPointer(r, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW);\n        },\n        _setupFrameBuffer: function _setupFrameBuffer(t) {\n          var e,\n              i,\n              r = t.context;\n          1 < t.passes ? (e = t.destinationWidth, i = t.destinationHeight, t.sourceWidth === e && t.sourceHeight === i || (r.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(r, e, i)), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t.targetTexture, 0)) : (r.bindFramebuffer(r.FRAMEBUFFER, null), r.finish());\n        },\n        _swapTextures: function _swapTextures(t) {\n          t.passes--, t.pass++;\n          var e = t.targetTexture;\n          t.targetTexture = t.sourceTexture, t.sourceTexture = e;\n        },\n        isNeutralState: function isNeutralState() {\n          var t = this.mainParameter,\n              e = A.Image.filters[this.type].prototype;\n\n          if (t) {\n            if (Array.isArray(e[t])) {\n              for (var i = e[t].length; i--;) {\n                if (this[t][i] !== e[t][i]) return !1;\n              }\n\n              return !0;\n            }\n\n            return e[t] === this[t];\n          }\n\n          return !1;\n        },\n        applyTo: function applyTo(t) {\n          t.webgl ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);\n        },\n        retrieveShader: function retrieveShader(t) {\n          return t.programCache.hasOwnProperty(this.type) || (t.programCache[this.type] = this.createProgram(t.context)), t.programCache[this.type];\n        },\n        applyToWebGL: function applyToWebGL(t) {\n          var e = t.context,\n              i = this.retrieveShader(t);\n          0 === t.pass && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(i.program), this.sendAttributeData(e, i.attributeLocations, t.aPosition), e.uniform1f(i.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(i.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, i.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);\n        },\n        bindAdditionalTexture: function bindAdditionalTexture(t, e, i) {\n          t.activeTexture(i), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0);\n        },\n        unbindAdditionalTexture: function unbindAdditionalTexture(t, e) {\n          t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0);\n        },\n        getMainParameter: function getMainParameter() {\n          return this[this.mainParameter];\n        },\n        setMainParameter: function setMainParameter(t) {\n          this[this.mainParameter] = t;\n        },\n        sendUniformData: function sendUniformData() {},\n        createHelpLayer: function createHelpLayer(t) {\n          if (!t.helpLayer) {\n            var e = document.createElement(\"canvas\");\n            e.width = t.sourceWidth, e.height = t.sourceHeight, t.helpLayer = e;\n          }\n        },\n        toObject: function toObject() {\n          var t = {\n            type: this.type\n          },\n              e = this.mainParameter;\n          return e && (t[e] = this[e]), t;\n        },\n        toJSON: function toJSON() {\n          return this.toObject();\n        }\n      }), A.Image.filters.BaseFilter.fromObject = function (t, e) {\n        var i = new A.Image.filters[t.type](t);\n        return e && e(i), i;\n      }, function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.ColorMatrix = r(i.BaseFilter, {\n          type: \"ColorMatrix\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nvarying vec2 vTexCoord;\\nuniform mat4 uColorMatrix;\\nuniform vec4 uConstants;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\ncolor *= uColorMatrix;\\ncolor += uConstants;\\ngl_FragColor = color;\\n}\",\n          matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n          mainParameter: \"matrix\",\n          colorsOnly: !0,\n          initialize: function initialize(t) {\n            this.callSuper(\"initialize\", t), this.matrix = this.matrix.slice(0);\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i,\n                r,\n                n,\n                o,\n                s = t.imageData.data,\n                a = s.length,\n                h = this.matrix,\n                c = this.colorsOnly;\n\n            for (o = 0; o < a; o += 4) {\n              e = s[o], i = s[o + 1], r = s[o + 2], c ? (s[o] = e * h[0] + i * h[1] + r * h[2] + 255 * h[4], s[o + 1] = e * h[5] + i * h[6] + r * h[7] + 255 * h[9], s[o + 2] = e * h[10] + i * h[11] + r * h[12] + 255 * h[14]) : (n = s[o + 3], s[o] = e * h[0] + i * h[1] + r * h[2] + n * h[3] + 255 * h[4], s[o + 1] = e * h[5] + i * h[6] + r * h[7] + n * h[8] + 255 * h[9], s[o + 2] = e * h[10] + i * h[11] + r * h[12] + n * h[13] + 255 * h[14], s[o + 3] = e * h[15] + i * h[16] + r * h[17] + n * h[18] + 255 * h[19]);\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uColorMatrix: t.getUniformLocation(e, \"uColorMatrix\"),\n              uConstants: t.getUniformLocation(e, \"uConstants\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            var i = this.matrix,\n                r = [i[0], i[1], i[2], i[3], i[5], i[6], i[7], i[8], i[10], i[11], i[12], i[13], i[15], i[16], i[17], i[18]],\n                n = [i[4], i[9], i[14], i[19]];\n            t.uniformMatrix4fv(e.uColorMatrix, !1, r), t.uniform4fv(e.uConstants, n);\n          }\n        }), e.Image.filters.ColorMatrix.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Brightness = r(i.BaseFilter, {\n          type: \"Brightness\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uBrightness;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\ncolor.rgb += uBrightness;\\ngl_FragColor = color;\\n}\",\n          brightness: 0,\n          mainParameter: \"brightness\",\n          applyTo2d: function applyTo2d(t) {\n            if (0 !== this.brightness) {\n              var e,\n                  i = t.imageData.data,\n                  r = i.length,\n                  n = Math.round(255 * this.brightness);\n\n              for (e = 0; e < r; e += 4) {\n                i[e] = i[e] + n, i[e + 1] = i[e + 1] + n, i[e + 2] = i[e + 2] + n;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uBrightness: t.getUniformLocation(e, \"uBrightness\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1f(e.uBrightness, this.brightness);\n          }\n        }), e.Image.filters.Brightness.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.Image.filters,\n            n = e.util.createClass;\n        r.Convolute = n(r.BaseFilter, {\n          type: \"Convolute\",\n          opaque: !1,\n          matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],\n          fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[9];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 0);\\nfor (float h = 0.0; h < 3.0; h+=1.0) {\\nfor (float w = 0.0; w < 3.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n}\\n}\\ngl_FragColor = color;\\n}\",\n            Convolute_3_0: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[9];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 1);\\nfor (float h = 0.0; h < 3.0; h+=1.0) {\\nfor (float w = 0.0; w < 3.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n}\\n}\\nfloat alpha = texture2D(uTexture, vTexCoord).a;\\ngl_FragColor = color;\\ngl_FragColor.a = alpha;\\n}\",\n            Convolute_5_1: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[25];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 0);\\nfor (float h = 0.0; h < 5.0; h+=1.0) {\\nfor (float w = 0.0; w < 5.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n}\\n}\\ngl_FragColor = color;\\n}\",\n            Convolute_5_0: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[25];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 1);\\nfor (float h = 0.0; h < 5.0; h+=1.0) {\\nfor (float w = 0.0; w < 5.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n}\\n}\\nfloat alpha = texture2D(uTexture, vTexCoord).a;\\ngl_FragColor = color;\\ngl_FragColor.a = alpha;\\n}\",\n            Convolute_7_1: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[49];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 0);\\nfor (float h = 0.0; h < 7.0; h+=1.0) {\\nfor (float w = 0.0; w < 7.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n}\\n}\\ngl_FragColor = color;\\n}\",\n            Convolute_7_0: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[49];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 1);\\nfor (float h = 0.0; h < 7.0; h+=1.0) {\\nfor (float w = 0.0; w < 7.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n}\\n}\\nfloat alpha = texture2D(uTexture, vTexCoord).a;\\ngl_FragColor = color;\\ngl_FragColor.a = alpha;\\n}\",\n            Convolute_9_1: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[81];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 0);\\nfor (float h = 0.0; h < 9.0; h+=1.0) {\\nfor (float w = 0.0; w < 9.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n}\\n}\\ngl_FragColor = color;\\n}\",\n            Convolute_9_0: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uMatrix[81];\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = vec4(0, 0, 0, 1);\\nfor (float h = 0.0; h < 9.0; h+=1.0) {\\nfor (float w = 0.0; w < 9.0; w+=1.0) {\\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n}\\n}\\nfloat alpha = texture2D(uTexture, vTexCoord).a;\\ngl_FragColor = color;\\ngl_FragColor.a = alpha;\\n}\"\n          },\n          retrieveShader: function retrieveShader(t) {\n            var e = Math.sqrt(this.matrix.length),\n                i = this.type + \"_\" + e + \"_\" + (this.opaque ? 1 : 0),\n                r = this.fragmentSource[i];\n            return t.programCache.hasOwnProperty(i) || (t.programCache[i] = this.createProgram(t.context, r)), t.programCache[i];\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i,\n                r,\n                n,\n                o,\n                s,\n                a,\n                h,\n                c,\n                l,\n                u,\n                f,\n                d,\n                g = t.imageData,\n                p = g.data,\n                v = this.matrix,\n                m = Math.round(Math.sqrt(v.length)),\n                y = Math.floor(m / 2),\n                _ = g.width,\n                b = g.height,\n                x = t.ctx.createImageData(_, b),\n                C = x.data,\n                S = this.opaque ? 1 : 0;\n\n            for (u = 0; u < b; u++) {\n              for (l = 0; l < _; l++) {\n                for (o = 4 * (u * _ + l), d = n = r = i = e = 0; d < m; d++) {\n                  for (f = 0; f < m; f++) {\n                    s = l + f - y, (a = u + d - y) < 0 || b < a || s < 0 || _ < s || (h = 4 * (a * _ + s), c = v[d * m + f], e += p[h] * c, i += p[h + 1] * c, r += p[h + 2] * c, S || (n += p[h + 3] * c));\n                  }\n                }\n\n                C[o] = e, C[o + 1] = i, C[o + 2] = r, C[o + 3] = S ? p[o + 3] : n;\n              }\n            }\n\n            t.imageData = x;\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uMatrix: t.getUniformLocation(e, \"uMatrix\"),\n              uOpaque: t.getUniformLocation(e, \"uOpaque\"),\n              uHalfSize: t.getUniformLocation(e, \"uHalfSize\"),\n              uSize: t.getUniformLocation(e, \"uSize\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1fv(e.uMatrix, this.matrix);\n          },\n          toObject: function toObject() {\n            return i(this.callSuper(\"toObject\"), {\n              opaque: this.opaque,\n              matrix: this.matrix\n            });\n          }\n        }), e.Image.filters.Convolute.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Grayscale = r(i.BaseFilter, {\n          type: \"Grayscale\",\n          fragmentSource: {\n            average: \"precision highp float;\\nuniform sampler2D uTexture;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nfloat average = (color.r + color.b + color.g) / 3.0;\\ngl_FragColor = vec4(average, average, average, color.a);\\n}\",\n            lightness: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform int uMode;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 col = texture2D(uTexture, vTexCoord);\\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\ngl_FragColor = vec4(average, average, average, col.a);\\n}\",\n            luminosity: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform int uMode;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 col = texture2D(uTexture, vTexCoord);\\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\ngl_FragColor = vec4(average, average, average, col.a);\\n}\"\n          },\n          mode: \"average\",\n          mainParameter: \"mode\",\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i,\n                r = t.imageData.data,\n                n = r.length,\n                o = this.mode;\n\n            for (e = 0; e < n; e += 4) {\n              \"average\" === o ? i = (r[e] + r[e + 1] + r[e + 2]) / 3 : \"lightness\" === o ? i = (Math.min(r[e], r[e + 1], r[e + 2]) + Math.max(r[e], r[e + 1], r[e + 2])) / 2 : \"luminosity\" === o && (i = .21 * r[e] + .72 * r[e + 1] + .07 * r[e + 2]), r[e] = i, r[e + 1] = i, r[e + 2] = i;\n            }\n          },\n          retrieveShader: function retrieveShader(t) {\n            var e = this.type + \"_\" + this.mode;\n\n            if (!t.programCache.hasOwnProperty(e)) {\n              var i = this.fragmentSource[this.mode];\n              t.programCache[e] = this.createProgram(t.context, i);\n            }\n\n            return t.programCache[e];\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uMode: t.getUniformLocation(e, \"uMode\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1i(e.uMode, 1);\n          },\n          isNeutralState: function isNeutralState() {\n            return !1;\n          }\n        }), e.Image.filters.Grayscale.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Invert = r(i.BaseFilter, {\n          type: \"Invert\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform int uInvert;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nif (uInvert == 1) {\\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n} else {\\ngl_FragColor = color;\\n}\\n}\",\n          invert: !0,\n          mainParameter: \"invert\",\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i = t.imageData.data,\n                r = i.length;\n\n            for (e = 0; e < r; e += 4) {\n              i[e] = 255 - i[e], i[e + 1] = 255 - i[e + 1], i[e + 2] = 255 - i[e + 2];\n            }\n          },\n          isNeutralState: function isNeutralState() {\n            return !this.invert;\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uInvert: t.getUniformLocation(e, \"uInvert\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1i(e.uInvert, this.invert);\n          }\n        }), e.Image.filters.Invert.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.Image.filters,\n            n = e.util.createClass;\n        r.Noise = n(r.BaseFilter, {\n          type: \"Noise\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uStepH;\\nuniform float uNoise;\\nuniform float uSeed;\\nvarying vec2 vTexCoord;\\nfloat rand(vec2 co, float seed, float vScale) {\\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n}\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\ngl_FragColor = color;\\n}\",\n          mainParameter: \"noise\",\n          noise: 0,\n          applyTo2d: function applyTo2d(t) {\n            if (0 !== this.noise) {\n              var e,\n                  i,\n                  r = t.imageData.data,\n                  n = r.length,\n                  o = this.noise;\n\n              for (e = 0, n = r.length; e < n; e += 4) {\n                i = (.5 - Math.random()) * o, r[e] += i, r[e + 1] += i, r[e + 2] += i;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uNoise: t.getUniformLocation(e, \"uNoise\"),\n              uSeed: t.getUniformLocation(e, \"uSeed\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random());\n          },\n          toObject: function toObject() {\n            return i(this.callSuper(\"toObject\"), {\n              noise: this.noise\n            });\n          }\n        }), e.Image.filters.Noise.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Pixelate = r(i.BaseFilter, {\n          type: \"Pixelate\",\n          blocksize: 4,\n          mainParameter: \"blocksize\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uBlocksize;\\nuniform float uStepW;\\nuniform float uStepH;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nfloat blockW = uBlocksize * uStepW;\\nfloat blockH = uBlocksize * uStepW;\\nint posX = int(vTexCoord.x / blockW);\\nint posY = int(vTexCoord.y / blockH);\\nfloat fposX = float(posX);\\nfloat fposY = float(posY);\\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\nvec4 color = texture2D(uTexture, squareCoords);\\ngl_FragColor = color;\\n}\",\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i,\n                r,\n                n,\n                o,\n                s,\n                a,\n                h,\n                c,\n                l,\n                u,\n                f = t.imageData,\n                d = f.data,\n                g = f.height,\n                p = f.width;\n\n            for (i = 0; i < g; i += this.blocksize) {\n              for (r = 0; r < p; r += this.blocksize) {\n                for (n = d[e = 4 * i * p + 4 * r], o = d[e + 1], s = d[e + 2], a = d[e + 3], l = Math.min(i + this.blocksize, g), u = Math.min(r + this.blocksize, p), h = i; h < l; h++) {\n                  for (c = r; c < u; c++) {\n                    d[e = 4 * h * p + 4 * c] = n, d[e + 1] = o, d[e + 2] = s, d[e + 3] = a;\n                  }\n                }\n              }\n            }\n          },\n          isNeutralState: function isNeutralState() {\n            return 1 === this.blocksize;\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uBlocksize: t.getUniformLocation(e, \"uBlocksize\"),\n              uStepW: t.getUniformLocation(e, \"uStepW\"),\n              uStepH: t.getUniformLocation(e, \"uStepH\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1f(e.uBlocksize, this.blocksize);\n          }\n        }), e.Image.filters.Pixelate.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.extend,\n            r = e.Image.filters,\n            n = e.util.createClass;\n        r.RemoveColor = n(r.BaseFilter, {\n          type: \"RemoveColor\",\n          color: \"#FFFFFF\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform vec4 uLow;\\nuniform vec4 uHigh;\\nvarying vec2 vTexCoord;\\nvoid main() {\\ngl_FragColor = texture2D(uTexture, vTexCoord);\\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\ngl_FragColor.a = 0.0;\\n}\\n}\",\n          distance: .02,\n          useAlpha: !1,\n          applyTo2d: function applyTo2d(t) {\n            var i,\n                r,\n                n,\n                o,\n                s = t.imageData.data,\n                a = 255 * this.distance,\n                h = new e.Color(this.color).getSource(),\n                c = [h[0] - a, h[1] - a, h[2] - a],\n                l = [h[0] + a, h[1] + a, h[2] + a];\n\n            for (i = 0; i < s.length; i += 4) {\n              r = s[i], n = s[i + 1], o = s[i + 2], c[0] < r && c[1] < n && c[2] < o && r < l[0] && n < l[1] && o < l[2] && (s[i + 3] = 0);\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uLow: t.getUniformLocation(e, \"uLow\"),\n              uHigh: t.getUniformLocation(e, \"uHigh\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, i) {\n            var r = new e.Color(this.color).getSource(),\n                n = parseFloat(this.distance),\n                o = [0 + r[0] / 255 - n, 0 + r[1] / 255 - n, 0 + r[2] / 255 - n, 1],\n                s = [r[0] / 255 + n, r[1] / 255 + n, r[2] / 255 + n, 1];\n            t.uniform4fv(i.uLow, o), t.uniform4fv(i.uHigh, s);\n          },\n          toObject: function toObject() {\n            return i(this.callSuper(\"toObject\"), {\n              color: this.color,\n              distance: this.distance\n            });\n          }\n        }), e.Image.filters.RemoveColor.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass,\n            n = {\n          Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0],\n          Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0],\n          Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0],\n          Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0],\n          Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0],\n          Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0],\n          BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]\n        };\n\n        for (var o in n) {\n          i[o] = r(i.ColorMatrix, {\n            type: o,\n            matrix: n[o],\n            mainParameter: !1,\n            colorsOnly: !0\n          }), e.Image.filters[o].fromObject = e.Image.filters.BaseFilter.fromObject;\n        }\n      }(e), function (t) {\n        \"use strict\";\n\n        var i = e.fabric,\n            r = i.Image.filters,\n            n = i.util.createClass;\n        r.BlendColor = n(r.BaseFilter, {\n          type: \"BlendColor\",\n          color: \"#F95C63\",\n          mode: \"multiply\",\n          alpha: 1,\n          fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\ngl_FragColor.r *= 2.0 * uColor.r;\\n} else {\\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n}\\nif (uColor.g < 0.5) {\\ngl_FragColor.g *= 2.0 * uColor.g;\\n} else {\\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n}\\nif (uColor.b < 0.5) {\\ngl_FragColor.b *= 2.0 * uColor.b;\\n} else {\\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\ngl_FragColor.rgb += uColor.rgb;\\n\"\n          },\n          buildSource: function buildSource(t) {\n            return \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform vec4 uColor;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\ngl_FragColor = color;\\nif (color.a > 0.0) {\\n\" + this.fragmentSource[t] + \"}\\n}\";\n          },\n          retrieveShader: function retrieveShader(t) {\n            var e,\n                i = this.type + \"_\" + this.mode;\n            return t.programCache.hasOwnProperty(i) || (e = this.buildSource(this.mode), t.programCache[i] = this.createProgram(t.context, e)), t.programCache[i];\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                r,\n                n,\n                o,\n                s,\n                a,\n                h,\n                c = t.imageData.data,\n                l = c.length,\n                u = 1 - this.alpha;\n            e = (h = new i.Color(this.color).getSource())[0] * this.alpha, r = h[1] * this.alpha, n = h[2] * this.alpha;\n\n            for (var f = 0; f < l; f += 4) {\n              switch (o = c[f], s = c[f + 1], a = c[f + 2], this.mode) {\n                case \"multiply\":\n                  c[f] = o * e / 255, c[f + 1] = s * r / 255, c[f + 2] = a * n / 255;\n                  break;\n\n                case \"screen\":\n                  c[f] = 255 - (255 - o) * (255 - e) / 255, c[f + 1] = 255 - (255 - s) * (255 - r) / 255, c[f + 2] = 255 - (255 - a) * (255 - n) / 255;\n                  break;\n\n                case \"add\":\n                  c[f] = o + e, c[f + 1] = s + r, c[f + 2] = a + n;\n                  break;\n\n                case \"diff\":\n                case \"difference\":\n                  c[f] = Math.abs(o - e), c[f + 1] = Math.abs(s - r), c[f + 2] = Math.abs(a - n);\n                  break;\n\n                case \"subtract\":\n                  c[f] = o - e, c[f + 1] = s - r, c[f + 2] = a - n;\n                  break;\n\n                case \"darken\":\n                  c[f] = Math.min(o, e), c[f + 1] = Math.min(s, r), c[f + 2] = Math.min(a, n);\n                  break;\n\n                case \"lighten\":\n                  c[f] = Math.max(o, e), c[f + 1] = Math.max(s, r), c[f + 2] = Math.max(a, n);\n                  break;\n\n                case \"overlay\":\n                  c[f] = e < 128 ? 2 * o * e / 255 : 255 - 2 * (255 - o) * (255 - e) / 255, c[f + 1] = r < 128 ? 2 * s * r / 255 : 255 - 2 * (255 - s) * (255 - r) / 255, c[f + 2] = n < 128 ? 2 * a * n / 255 : 255 - 2 * (255 - a) * (255 - n) / 255;\n                  break;\n\n                case \"exclusion\":\n                  c[f] = e + o - 2 * e * o / 255, c[f + 1] = r + s - 2 * r * s / 255, c[f + 2] = n + a - 2 * n * a / 255;\n                  break;\n\n                case \"tint\":\n                  c[f] = e + o * u, c[f + 1] = r + s * u, c[f + 2] = n + a * u;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uColor: t.getUniformLocation(e, \"uColor\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            var r = new i.Color(this.color).getSource();\n            r[0] = this.alpha * r[0] / 255, r[1] = this.alpha * r[1] / 255, r[2] = this.alpha * r[2] / 255, r[3] = this.alpha, t.uniform4fv(e.uColor, r);\n          },\n          toObject: function toObject() {\n            return {\n              type: this.type,\n              color: this.color,\n              mode: this.mode,\n              alpha: this.alpha\n            };\n          }\n        }), i.Image.filters.BlendColor.fromObject = i.Image.filters.BaseFilter.fromObject;\n      }(), function (t) {\n        \"use strict\";\n\n        var i = e.fabric,\n            r = i.Image.filters,\n            n = i.util.createClass;\n        r.BlendImage = n(r.BaseFilter, {\n          type: \"BlendImage\",\n          image: null,\n          mode: \"multiply\",\n          alpha: 1,\n          vertexSource: \"attribute vec2 aPosition;\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexCoord2;\\nuniform mat3 uTransformMatrix;\\nvoid main() {\\nvTexCoord = aPosition;\\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n}\",\n          fragmentSource: {\n            multiply: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform sampler2D uImage;\\nuniform vec4 uColor;\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexCoord2;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nvec4 color2 = texture2D(uImage, vTexCoord2);\\ncolor.rgba *= color2.rgba;\\ngl_FragColor = color;\\n}\",\n            mask: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform sampler2D uImage;\\nuniform vec4 uColor;\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexCoord2;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nvec4 color2 = texture2D(uImage, vTexCoord2);\\ncolor.a = color2.a;\\ngl_FragColor = color;\\n}\"\n          },\n          retrieveShader: function retrieveShader(t) {\n            var e = this.type + \"_\" + this.mode,\n                i = this.fragmentSource[this.mode];\n            return t.programCache.hasOwnProperty(e) || (t.programCache[e] = this.createProgram(t.context, i)), t.programCache[e];\n          },\n          applyToWebGL: function applyToWebGL(t) {\n            var e = t.context,\n                i = this.createTexture(t.filterBackend, this.image);\n            this.bindAdditionalTexture(e, i, e.TEXTURE1), this.callSuper(\"applyToWebGL\", t), this.unbindAdditionalTexture(e, e.TEXTURE1);\n          },\n          createTexture: function createTexture(t, e) {\n            return t.getCachedTexture(e.cacheKey, e._element);\n          },\n          calculateMatrix: function calculateMatrix() {\n            var t = this.image,\n                e = t._element.width,\n                i = t._element.height;\n            return [1 / t.scaleX, 0, 0, 0, 1 / t.scaleY, 0, -t.left / e, -t.top / i, 1];\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                r,\n                n,\n                o,\n                s,\n                a,\n                h,\n                c,\n                l,\n                u,\n                f,\n                d = t.imageData,\n                g = t.filterBackend.resources,\n                p = d.data,\n                v = p.length,\n                m = d.width,\n                y = d.height,\n                _ = this.image;\n            g.blendImage || (g.blendImage = i.util.createCanvasElement()), u = (l = g.blendImage).getContext(\"2d\"), l.width !== m || l.height !== y ? (l.width = m, l.height = y) : u.clearRect(0, 0, m, y), u.setTransform(_.scaleX, 0, 0, _.scaleY, _.left, _.top), u.drawImage(_._element, 0, 0, m, y), f = u.getImageData(0, 0, m, y).data;\n\n            for (var b = 0; b < v; b += 4) {\n              switch (s = p[b], a = p[b + 1], h = p[b + 2], c = p[b + 3], e = f[b], r = f[b + 1], n = f[b + 2], o = f[b + 3], this.mode) {\n                case \"multiply\":\n                  p[b] = s * e / 255, p[b + 1] = a * r / 255, p[b + 2] = h * n / 255, p[b + 3] = c * o / 255;\n                  break;\n\n                case \"mask\":\n                  p[b + 3] = o;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uTransformMatrix: t.getUniformLocation(e, \"uTransformMatrix\"),\n              uImage: t.getUniformLocation(e, \"uImage\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            var i = this.calculateMatrix();\n            t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, i);\n          },\n          toObject: function toObject() {\n            return {\n              type: this.type,\n              image: this.image && this.image.toObject(),\n              mode: this.mode,\n              alpha: this.alpha\n            };\n          }\n        }), i.Image.filters.BlendImage.fromObject = function (t, e) {\n          i.Image.fromObject(t.image, function (r) {\n            var n = i.util.object.clone(t);\n            n.image = r, e(new i.Image.filters.BlendImage(n));\n          });\n        };\n      }(), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = Math.pow,\n            r = Math.floor,\n            n = Math.sqrt,\n            o = Math.abs,\n            s = Math.round,\n            a = Math.sin,\n            h = Math.ceil,\n            c = e.Image.filters,\n            l = e.util.createClass;\n        c.Resize = l(c.BaseFilter, {\n          type: \"Resize\",\n          resizeType: \"hermite\",\n          scaleX: 1,\n          scaleY: 1,\n          lanczosLobes: 3,\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uDelta: t.getUniformLocation(e, \"uDelta\"),\n              uTaps: t.getUniformLocation(e, \"uTaps\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform2fv(e.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t.uniform1fv(e.uTaps, this.taps);\n          },\n          retrieveShader: function retrieveShader(t) {\n            var e = this.getFilterWindow(),\n                i = this.type + \"_\" + e;\n\n            if (!t.programCache.hasOwnProperty(i)) {\n              var r = this.generateShader(e);\n              t.programCache[i] = this.createProgram(t.context, r);\n            }\n\n            return t.programCache[i];\n          },\n          getFilterWindow: function getFilterWindow() {\n            var t = this.tempScale;\n            return Math.ceil(this.lanczosLobes / t);\n          },\n          getTaps: function getTaps() {\n            for (var t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, i = this.getFilterWindow(), r = new Array(i), n = 1; n <= i; n++) {\n              r[n - 1] = t(n * e);\n            }\n\n            return r;\n          },\n          generateShader: function generateShader(t) {\n            for (var e = new Array(t), i = this.fragmentSourceTOP, r = 1; r <= t; r++) {\n              e[r - 1] = r + \".0 * uDelta\";\n            }\n\n            return i += \"uniform float uTaps[\" + t + \"];\\n\", i += \"void main() {\\n\", i += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\", i += \"  float sum = 1.0;\\n\", e.forEach(function (t, e) {\n              i += \"  color += texture2D(uTexture, vTexCoord + \" + t + \") * uTaps[\" + e + \"];\\n\", i += \"  color += texture2D(uTexture, vTexCoord - \" + t + \") * uTaps[\" + e + \"];\\n\", i += \"  sum += 2.0 * uTaps[\" + e + \"];\\n\";\n            }), i += \"  gl_FragColor = color / sum;\\n\", i += \"}\";\n          },\n          fragmentSourceTOP: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform vec2 uDelta;\\nvarying vec2 vTexCoord;\\n\",\n          applyTo: function applyTo(t) {\n            t.webgl ? (t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceHeight = t.destinationHeight) : this.applyTo2d(t);\n          },\n          isNeutralState: function isNeutralState() {\n            return 1 === this.scaleX && 1 === this.scaleY;\n          },\n          lanczosCreate: function lanczosCreate(t) {\n            return function (e) {\n              if (t <= e || e <= -t) return 0;\n              if (e < 1.1920929e-7 && -1.1920929e-7 < e) return 1;\n              var i = (e *= Math.PI) / t;\n              return a(e) / e * a(i) / i;\n            };\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e = t.imageData,\n                i = this.scaleX,\n                r = this.scaleY;\n            this.rcpScaleX = 1 / i, this.rcpScaleY = 1 / r;\n            var n,\n                o = e.width,\n                a = e.height,\n                h = s(o * i),\n                c = s(a * r);\n            \"sliceHack\" === this.resizeType ? n = this.sliceByTwo(t, o, a, h, c) : \"hermite\" === this.resizeType ? n = this.hermiteFastResize(t, o, a, h, c) : \"bilinear\" === this.resizeType ? n = this.bilinearFiltering(t, o, a, h, c) : \"lanczos\" === this.resizeType && (n = this.lanczosResize(t, o, a, h, c)), t.imageData = n;\n          },\n          sliceByTwo: function sliceByTwo(t, i, n, o, s) {\n            var a,\n                h,\n                c = t.imageData,\n                l = !1,\n                u = !1,\n                f = .5 * i,\n                d = .5 * n,\n                g = e.filterBackend.resources,\n                p = 0,\n                v = 0,\n                m = i,\n                y = 0;\n\n            for (g.sliceByTwo || (g.sliceByTwo = document.createElement(\"canvas\")), ((a = g.sliceByTwo).width < 1.5 * i || a.height < n) && (a.width = 1.5 * i, a.height = n), (h = a.getContext(\"2d\")).clearRect(0, 0, 1.5 * i, n), h.putImageData(c, 0, 0), o = r(o), s = r(s); !l || !u;) {\n              n = d, o < r(.5 * (i = f)) ? f = r(.5 * f) : (f = o, l = !0), s < r(.5 * d) ? d = r(.5 * d) : (d = s, u = !0), h.drawImage(a, p, v, i, n, m, y, f, d), p = m, v = y, y += d;\n            }\n\n            return h.getImageData(p, v, o, s);\n          },\n          lanczosResize: function lanczosResize(t, e, s, a, c) {\n            var l = t.imageData.data,\n                u = t.ctx.createImageData(a, c),\n                f = u.data,\n                d = this.lanczosCreate(this.lanczosLobes),\n                g = this.rcpScaleX,\n                p = this.rcpScaleY,\n                v = 2 / this.rcpScaleX,\n                m = 2 / this.rcpScaleY,\n                y = h(g * this.lanczosLobes / 2),\n                _ = h(p * this.lanczosLobes / 2),\n                b = {},\n                x = {},\n                C = {};\n\n            return function t(h) {\n              var S, w, T, O, E, k, P, A, D, j, M;\n\n              for (x.x = (h + .5) * g, C.x = r(x.x), S = 0; S < c; S++) {\n                for (x.y = (S + .5) * p, C.y = r(x.y), D = A = P = k = E = 0, w = C.x - y; w <= C.x + y; w++) {\n                  if (!(w < 0 || e <= w)) {\n                    j = r(1e3 * o(w - x.x)), b[j] || (b[j] = {});\n\n                    for (var F = C.y - _; F <= C.y + _; F++) {\n                      F < 0 || s <= F || (M = r(1e3 * o(F - x.y)), b[j][M] || (b[j][M] = d(n(i(j * v, 2) + i(M * m, 2)) / 1e3)), 0 < (T = b[j][M]) && (E += T, k += T * l[O = 4 * (F * e + w)], P += T * l[O + 1], A += T * l[O + 2], D += T * l[O + 3]));\n                    }\n                  }\n                }\n\n                f[O = 4 * (S * a + h)] = k / E, f[O + 1] = P / E, f[O + 2] = A / E, f[O + 3] = D / E;\n              }\n\n              return ++h < a ? t(h) : u;\n            }(0);\n          },\n          bilinearFiltering: function bilinearFiltering(t, e, i, n, o) {\n            var s,\n                a,\n                h,\n                c,\n                l,\n                u,\n                f,\n                d,\n                g,\n                p = 0,\n                v = this.rcpScaleX,\n                m = this.rcpScaleY,\n                y = 4 * (e - 1),\n                _ = t.imageData.data,\n                b = t.ctx.createImageData(n, o),\n                x = b.data;\n\n            for (h = 0; h < o; h++) {\n              for (c = 0; c < n; c++) {\n                for (l = v * c - (s = r(v * c)), u = m * h - (a = r(m * h)), g = 4 * (a * e + s), f = 0; f < 4; f++) {\n                  d = _[g + f] * (1 - l) * (1 - u) + _[g + 4 + f] * l * (1 - u) + _[g + y + f] * u * (1 - l) + _[g + y + 4 + f] * l * u, x[p++] = d;\n                }\n              }\n            }\n\n            return b;\n          },\n          hermiteFastResize: function hermiteFastResize(t, e, i, s, a) {\n            for (var c = this.rcpScaleX, l = this.rcpScaleY, u = h(c / 2), f = h(l / 2), d = t.imageData.data, g = t.ctx.createImageData(s, a), p = g.data, v = 0; v < a; v++) {\n              for (var m = 0; m < s; m++) {\n                for (var y = 4 * (m + v * s), _ = 0, b = 0, x = 0, C = 0, S = 0, w = 0, T = 0, O = (v + .5) * l, E = r(v * l); E < (v + 1) * l; E++) {\n                  for (var k = o(O - (E + .5)) / f, P = (m + .5) * c, A = k * k, D = r(m * c); D < (m + 1) * c; D++) {\n                    var j = o(P - (D + .5)) / u,\n                        M = n(A + j * j);\n                    1 < M && M < -1 || 0 < (_ = 2 * M * M * M - 3 * M * M + 1) && (T += _ * d[3 + (j = 4 * (D + E * e))], x += _, d[j + 3] < 255 && (_ = _ * d[j + 3] / 250), C += _ * d[j], S += _ * d[j + 1], w += _ * d[j + 2], b += _);\n                  }\n                }\n\n                p[y] = C / b, p[y + 1] = S / b, p[y + 2] = w / b, p[y + 3] = T / x;\n              }\n            }\n\n            return g;\n          },\n          toObject: function toObject() {\n            return {\n              type: this.type,\n              scaleX: this.scaleX,\n              scaleY: this.scaleY,\n              resizeType: this.resizeType,\n              lanczosLobes: this.lanczosLobes\n            };\n          }\n        }), e.Image.filters.Resize.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Contrast = r(i.BaseFilter, {\n          type: \"Contrast\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uContrast;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\ngl_FragColor = color;\\n}\",\n          contrast: 0,\n          mainParameter: \"contrast\",\n          applyTo2d: function applyTo2d(t) {\n            if (0 !== this.contrast) {\n              var e,\n                  i = t.imageData.data,\n                  r = i.length,\n                  n = Math.floor(255 * this.contrast),\n                  o = 259 * (n + 255) / (255 * (259 - n));\n\n              for (e = 0; e < r; e += 4) {\n                i[e] = o * (i[e] - 128) + 128, i[e + 1] = o * (i[e + 1] - 128) + 128, i[e + 2] = o * (i[e + 2] - 128) + 128;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uContrast: t.getUniformLocation(e, \"uContrast\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1f(e.uContrast, this.contrast);\n          }\n        }), e.Image.filters.Contrast.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Saturation = r(i.BaseFilter, {\n          type: \"Saturation\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform float uSaturation;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nfloat rgMax = max(color.r, color.g);\\nfloat rgbMax = max(rgMax, color.b);\\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\ngl_FragColor = color;\\n}\",\n          saturation: 0,\n          mainParameter: \"saturation\",\n          applyTo2d: function applyTo2d(t) {\n            if (0 !== this.saturation) {\n              var e,\n                  i,\n                  r = t.imageData.data,\n                  n = r.length,\n                  o = -this.saturation;\n\n              for (e = 0; e < n; e += 4) {\n                i = Math.max(r[e], r[e + 1], r[e + 2]), r[e] += i !== r[e] ? (i - r[e]) * o : 0, r[e + 1] += i !== r[e + 1] ? (i - r[e + 1]) * o : 0, r[e + 2] += i !== r[e + 2] ? (i - r[e + 2]) * o : 0;\n              }\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uSaturation: t.getUniformLocation(e, \"uSaturation\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform1f(e.uSaturation, -this.saturation);\n          }\n        }), e.Image.filters.Saturation.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Blur = r(i.BaseFilter, {\n          type: \"Blur\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform vec2 uDelta;\\nvarying vec2 vTexCoord;\\nconst float nSamples = 15.0;\\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\nfloat random(vec3 scale) {\\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n}\\nvoid main() {\\nvec4 color = vec4(0.0);\\nfloat total = 0.0;\\nfloat offset = random(v3offset);\\nfor (float t = -nSamples; t <= nSamples; t++) {\\nfloat percent = (t + offset - 0.5) / nSamples;\\nfloat weight = 1.0 - abs(percent);\\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\ntotal += weight;\\n}\\ngl_FragColor = color / total;\\n}\",\n          blur: 0,\n          mainParameter: \"blur\",\n          applyTo: function applyTo(t) {\n            t.webgl ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);\n          },\n          applyTo2d: function applyTo2d(t) {\n            t.imageData = this.simpleBlur(t);\n          },\n          simpleBlur: function simpleBlur(t) {\n            var i,\n                r,\n                n = t.filterBackend.resources,\n                o = t.imageData.width,\n                s = t.imageData.height;\n            n.blurLayer1 || (n.blurLayer1 = e.util.createCanvasElement(), n.blurLayer2 = e.util.createCanvasElement()), i = n.blurLayer1, r = n.blurLayer2, i.width === o && i.height === s || (r.width = i.width = o, r.height = i.height = s);\n            var a,\n                h,\n                c,\n                l,\n                u = i.getContext(\"2d\"),\n                f = r.getContext(\"2d\"),\n                d = .06 * this.blur * .5;\n\n            for (u.putImageData(t.imageData, 0, 0), f.clearRect(0, 0, o, s), l = -15; l <= 15; l++) {\n              c = d * (h = l / 15) * o + (a = (Math.random() - .5) / 4), f.globalAlpha = 1 - Math.abs(h), f.drawImage(i, c, a), u.drawImage(r, 0, 0), f.globalAlpha = 1, f.clearRect(0, 0, r.width, r.height);\n            }\n\n            for (l = -15; l <= 15; l++) {\n              c = d * (h = l / 15) * s + (a = (Math.random() - .5) / 4), f.globalAlpha = 1 - Math.abs(h), f.drawImage(i, a, c), u.drawImage(r, 0, 0), f.globalAlpha = 1, f.clearRect(0, 0, r.width, r.height);\n            }\n\n            t.ctx.drawImage(i, 0, 0);\n            var g = t.ctx.getImageData(0, 0, i.width, i.height);\n            return u.globalAlpha = 1, u.clearRect(0, 0, i.width, i.height), g;\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              delta: t.getUniformLocation(e, \"uDelta\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            var i = this.chooseRightDelta();\n            t.uniform2fv(e.delta, i);\n          },\n          chooseRightDelta: function chooseRightDelta() {\n            var t,\n                e = 1,\n                i = [0, 0];\n            return this.horizontal ? 1 < this.aspectRatio && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio), t = e * this.blur * .12, this.horizontal ? i[0] = t : i[1] = t, i;\n          }\n        }), i.Blur.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Gamma = r(i.BaseFilter, {\n          type: \"Gamma\",\n          fragmentSource: \"precision highp float;\\nuniform sampler2D uTexture;\\nuniform vec3 uGamma;\\nvarying vec2 vTexCoord;\\nvoid main() {\\nvec4 color = texture2D(uTexture, vTexCoord);\\nvec3 correction = (1.0 / uGamma);\\ncolor.r = pow(color.r, correction.r);\\ncolor.g = pow(color.g, correction.g);\\ncolor.b = pow(color.b, correction.b);\\ngl_FragColor = color;\\ngl_FragColor.rgb *= color.a;\\n}\",\n          gamma: [1, 1, 1],\n          mainParameter: \"gamma\",\n          initialize: function initialize(t) {\n            this.gamma = [1, 1, 1], i.BaseFilter.prototype.initialize.call(this, t);\n          },\n          applyTo2d: function applyTo2d(t) {\n            var e,\n                i = t.imageData.data,\n                r = this.gamma,\n                n = i.length,\n                o = 1 / r[0],\n                s = 1 / r[1],\n                a = 1 / r[2];\n\n            for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), e = 0, n = 256; e < n; e++) {\n              this.rVals[e] = 255 * Math.pow(e / 255, o), this.gVals[e] = 255 * Math.pow(e / 255, s), this.bVals[e] = 255 * Math.pow(e / 255, a);\n            }\n\n            for (e = 0, n = i.length; e < n; e += 4) {\n              i[e] = this.rVals[i[e]], i[e + 1] = this.gVals[i[e + 1]], i[e + 2] = this.bVals[i[e + 2]];\n            }\n          },\n          getUniformLocations: function getUniformLocations(t, e) {\n            return {\n              uGamma: t.getUniformLocation(e, \"uGamma\")\n            };\n          },\n          sendUniformData: function sendUniformData(t, e) {\n            t.uniform3fv(e.uGamma, this.gamma);\n          }\n        }), e.Image.filters.Gamma.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.Composed = r(i.BaseFilter, {\n          type: \"Composed\",\n          subFilters: [],\n          initialize: function initialize(t) {\n            this.callSuper(\"initialize\", t), this.subFilters = this.subFilters.slice(0);\n          },\n          applyTo: function applyTo(t) {\n            t.passes += this.subFilters.length - 1, this.subFilters.forEach(function (e) {\n              e.applyTo(t);\n            });\n          },\n          toObject: function toObject() {\n            return e.util.object.extend(this.callSuper(\"toObject\"), {\n              subFilters: this.subFilters.map(function (t) {\n                return t.toObject();\n              })\n            });\n          },\n          isNeutralState: function isNeutralState() {\n            return !this.subFilters.some(function (t) {\n              return !t.isNeutralState();\n            });\n          }\n        }), e.Image.filters.Composed.fromObject = function (t, i) {\n          var r = (t.subFilters || []).map(function (t) {\n            return new e.Image.filters[t.type](t);\n          }),\n              n = new e.Image.filters.Composed({\n            subFilters: r\n          });\n          return i && i(n), n;\n        };\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.Image.filters,\n            r = e.util.createClass;\n        i.HueRotation = r(i.ColorMatrix, {\n          type: \"HueRotation\",\n          rotation: 0,\n          mainParameter: \"rotation\",\n          calculateMatrix: function calculateMatrix() {\n            var t = this.rotation * Math.PI,\n                i = e.util.cos(t),\n                r = e.util.sin(t),\n                n = Math.sqrt(1 / 3) * r,\n                o = 1 - i;\n            this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = i + o / 3, this.matrix[1] = 1 / 3 * o - n, this.matrix[2] = 1 / 3 * o + n, this.matrix[5] = 1 / 3 * o + n, this.matrix[6] = i + 1 / 3 * o, this.matrix[7] = 1 / 3 * o - n, this.matrix[10] = 1 / 3 * o - n, this.matrix[11] = 1 / 3 * o + n, this.matrix[12] = i + 1 / 3 * o;\n          },\n          isNeutralState: function isNeutralState(t) {\n            return this.calculateMatrix(), i.BaseFilter.prototype.isNeutralState.call(this, t);\n          },\n          applyTo: function applyTo(t) {\n            this.calculateMatrix(), i.BaseFilter.prototype.applyTo.call(this, t);\n          }\n        }), e.Image.filters.HueRotation.fromObject = e.Image.filters.BaseFilter.fromObject;\n      }(e), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {}),\n            i = e.util.object.clone;\n        e.Text ? e.warn(\"fabric.Text is already defined\") : (e.Text = e.util.createClass(e.Object, {\n          _dimensionAffectingProps: [\"fontSize\", \"fontWeight\", \"fontFamily\", \"fontStyle\", \"lineHeight\", \"text\", \"charSpacing\", \"textAlign\", \"styles\"],\n          _reNewline: /\\r?\\n/,\n          _reSpacesAndTabs: /[ \\t\\r]/g,\n          _reSpaceAndTab: /[ \\t\\r]/,\n          _reWords: /\\S+/g,\n          type: \"text\",\n          fontSize: 40,\n          fontWeight: \"normal\",\n          fontFamily: \"Times New Roman\",\n          underline: !1,\n          overline: !1,\n          linethrough: !1,\n          textAlign: \"left\",\n          fontStyle: \"normal\",\n          lineHeight: 1.16,\n          superscript: {\n            size: .6,\n            baseline: -.35\n          },\n          subscript: {\n            size: .6,\n            baseline: .11\n          },\n          textBackgroundColor: \"\",\n          stateProperties: e.Object.prototype.stateProperties.concat(\"fontFamily\", \"fontWeight\", \"fontSize\", \"text\", \"underline\", \"overline\", \"linethrough\", \"textAlign\", \"fontStyle\", \"lineHeight\", \"textBackgroundColor\", \"charSpacing\", \"styles\"),\n          cacheProperties: e.Object.prototype.cacheProperties.concat(\"fontFamily\", \"fontWeight\", \"fontSize\", \"text\", \"underline\", \"overline\", \"linethrough\", \"textAlign\", \"fontStyle\", \"lineHeight\", \"textBackgroundColor\", \"charSpacing\", \"styles\"),\n          stroke: null,\n          shadow: null,\n          _fontSizeFraction: .222,\n          offsets: {\n            underline: .1,\n            linethrough: -.315,\n            overline: -.88\n          },\n          _fontSizeMult: 1.13,\n          charSpacing: 0,\n          styles: null,\n          _measuringContext: null,\n          deltaY: 0,\n          _styleProperties: [\"stroke\", \"strokeWidth\", \"fill\", \"fontFamily\", \"fontSize\", \"fontWeight\", \"fontStyle\", \"underline\", \"overline\", \"linethrough\", \"deltaY\", \"textBackgroundColor\"],\n          __charBounds: [],\n          CACHE_FONT_SIZE: 400,\n          MIN_TEXT_WIDTH: 2,\n          initialize: function initialize(t, e) {\n            this.styles = e && e.styles || {}, this.text = t, this.__skipDimension = !0, this.callSuper(\"initialize\", e), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({\n              propertySet: \"_dimensionAffectingProps\"\n            });\n          },\n          getMeasuringContext: function getMeasuringContext() {\n            return e._measuringContext || (e._measuringContext = this.canvas && this.canvas.contextCache || e.util.createCanvasElement().getContext(\"2d\")), e._measuringContext;\n          },\n          _splitText: function _splitText() {\n            var t = this._splitTextIntoLines(this.text);\n\n            return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t;\n          },\n          initDimensions: function initDimensions() {\n            this.__skipDimension || (this._splitText(), this._clearCache(), this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, -1 !== this.textAlign.indexOf(\"justify\") && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({\n              propertySet: \"_dimensionAffectingProps\"\n            }));\n          },\n          enlargeSpaces: function enlargeSpaces() {\n            for (var t, e, i, r, n, o, s, a = 0, h = this._textLines.length; a < h; a++) {\n              if ((\"justify\" === this.textAlign || a !== h - 1 && !this.isEndOfWrapping(a)) && (r = 0, n = this._textLines[a], (e = this.getLineWidth(a)) < this.width && (s = this.textLines[a].match(this._reSpacesAndTabs)))) {\n                i = s.length, t = (this.width - e) / i;\n\n                for (var c = 0, l = n.length; c <= l; c++) {\n                  o = this.__charBounds[a][c], this._reSpaceAndTab.test(n[c]) ? (o.width += t, o.kernedWidth += t, o.left += r, r += t) : o.left += r;\n                }\n              }\n            }\n          },\n          isEndOfWrapping: function isEndOfWrapping(t) {\n            return t === this._textLines.length - 1;\n          },\n          toString: function toString() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n          },\n          _getCacheCanvasDimensions: function _getCacheCanvasDimensions() {\n            var t = this.callSuper(\"_getCacheCanvasDimensions\"),\n                e = this.fontSize;\n            return t.width += e * t.zoomX, t.height += e * t.zoomY, t;\n          },\n          _render: function _render(t) {\n            this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, \"underline\"), this._renderText(t), this._renderTextDecoration(t, \"overline\"), this._renderTextDecoration(t, \"linethrough\");\n          },\n          _renderText: function _renderText(t) {\n            \"stroke\" === this.paintFirst ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t));\n          },\n          _setTextStyles: function _setTextStyles(t, e, i) {\n            t.textBaseline = \"alphabetic\", t.font = this._getFontDeclaration(e, i);\n          },\n          calcTextWidth: function calcTextWidth() {\n            for (var t = this.getLineWidth(0), e = 1, i = this._textLines.length; e < i; e++) {\n              var r = this.getLineWidth(e);\n              t < r && (t = r);\n            }\n\n            return t;\n          },\n          _renderTextLine: function _renderTextLine(t, e, i, r, n, o) {\n            this._renderChars(t, e, i, r, n, o);\n          },\n          _renderTextLinesBackground: function _renderTextLinesBackground(t) {\n            if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\")) {\n              for (var e, i, r, n, o, s, a = 0, h = t.fillStyle, c = this._getLeftOffset(), l = this._getTopOffset(), u = 0, f = 0, d = 0, g = this._textLines.length; d < g; d++) {\n                if (e = this.getHeightOfLine(d), this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", d)) {\n                  r = this._textLines[d], i = this._getLineLeftOffset(d), u = f = 0, n = this.getValueOfPropertyAt(d, 0, \"textBackgroundColor\");\n\n                  for (var p = 0, v = r.length; p < v; p++) {\n                    o = this.__charBounds[d][p], (s = this.getValueOfPropertyAt(d, p, \"textBackgroundColor\")) !== n ? ((t.fillStyle = n) && t.fillRect(c + i + u, l + a, f, e / this.lineHeight), u = o.left, f = o.width, n = s) : f += o.kernedWidth;\n                  }\n\n                  s && (t.fillStyle = s, t.fillRect(c + i + u, l + a, f, e / this.lineHeight)), a += e;\n                } else a += e;\n              }\n\n              t.fillStyle = h, this._removeShadow(t);\n            }\n          },\n          getFontCache: function getFontCache(t) {\n            var i = t.fontFamily.toLowerCase();\n            e.charWidthsCache[i] || (e.charWidthsCache[i] = {});\n            var r = e.charWidthsCache[i],\n                n = t.fontStyle.toLowerCase() + \"_\" + (t.fontWeight + \"\").toLowerCase();\n            return r[n] || (r[n] = {}), r[n];\n          },\n          _applyCharStyles: function _applyCharStyles(t, e, i, r, n) {\n            this._setFillStyles(e, n), this._setStrokeStyles(e, n), e.font = this._getFontDeclaration(n);\n          },\n          _measureChar: function _measureChar(t, e, i, r) {\n            var n,\n                o,\n                s,\n                a,\n                h = this.getFontCache(e),\n                c = i + t,\n                l = this._getFontDeclaration(e) === this._getFontDeclaration(r),\n                u = e.fontSize / this.CACHE_FONT_SIZE;\n\n            if (i && void 0 !== h[i] && (s = h[i]), void 0 !== h[t] && (a = n = h[t]), l && void 0 !== h[c] && (a = (o = h[c]) - s), void 0 === n || void 0 === s || void 0 === o) {\n              var f = this.getMeasuringContext();\n\n              this._setTextStyles(f, e, !0);\n            }\n\n            return void 0 === n && (a = n = f.measureText(t).width, h[t] = n), void 0 === s && l && i && (s = f.measureText(i).width, h[i] = s), l && void 0 === o && (o = f.measureText(c).width, a = (h[c] = o) - s), {\n              width: n * u,\n              kernedWidth: a * u\n            };\n          },\n          getHeightOfChar: function getHeightOfChar(t, e) {\n            return this.getValueOfPropertyAt(t, e, \"fontSize\");\n          },\n          measureLine: function measureLine(t) {\n            var e = this._measureLine(t);\n\n            return 0 !== this.charSpacing && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e;\n          },\n          _measureLine: function _measureLine(t) {\n            var e,\n                i,\n                r,\n                n,\n                o = 0,\n                s = this._textLines[t],\n                a = new Array(s.length);\n\n            for (this.__charBounds[t] = a, e = 0; e < s.length; e++) {\n              i = s[e], n = this._getGraphemeBox(i, t, e, r), o += (a[e] = n).kernedWidth, r = i;\n            }\n\n            return a[e] = {\n              left: n ? n.left + n.width : 0,\n              width: 0,\n              kernedWidth: 0,\n              height: this.fontSize\n            }, {\n              width: o,\n              numOfSpaces: 0\n            };\n          },\n          _getGraphemeBox: function _getGraphemeBox(t, e, i, r, n) {\n            var o,\n                s = this.getCompleteStyleDeclaration(e, i),\n                a = r ? this.getCompleteStyleDeclaration(e, i - 1) : {},\n                h = this._measureChar(t, s, r, a),\n                c = h.kernedWidth,\n                l = h.width;\n\n            0 !== this.charSpacing && (l += o = this._getWidthOfCharSpacing(), c += o);\n            var u = {\n              width: l,\n              left: 0,\n              height: s.fontSize,\n              kernedWidth: c,\n              deltaY: s.deltaY\n            };\n\n            if (0 < i && !n) {\n              var f = this.__charBounds[e][i - 1];\n              u.left = f.left + f.width + h.kernedWidth - h.width;\n            }\n\n            return u;\n          },\n          getHeightOfLine: function getHeightOfLine(t) {\n            if (this.__lineHeights[t]) return this.__lineHeights[t];\n\n            for (var e = this._textLines[t], i = this.getHeightOfChar(t, 0), r = 1, n = e.length; r < n; r++) {\n              i = Math.max(this.getHeightOfChar(t, r), i);\n            }\n\n            return this.__lineHeights[t] = i * this.lineHeight * this._fontSizeMult;\n          },\n          calcTextHeight: function calcTextHeight() {\n            for (var t, e = 0, i = 0, r = this._textLines.length; i < r; i++) {\n              t = this.getHeightOfLine(i), e += i === r - 1 ? t / this.lineHeight : t;\n            }\n\n            return e;\n          },\n          _getLeftOffset: function _getLeftOffset() {\n            return -this.width / 2;\n          },\n          _getTopOffset: function _getTopOffset() {\n            return -this.height / 2;\n          },\n          _renderTextCommon: function _renderTextCommon(t, e) {\n            t.save();\n\n            for (var i = 0, r = this._getLeftOffset(), n = this._getTopOffset(), o = this._applyPatternGradientTransform(t, \"fillText\" === e ? this.fill : this.stroke), s = 0, a = this._textLines.length; s < a; s++) {\n              var h = this.getHeightOfLine(s),\n                  c = h / this.lineHeight,\n                  l = this._getLineLeftOffset(s);\n\n              this._renderTextLine(e, t, this._textLines[s], r + l - o.offsetX, n + i + c - o.offsetY, s), i += h;\n            }\n\n            t.restore();\n          },\n          _renderTextFill: function _renderTextFill(t) {\n            (this.fill || this.styleHas(\"fill\")) && this._renderTextCommon(t, \"fillText\");\n          },\n          _renderTextStroke: function _renderTextStroke(t) {\n            (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, \"strokeText\"), t.closePath(), t.restore());\n          },\n          _renderChars: function _renderChars(t, e, i, r, n, o) {\n            var s,\n                a,\n                h,\n                c,\n                l = this.getHeightOfLine(o),\n                u = -1 !== this.textAlign.indexOf(\"justify\"),\n                f = \"\",\n                d = 0,\n                g = !u && 0 === this.charSpacing && this.isEmptyStyles(o);\n            if (e.save(), n -= l * this._fontSizeFraction / this.lineHeight, g) return this._renderChar(t, e, o, 0, this.textLines[o], r, n, l), void e.restore();\n\n            for (var p = 0, v = i.length - 1; p <= v; p++) {\n              c = p === v || this.charSpacing, f += i[p], h = this.__charBounds[o][p], 0 === d ? (r += h.kernedWidth - h.width, d += h.width) : d += h.kernedWidth, u && !c && this._reSpaceAndTab.test(i[p]) && (c = !0), c || (s = s || this.getCompleteStyleDeclaration(o, p), a = this.getCompleteStyleDeclaration(o, p + 1), c = this._hasStyleChanged(s, a)), c && (this._renderChar(t, e, o, p, f, r, n, l), f = \"\", s = a, r += d, d = 0);\n            }\n\n            e.restore();\n          },\n          _renderChar: function _renderChar(t, e, i, r, n, o, s) {\n            var a = this._getStyleDeclaration(i, r),\n                h = this.getCompleteStyleDeclaration(i, r),\n                c = \"fillText\" === t && h.fill,\n                l = \"strokeText\" === t && h.stroke && h.strokeWidth;\n\n            (l || c) && (a && e.save(), this._applyCharStyles(t, e, i, r, h), a && a.textBackgroundColor && this._removeShadow(e), a && a.deltaY && (s += a.deltaY), c && e.fillText(n, o, s), l && e.strokeText(n, o, s), a && e.restore());\n          },\n          setSuperscript: function setSuperscript(t, e) {\n            return this._setScript(t, e, this.superscript);\n          },\n          setSubscript: function setSubscript(t, e) {\n            return this._setScript(t, e, this.subscript);\n          },\n          _setScript: function _setScript(t, e, i) {\n            var r = this.get2DCursorLocation(t, !0),\n                n = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, \"fontSize\"),\n                o = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, \"deltaY\"),\n                s = {\n              fontSize: n * i.size,\n              deltaY: o + n * i.baseline\n            };\n            return this.setSelectionStyles(s, t, e), this;\n          },\n          _hasStyleChanged: function _hasStyleChanged(t, e) {\n            return t.fill !== e.fill || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fontSize !== e.fontSize || t.fontFamily !== e.fontFamily || t.fontWeight !== e.fontWeight || t.fontStyle !== e.fontStyle || t.deltaY !== e.deltaY;\n          },\n          _hasStyleChangedForSvg: function _hasStyleChangedForSvg(t, e) {\n            return this._hasStyleChanged(t, e) || t.overline !== e.overline || t.underline !== e.underline || t.linethrough !== e.linethrough;\n          },\n          _getLineLeftOffset: function _getLineLeftOffset(t) {\n            var e = this.getLineWidth(t);\n            return \"center\" === this.textAlign ? (this.width - e) / 2 : \"right\" === this.textAlign ? this.width - e : \"justify-center\" === this.textAlign && this.isEndOfWrapping(t) ? (this.width - e) / 2 : \"justify-right\" === this.textAlign && this.isEndOfWrapping(t) ? this.width - e : 0;\n          },\n          _clearCache: function _clearCache() {\n            this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];\n          },\n          _shouldClearDimensionCache: function _shouldClearDimensionCache() {\n            var t = this._forceClearCache;\n            return t || (t = this.hasStateChanged(\"_dimensionAffectingProps\")), t && (this.dirty = !0, this._forceClearCache = !1), t;\n          },\n          getLineWidth: function getLineWidth(t) {\n            return this.__lineWidths[t] ? this.__lineWidths[t] : (e = \"\" === this._textLines[t] ? 0 : this.measureLine(t).width, this.__lineWidths[t] = e);\n            var e;\n          },\n          _getWidthOfCharSpacing: function _getWidthOfCharSpacing() {\n            return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0;\n          },\n          getValueOfPropertyAt: function getValueOfPropertyAt(t, e, i) {\n            var r = this._getStyleDeclaration(t, e);\n\n            return r && void 0 !== r[i] ? r[i] : this[i];\n          },\n          _renderTextDecoration: function _renderTextDecoration(t, e) {\n            if (this[e] || this.styleHas(e)) {\n              for (var i, r, n, o, s, a, h, c, l, u, f, d, g, p, v, m, y = this._getLeftOffset(), _ = this._getTopOffset(), b = this._getWidthOfCharSpacing(), x = 0, C = this._textLines.length; x < C; x++) {\n                if (i = this.getHeightOfLine(x), this[e] || this.styleHas(e, x)) {\n                  h = this._textLines[x], p = i / this.lineHeight, o = this._getLineLeftOffset(x), f = u = 0, c = this.getValueOfPropertyAt(x, 0, e), m = this.getValueOfPropertyAt(x, 0, \"fill\"), l = _ + p * (1 - this._fontSizeFraction), r = this.getHeightOfChar(x, 0), s = this.getValueOfPropertyAt(x, 0, \"deltaY\");\n\n                  for (var S = 0, w = h.length; S < w; S++) {\n                    d = this.__charBounds[x][S], g = this.getValueOfPropertyAt(x, S, e), v = this.getValueOfPropertyAt(x, S, \"fill\"), n = this.getHeightOfChar(x, S), a = this.getValueOfPropertyAt(x, S, \"deltaY\"), (g !== c || v !== m || n !== r || a !== s) && 0 < f ? (t.fillStyle = m, c && m && t.fillRect(y + o + u, l + this.offsets[e] * r + s, f, this.fontSize / 15), u = d.left, f = d.width, c = g, m = v, r = n, s = a) : f += d.kernedWidth;\n                  }\n\n                  t.fillStyle = v, g && v && t.fillRect(y + o + u, l + this.offsets[e] * r + s, f - b, this.fontSize / 15), _ += i;\n                } else _ += i;\n              }\n\n              this._removeShadow(t);\n            }\n          },\n          _getFontDeclaration: function _getFontDeclaration(t, i) {\n            var r = t || this,\n                n = this.fontFamily,\n                o = -1 < e.Text.genericFonts.indexOf(n.toLowerCase()),\n                s = void 0 === n || -1 < n.indexOf(\"'\") || -1 < n.indexOf('\"') || o ? r.fontFamily : '\"' + r.fontFamily + '\"';\n            return [e.isLikelyNode ? r.fontWeight : r.fontStyle, e.isLikelyNode ? r.fontStyle : r.fontWeight, i ? this.CACHE_FONT_SIZE + \"px\" : r.fontSize + \"px\", s].join(\" \");\n          },\n          render: function render(t) {\n            this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper(\"render\", t)));\n          },\n          _splitTextIntoLines: function _splitTextIntoLines(t) {\n            for (var i = t.split(this._reNewline), r = new Array(i.length), n = [\"\\n\"], o = [], s = 0; s < i.length; s++) {\n              r[s] = e.util.string.graphemeSplit(i[s]), o = o.concat(r[s], n);\n            }\n\n            return o.pop(), {\n              _unwrappedLines: r,\n              lines: i,\n              graphemeText: o,\n              graphemeLines: r\n            };\n          },\n          toObject: function toObject(t) {\n            var e = [\"text\", \"fontSize\", \"fontWeight\", \"fontFamily\", \"fontStyle\", \"lineHeight\", \"underline\", \"overline\", \"linethrough\", \"textAlign\", \"textBackgroundColor\", \"charSpacing\"].concat(t),\n                r = this.callSuper(\"toObject\", e);\n            return r.styles = i(this.styles, !0), r;\n          },\n          set: function set(t, e) {\n            this.callSuper(\"set\", t, e);\n            var i = !1;\n            if (\"object\" == typeof t) for (var r in t) {\n              i = i || -1 !== this._dimensionAffectingProps.indexOf(r);\n            } else i = -1 !== this._dimensionAffectingProps.indexOf(t);\n            return i && (this.initDimensions(), this.setCoords()), this;\n          },\n          complexity: function complexity() {\n            return 1;\n          }\n        }), e.Text.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \")), e.Text.DEFAULT_SVG_FONT_SIZE = 16, e.Text.fromElement = function (t, r, n) {\n          if (!t) return r(null);\n          var o = e.parseAttributes(t, e.Text.ATTRIBUTE_NAMES),\n              s = o.textAnchor || \"left\";\n\n          if ((n = e.util.object.extend(n ? i(n) : {}, o)).top = n.top || 0, n.left = n.left || 0, o.textDecoration) {\n            var a = o.textDecoration;\n            -1 !== a.indexOf(\"underline\") && (n.underline = !0), -1 !== a.indexOf(\"overline\") && (n.overline = !0), -1 !== a.indexOf(\"line-through\") && (n.linethrough = !0), delete n.textDecoration;\n          }\n\n          \"dx\" in o && (n.left += o.dx), \"dy\" in o && (n.top += o.dy), \"fontSize\" in n || (n.fontSize = e.Text.DEFAULT_SVG_FONT_SIZE);\n          var h = \"\";\n          \"textContent\" in t ? h = t.textContent : \"firstChild\" in t && null !== t.firstChild && \"data\" in t.firstChild && null !== t.firstChild.data && (h = t.firstChild.data), h = h.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n          var c = n.strokeWidth;\n          n.strokeWidth = 0;\n          var l = new e.Text(h, n),\n              u = l.getScaledHeight() / l.height,\n              f = ((l.height + l.strokeWidth) * l.lineHeight - l.height) * u,\n              d = l.getScaledHeight() + f,\n              g = 0;\n          \"center\" === s && (g = l.getScaledWidth() / 2), \"right\" === s && (g = l.getScaledWidth()), l.set({\n            left: l.left - g,\n            top: l.top - (d - l.fontSize * (.07 + l._fontSizeFraction)) / l.lineHeight,\n            strokeWidth: void 0 !== c ? c : 1\n          }), r(l);\n        }, e.Text.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Text\", t, i, \"text\");\n        }, e.Text.genericFonts = [\"sans-serif\", \"serif\", \"cursive\", \"fantasy\", \"monospace\"], e.util.createAccessors && e.util.createAccessors(e.Text));\n      }(e), A.util.object.extend(A.Text.prototype, {\n        isEmptyStyles: function isEmptyStyles(t) {\n          if (!this.styles) return !0;\n          if (void 0 !== t && !this.styles[t]) return !0;\n          var e = void 0 === t ? this.styles : {\n            line: this.styles[t]\n          };\n\n          for (var i in e) {\n            for (var r in e[i]) {\n              for (var n in e[i][r]) {\n                return !1;\n              }\n            }\n          }\n\n          return !0;\n        },\n        styleHas: function styleHas(t, e) {\n          if (!this.styles || !t || \"\" === t) return !1;\n          if (void 0 !== e && !this.styles[e]) return !1;\n          var i = void 0 === e ? this.styles : {\n            line: this.styles[e]\n          };\n\n          for (var r in i) {\n            for (var n in i[r]) {\n              if (void 0 !== i[r][n][t]) return !0;\n            }\n          }\n\n          return !1;\n        },\n        cleanStyle: function cleanStyle(t) {\n          if (!this.styles || !t || \"\" === t) return !1;\n          var e,\n              i,\n              r = this.styles,\n              n = 0,\n              o = !0,\n              s = 0;\n\n          for (var a in r) {\n            for (var h in e = 0, r[a]) {\n              var c;\n              n++, (c = r[a][h]).hasOwnProperty(t) ? (i ? c[t] !== i && (o = !1) : i = c[t], c[t] === this[t] && delete c[t]) : o = !1, 0 !== Object.keys(c).length ? e++ : delete r[a][h];\n            }\n\n            0 === e && delete r[a];\n          }\n\n          for (var l = 0; l < this._textLines.length; l++) {\n            s += this._textLines[l].length;\n          }\n\n          o && n === s && (this[t] = i, this.removeStyle(t));\n        },\n        removeStyle: function removeStyle(t) {\n          if (this.styles && t && \"\" !== t) {\n            var e,\n                i,\n                r,\n                n = this.styles;\n\n            for (i in n) {\n              for (r in e = n[i]) {\n                delete e[r][t], 0 === Object.keys(e[r]).length && delete e[r];\n              }\n\n              0 === Object.keys(e).length && delete n[i];\n            }\n          }\n        },\n        _extendStyles: function _extendStyles(t, e) {\n          var i = this.get2DCursorLocation(t);\n          this._getLineStyle(i.lineIndex) || this._setLineStyle(i.lineIndex, {}), this._getStyleDeclaration(i.lineIndex, i.charIndex) || this._setStyleDeclaration(i.lineIndex, i.charIndex, {}), A.util.object.extend(this._getStyleDeclaration(i.lineIndex, i.charIndex), e);\n        },\n        get2DCursorLocation: function get2DCursorLocation(t, e) {\n          void 0 === t && (t = this.selectionStart);\n\n          for (var i = e ? this._unwrappedTextLines : this._textLines, r = i.length, n = 0; n < r; n++) {\n            if (t <= i[n].length) return {\n              lineIndex: n,\n              charIndex: t\n            };\n            t -= i[n].length + 1;\n          }\n\n          return {\n            lineIndex: n - 1,\n            charIndex: i[n - 1].length < t ? i[n - 1].length : t\n          };\n        },\n        getSelectionStyles: function getSelectionStyles(t, e, i) {\n          void 0 === t && (t = this.selectionStart || 0), void 0 === e && (e = this.selectionEnd || t);\n\n          for (var r = [], n = t; n < e; n++) {\n            r.push(this.getStyleAtPosition(n, i));\n          }\n\n          return r;\n        },\n        getStyleAtPosition: function getStyleAtPosition(t, e) {\n          var i = this.get2DCursorLocation(t);\n          return (e ? this.getCompleteStyleDeclaration(i.lineIndex, i.charIndex) : this._getStyleDeclaration(i.lineIndex, i.charIndex)) || {};\n        },\n        setSelectionStyles: function setSelectionStyles(t, e, i) {\n          void 0 === e && (e = this.selectionStart || 0), void 0 === i && (i = this.selectionEnd || e);\n\n          for (var r = e; r < i; r++) {\n            this._extendStyles(r, t);\n          }\n\n          return this._forceClearCache = !0, this;\n        },\n        _getStyleDeclaration: function _getStyleDeclaration(t, e) {\n          var i = this.styles && this.styles[t];\n          return i ? i[e] : null;\n        },\n        getCompleteStyleDeclaration: function getCompleteStyleDeclaration(t, e) {\n          for (var i, r = this._getStyleDeclaration(t, e) || {}, n = {}, o = 0; o < this._styleProperties.length; o++) {\n            n[i = this._styleProperties[o]] = void 0 === r[i] ? this[i] : r[i];\n          }\n\n          return n;\n        },\n        _setStyleDeclaration: function _setStyleDeclaration(t, e, i) {\n          this.styles[t][e] = i;\n        },\n        _deleteStyleDeclaration: function _deleteStyleDeclaration(t, e) {\n          delete this.styles[t][e];\n        },\n        _getLineStyle: function _getLineStyle(t) {\n          return this.styles[t];\n        },\n        _setLineStyle: function _setLineStyle(t, e) {\n          this.styles[t] = e;\n        },\n        _deleteLineStyle: function _deleteLineStyle(t) {\n          delete this.styles[t];\n        }\n      }), function () {\n        function t(t) {\n          t.textDecoration && (-1 < t.textDecoration.indexOf(\"underline\") && (t.underline = !0), -1 < t.textDecoration.indexOf(\"line-through\") && (t.linethrough = !0), -1 < t.textDecoration.indexOf(\"overline\") && (t.overline = !0), delete t.textDecoration);\n        }\n\n        A.IText = A.util.createClass(A.Text, A.Observable, {\n          type: \"i-text\",\n          selectionStart: 0,\n          selectionEnd: 0,\n          selectionColor: \"rgba(17,119,255,0.3)\",\n          isEditing: !1,\n          editable: !0,\n          editingBorderColor: \"rgba(102,153,255,0.25)\",\n          cursorWidth: 2,\n          cursorColor: \"#333\",\n          cursorDelay: 1e3,\n          cursorDuration: 600,\n          caching: !0,\n          _reSpace: /\\s|\\n/,\n          _currentCursorOpacity: 0,\n          _selectionDirection: null,\n          _abortCursorAnimation: !1,\n          __widthOfSpace: [],\n          inCompositionMode: !1,\n          initialize: function initialize(t, e) {\n            this.callSuper(\"initialize\", t, e), this.initBehavior();\n          },\n          setSelectionStart: function setSelectionStart(t) {\n            t = Math.max(t, 0), this._updateAndFire(\"selectionStart\", t);\n          },\n          setSelectionEnd: function setSelectionEnd(t) {\n            t = Math.min(t, this.text.length), this._updateAndFire(\"selectionEnd\", t);\n          },\n          _updateAndFire: function _updateAndFire(t, e) {\n            this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea();\n          },\n          _fireSelectionChanged: function _fireSelectionChanged() {\n            this.fire(\"selection:changed\"), this.canvas && this.canvas.fire(\"text:selection:changed\", {\n              target: this\n            });\n          },\n          initDimensions: function initDimensions() {\n            this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper(\"initDimensions\");\n          },\n          render: function render(t) {\n            this.clearContextTop(), this.callSuper(\"render\", t), this.cursorOffsetCache = {}, this.renderCursorOrSelection();\n          },\n          _render: function _render(t) {\n            this.callSuper(\"_render\", t);\n          },\n          clearContextTop: function clearContextTop(t) {\n            if (this.isEditing && this.canvas && this.canvas.contextTop) {\n              var e = this.canvas.contextTop,\n                  i = this.canvas.viewportTransform;\n              e.save(), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this.transform(e), this.transformMatrix && e.transform.apply(e, this.transformMatrix), this._clearTextArea(e), t || e.restore();\n            }\n          },\n          renderCursorOrSelection: function renderCursorOrSelection() {\n            if (this.isEditing && this.canvas) {\n              var t,\n                  e = this._getCursorBoundaries();\n\n              this.canvas && this.canvas.contextTop ? (t = this.canvas.contextTop, this.clearContextTop(!0)) : (t = this.canvas.contextContainer).save(), this.selectionStart === this.selectionEnd ? this.renderCursor(e, t) : this.renderSelection(e, t), t.restore();\n            }\n          },\n          _clearTextArea: function _clearTextArea(t) {\n            var e = this.width + 4,\n                i = this.height + 4;\n            t.clearRect(-e / 2, -i / 2, e, i);\n          },\n          _getCursorBoundaries: function _getCursorBoundaries(t) {\n            void 0 === t && (t = this.selectionStart);\n\n            var e = this._getLeftOffset(),\n                i = this._getTopOffset(),\n                r = this._getCursorBoundariesOffsets(t);\n\n            return {\n              left: e,\n              top: i,\n              leftOffset: r.left,\n              topOffset: r.top\n            };\n          },\n          _getCursorBoundariesOffsets: function _getCursorBoundariesOffsets(t) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) return this.cursorOffsetCache;\n            var e,\n                i,\n                r,\n                n,\n                o = 0,\n                s = 0,\n                a = this.get2DCursorLocation(t);\n            r = a.charIndex, i = a.lineIndex;\n\n            for (var h = 0; h < i; h++) {\n              o += this.getHeightOfLine(h);\n            }\n\n            e = this._getLineLeftOffset(i);\n            var c = this.__charBounds[i][r];\n            return c && (s = c.left), 0 !== this.charSpacing && r === this._textLines[i].length && (s -= this._getWidthOfCharSpacing()), n = {\n              top: o,\n              left: e + (0 < s ? s : 0)\n            }, this.cursorOffsetCache = n, this.cursorOffsetCache;\n          },\n          renderCursor: function renderCursor(t, e) {\n            var i = this.get2DCursorLocation(),\n                r = i.lineIndex,\n                n = 0 < i.charIndex ? i.charIndex - 1 : 0,\n                o = this.getValueOfPropertyAt(r, n, \"fontSize\"),\n                s = this.scaleX * this.canvas.getZoom(),\n                a = this.cursorWidth / s,\n                h = t.topOffset,\n                c = this.getValueOfPropertyAt(r, n, \"deltaY\");\n            h += (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - o * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(t, e), e.fillStyle = this.getValueOfPropertyAt(r, n, \"fill\"), e.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, e.fillRect(t.left + t.leftOffset - a / 2, h + t.top + c, a, o);\n          },\n          renderSelection: function renderSelection(t, e) {\n            for (var i = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, r = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, n = -1 !== this.textAlign.indexOf(\"justify\"), o = this.get2DCursorLocation(i), s = this.get2DCursorLocation(r), a = o.lineIndex, h = s.lineIndex, c = o.charIndex < 0 ? 0 : o.charIndex, l = s.charIndex < 0 ? 0 : s.charIndex, u = a; u <= h; u++) {\n              var f,\n                  d = this._getLineLeftOffset(u) || 0,\n                  g = this.getHeightOfLine(u),\n                  p = 0,\n                  v = 0;\n              if (u === a && (p = this.__charBounds[a][c].left), a <= u && u < h) v = n && !this.isEndOfWrapping(u) ? this.width : this.getLineWidth(u) || 5;else if (u === h) if (0 === l) v = this.__charBounds[h][l].left;else {\n                var m = this._getWidthOfCharSpacing();\n\n                v = this.__charBounds[h][l - 1].left + this.__charBounds[h][l - 1].width - m;\n              }\n              f = g, (this.lineHeight < 1 || u === h && 1 < this.lineHeight) && (g /= this.lineHeight), this.inCompositionMode ? (e.fillStyle = this.compositionColor || \"black\", e.fillRect(t.left + d + p, t.top + t.topOffset + g, v - p, 1)) : (e.fillStyle = this.selectionColor, e.fillRect(t.left + d + p, t.top + t.topOffset, v - p, g)), t.topOffset += f;\n            }\n          },\n          getCurrentCharFontSize: function getCurrentCharFontSize() {\n            var t = this._getCurrentCharIndex();\n\n            return this.getValueOfPropertyAt(t.l, t.c, \"fontSize\");\n          },\n          getCurrentCharColor: function getCurrentCharColor() {\n            var t = this._getCurrentCharIndex();\n\n            return this.getValueOfPropertyAt(t.l, t.c, \"fill\");\n          },\n          _getCurrentCharIndex: function _getCurrentCharIndex() {\n            var t = this.get2DCursorLocation(this.selectionStart, !0),\n                e = 0 < t.charIndex ? t.charIndex - 1 : 0;\n            return {\n              l: t.lineIndex,\n              c: e\n            };\n          }\n        }), A.IText.fromObject = function (e, i) {\n          if (t(e), e.styles) for (var r in e.styles) {\n            for (var n in e.styles[r]) {\n              t(e.styles[r][n]);\n            }\n          }\n\n          A.Object._fromObject(\"IText\", e, i, \"text\");\n        };\n      }(), O = A.util.object.clone, A.util.object.extend(A.IText.prototype, {\n        initBehavior: function initBehavior() {\n          this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function onDeselect() {\n          this.isEditing && this.exitEditing(), this.selected = !1;\n        },\n        initAddedHandler: function initAddedHandler() {\n          var t = this;\n          this.on(\"added\", function () {\n            var e = t.canvas;\n            e && (e._hasITextHandlers || (e._hasITextHandlers = !0, t._initCanvasHandlers(e)), e._iTextInstances = e._iTextInstances || [], e._iTextInstances.push(t));\n          });\n        },\n        initRemovedHandler: function initRemovedHandler() {\n          var t = this;\n          this.on(\"removed\", function () {\n            var e = t.canvas;\n            e && (e._iTextInstances = e._iTextInstances || [], A.util.removeFromArray(e._iTextInstances, t), 0 === e._iTextInstances.length && (e._hasITextHandlers = !1, t._removeCanvasHandlers(e)));\n          });\n        },\n        _initCanvasHandlers: function _initCanvasHandlers(t) {\n          t._mouseUpITextHandler = function () {\n            t._iTextInstances && t._iTextInstances.forEach(function (t) {\n              t.__isMousedown = !1;\n            });\n          }, t.on(\"mouse:up\", t._mouseUpITextHandler);\n        },\n        _removeCanvasHandlers: function _removeCanvasHandlers(t) {\n          t.off(\"mouse:up\", t._mouseUpITextHandler);\n        },\n        _tick: function _tick() {\n          this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        _animateCursor: function _animateCursor(t, e, i, r) {\n          var n;\n          return n = {\n            isAborted: !1,\n            abort: function abort() {\n              this.isAborted = !0;\n            }\n          }, t.animate(\"_currentCursorOpacity\", e, {\n            duration: i,\n            onComplete: function onComplete() {\n              n.isAborted || t[r]();\n            },\n            onChange: function onChange() {\n              t.canvas && t.selectionStart === t.selectionEnd && t.renderCursorOrSelection();\n            },\n            abort: function abort() {\n              return n.isAborted;\n            }\n          }), n;\n        },\n        _onTickComplete: function _onTickComplete() {\n          var t = this;\n          this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () {\n            t._currentTickCompleteState = t._animateCursor(t, 0, this.cursorDuration / 2, \"_tick\");\n          }, 100);\n        },\n        initDelayedCursor: function initDelayedCursor(t) {\n          var e = this,\n              i = t ? 0 : this.cursorDelay;\n          this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () {\n            e._tick();\n          }, i);\n        },\n        abortCursorAnimation: function abortCursorAnimation() {\n          var t = this._currentTickState || this._currentTickCompleteState,\n              e = this.canvas;\n          this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, t && e && e.clearContext(e.contextTop || e.contextContainer);\n        },\n        selectAll: function selectAll() {\n          return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;\n        },\n        getSelectedText: function getSelectedText() {\n          return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        findWordBoundaryLeft: function findWordBoundaryLeft(t) {\n          var e = 0,\n              i = t - 1;\n          if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]);) {\n            e++, i--;\n          }\n\n          for (; /\\S/.test(this._text[i]) && -1 < i;) {\n            e++, i--;\n          }\n\n          return t - e;\n        },\n        findWordBoundaryRight: function findWordBoundaryRight(t) {\n          var e = 0,\n              i = t;\n          if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]);) {\n            e++, i++;\n          }\n\n          for (; /\\S/.test(this._text[i]) && i < this.text.length;) {\n            e++, i++;\n          }\n\n          return t + e;\n        },\n        findLineBoundaryLeft: function findLineBoundaryLeft(t) {\n          for (var e = 0, i = t - 1; !/\\n/.test(this._text[i]) && -1 < i;) {\n            e++, i--;\n          }\n\n          return t - e;\n        },\n        findLineBoundaryRight: function findLineBoundaryRight(t) {\n          for (var e = 0, i = t; !/\\n/.test(this._text[i]) && i < this.text.length;) {\n            e++, i++;\n          }\n\n          return t + e;\n        },\n        searchWordBoundary: function searchWordBoundary(t, e) {\n          for (var i = this._reSpace.test(this.text.charAt(t)) ? t - 1 : t, r = this.text.charAt(i), n = /[ \\n\\.,;!\\?\\-]/; !n.test(r) && 0 < i && i < this.text.length;) {\n            i += e, r = this.text.charAt(i);\n          }\n\n          return n.test(r) && \"\\n\" !== r && (i += 1 === e ? 0 : 1), i;\n        },\n        selectWord: function selectWord(t) {\n          t = t || this.selectionStart;\n          var e = this.searchWordBoundary(t, -1),\n              i = this.searchWordBoundary(t, 1);\n          this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();\n        },\n        selectLine: function selectLine(t) {\n          t = t || this.selectionStart;\n          var e = this.findLineBoundaryLeft(t),\n              i = this.findLineBoundaryRight(t);\n          return this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this;\n        },\n        enterEditing: function enterEditing(t) {\n          if (!this.isEditing && this.editable) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(t), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire(\"editing:entered\"), this._fireSelectionChanged(), this.canvas && (this.canvas.fire(\"text:editing:entered\", {\n            target: this\n          }), this.initMouseMoveHandler(), this.canvas.requestRenderAll()), this;\n        },\n        exitEditingOnOthers: function exitEditingOnOthers(t) {\n          t._iTextInstances && t._iTextInstances.forEach(function (t) {\n            t.selected = !1, t.isEditing && t.exitEditing();\n          });\n        },\n        initMouseMoveHandler: function initMouseMoveHandler() {\n          this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        mouseMoveHandler: function mouseMoveHandler(t) {\n          if (this.__isMousedown && this.isEditing) {\n            var e = this.getSelectionStartFromPointer(t.e),\n                i = this.selectionStart,\n                r = this.selectionEnd;\n            (e === this.__selectionStartOnMouseDown && i !== r || i !== e && r !== e) && (e > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = e) : (this.selectionStart = e, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === r || (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));\n          }\n        },\n        _setEditingProps: function _setEditingProps() {\n          this.hoverCursor = \"text\", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = \"text\"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;\n        },\n        fromStringToGraphemeSelection: function fromStringToGraphemeSelection(t, e, i) {\n          var r = i.slice(0, t),\n              n = A.util.string.graphemeSplit(r).length;\n          if (t === e) return {\n            selectionStart: n,\n            selectionEnd: n\n          };\n          var o = i.slice(t, e);\n          return {\n            selectionStart: n,\n            selectionEnd: n + A.util.string.graphemeSplit(o).length\n          };\n        },\n        fromGraphemeToStringSelection: function fromGraphemeToStringSelection(t, e, i) {\n          var r = i.slice(0, t).join(\"\").length;\n          return t === e ? {\n            selectionStart: r,\n            selectionEnd: r\n          } : {\n            selectionStart: r,\n            selectionEnd: r + i.slice(t, e).join(\"\").length\n          };\n        },\n        _updateTextarea: function _updateTextarea() {\n          if (this.cursorOffsetCache = {}, this.hiddenTextarea) {\n            if (!this.inCompositionMode) {\n              var t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n              this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd;\n            }\n\n            this.updateTextareaPosition();\n          }\n        },\n        updateFromTextArea: function updateFromTextArea() {\n          if (this.hiddenTextarea) {\n            this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords());\n            var t = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition();\n          }\n        },\n        updateTextareaPosition: function updateTextareaPosition() {\n          if (this.selectionStart === this.selectionEnd) {\n            var t = this._calcTextareaPosition();\n\n            this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top;\n          }\n        },\n        _calcTextareaPosition: function _calcTextareaPosition() {\n          if (!this.canvas) return {\n            x: 1,\n            y: 1\n          };\n\n          var t = this.inCompositionMode ? this.compositionStart : this.selectionStart,\n              e = this._getCursorBoundaries(t),\n              i = this.get2DCursorLocation(t),\n              r = i.lineIndex,\n              n = i.charIndex,\n              o = this.getValueOfPropertyAt(r, n, \"fontSize\") * this.lineHeight,\n              s = e.leftOffset,\n              a = this.calcTransformMatrix(),\n              h = {\n            x: e.left + s,\n            y: e.top + e.topOffset + o\n          },\n              c = this.canvas.upperCanvasEl,\n              l = c.width,\n              u = c.height,\n              f = l - o,\n              d = u - o,\n              g = c.clientWidth / l,\n              p = c.clientHeight / u;\n\n          return h = A.util.transformPoint(h, a), (h = A.util.transformPoint(h, this.canvas.viewportTransform)).x *= g, h.y *= p, h.x < 0 && (h.x = 0), h.x > f && (h.x = f), h.y < 0 && (h.y = 0), h.y > d && (h.y = d), h.x += this.canvas._offset.left, h.y += this.canvas._offset.top, {\n            left: h.x + \"px\",\n            top: h.y + \"px\",\n            fontSize: o + \"px\",\n            charHeight: o\n          };\n        },\n        _saveEditingProps: function _saveEditingProps() {\n          this._savedProps = {\n            hasControls: this.hasControls,\n            borderColor: this.borderColor,\n            lockMovementX: this.lockMovementX,\n            lockMovementY: this.lockMovementY,\n            hoverCursor: this.hoverCursor,\n            defaultCursor: this.canvas && this.canvas.defaultCursor,\n            moveCursor: this.canvas && this.canvas.moveCursor\n          };\n        },\n        _restoreEditingProps: function _restoreEditingProps() {\n          this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor));\n        },\n        exitEditing: function exitEditing() {\n          var t = this._textBeforeEdit !== this.text;\n          return this.selected = !1, this.isEditing = !1, this.selectable = !0, this.selectionEnd = this.selectionStart, this.hiddenTextarea && (this.hiddenTextarea.blur && this.hiddenTextarea.blur(), this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea), this.hiddenTextarea = null), this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire(\"editing:exited\"), t && this.fire(\"modified\"), this.canvas && (this.canvas.off(\"mouse:move\", this.mouseMoveHandler), this.canvas.fire(\"text:editing:exited\", {\n            target: this\n          }), t && this.canvas.fire(\"object:modified\", {\n            target: this\n          })), this;\n        },\n        _removeExtraneousStyles: function _removeExtraneousStyles() {\n          for (var t in this.styles) {\n            this._textLines[t] || delete this.styles[t];\n          }\n        },\n        removeStyleFromTo: function removeStyleFromTo(t, e) {\n          var i,\n              r,\n              n = this.get2DCursorLocation(t, !0),\n              o = this.get2DCursorLocation(e, !0),\n              s = n.lineIndex,\n              a = n.charIndex,\n              h = o.lineIndex,\n              c = o.charIndex;\n\n          if (s !== h) {\n            if (this.styles[s]) for (i = a; i < this._unwrappedTextLines[s].length; i++) {\n              delete this.styles[s][i];\n            }\n            if (this.styles[h]) for (i = c; i < this._unwrappedTextLines[h].length; i++) {\n              (r = this.styles[h][i]) && (this.styles[s] || (this.styles[s] = {}), this.styles[s][a + i - c] = r);\n            }\n\n            for (i = s + 1; i <= h; i++) {\n              delete this.styles[i];\n            }\n\n            this.shiftLineStyles(h, s - h);\n          } else if (this.styles[s]) {\n            r = this.styles[s];\n            var l,\n                u,\n                f = c - a;\n\n            for (i = a; i < c; i++) {\n              delete r[i];\n            }\n\n            for (u in this.styles[s]) {\n              c <= (l = parseInt(u, 10)) && (r[l - f] = r[u], delete r[u]);\n            }\n          }\n        },\n        shiftLineStyles: function shiftLineStyles(t, e) {\n          var i = O(this.styles);\n\n          for (var r in this.styles) {\n            var n = parseInt(r, 10);\n            t < n && (this.styles[n + e] = i[n], i[n - e] || delete this.styles[n]);\n          }\n        },\n        restartCursorIfNeeded: function restartCursorIfNeeded() {\n          this._currentTickState && !this._currentTickState.isAborted && this._currentTickCompleteState && !this._currentTickCompleteState.isAborted || this.initDelayedCursor();\n        },\n        insertNewlineStyleObject: function insertNewlineStyleObject(t, e, i, r) {\n          var n,\n              o = {},\n              s = !1;\n\n          for (var a in i || (i = 1), this.shiftLineStyles(t, i), this.styles[t] && (n = this.styles[t][0 === e ? e : e - 1]), this.styles[t]) {\n            var h = parseInt(a, 10);\n            e <= h && (s = !0, o[h - e] = this.styles[t][a], delete this.styles[t][a]);\n          }\n\n          for (s ? this.styles[t + i] = o : delete this.styles[t + i]; 1 < i;) {\n            i--, r && r[i] ? this.styles[t + i] = {\n              0: O(r[i])\n            } : n ? this.styles[t + i] = {\n              0: O(n)\n            } : delete this.styles[t + i];\n          }\n\n          this._forceClearCache = !0;\n        },\n        insertCharStyleObject: function insertCharStyleObject(t, e, i, r) {\n          this.styles || (this.styles = {});\n          var n = this.styles[t],\n              o = n ? O(n) : {};\n\n          for (var s in i || (i = 1), o) {\n            var a = parseInt(s, 10);\n            e <= a && (n[a + i] = o[a], o[a - i] || delete n[a]);\n          }\n\n          if (this._forceClearCache = !0, r) for (; i--;) {\n            Object.keys(r[i]).length && (this.styles[t] || (this.styles[t] = {}), this.styles[t][e + i] = O(r[i]));\n          } else if (n) for (var h = n[e ? e - 1 : 1]; h && i--;) {\n            this.styles[t][e + i] = O(h);\n          }\n        },\n        insertNewStyleBlock: function insertNewStyleBlock(t, e, i) {\n          for (var r = this.get2DCursorLocation(e, !0), n = [0], o = 0, s = 0; s < t.length; s++) {\n            \"\\n\" === t[s] ? n[++o] = 0 : n[o]++;\n          }\n\n          for (0 < n[0] && (this.insertCharStyleObject(r.lineIndex, r.charIndex, n[0], i), i = i && i.slice(n[0] + 1)), o && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + n[0], o), s = 1; s < o; s++) {\n            0 < n[s] ? this.insertCharStyleObject(r.lineIndex + s, 0, n[s], i) : i && (this.styles[r.lineIndex + s][0] = i[0]), i = i && i.slice(n[s] + 1);\n          }\n\n          0 < n[s] && this.insertCharStyleObject(r.lineIndex + s, 0, n[s], i);\n        },\n        setSelectionStartEndWithShift: function setSelectionStartEndWithShift(t, e, i) {\n          i <= t ? (e === t ? this._selectionDirection = \"left\" : \"right\" === this._selectionDirection && (this._selectionDirection = \"left\", this.selectionEnd = t), this.selectionStart = i) : t < i && i < e ? \"right\" === this._selectionDirection ? this.selectionEnd = i : this.selectionStart = i : (e === t ? this._selectionDirection = \"right\" : \"left\" === this._selectionDirection && (this._selectionDirection = \"right\", this.selectionStart = e), this.selectionEnd = i);\n        },\n        setSelectionInBoundaries: function setSelectionInBoundaries() {\n          var t = this.text.length;\n          this.selectionStart > t ? this.selectionStart = t : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > t ? this.selectionEnd = t : this.selectionEnd < 0 && (this.selectionEnd = 0);\n        }\n      }), A.util.object.extend(A.IText.prototype, {\n        initDoubleClickSimulation: function initDoubleClickSimulation() {\n          this.__lastClickTime = +new Date(), this.__lastLastClickTime = +new Date(), this.__lastPointer = {}, this.on(\"mousedown\", this.onMouseDown);\n        },\n        onMouseDown: function onMouseDown(t) {\n          if (this.canvas) {\n            this.__newClickTime = +new Date();\n            var e = t.pointer;\n            this.isTripleClick(e) && (this.fire(\"tripleclick\", t), this._stopEvent(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected;\n          }\n        },\n        isTripleClick: function isTripleClick(t) {\n          return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y;\n        },\n        _stopEvent: function _stopEvent(t) {\n          t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation();\n        },\n        initCursorSelectionHandlers: function initCursorSelectionHandlers() {\n          this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks();\n        },\n        initClicks: function initClicks() {\n          this.on(\"mousedblclick\", function (t) {\n            this.selectWord(this.getSelectionStartFromPointer(t.e));\n          }), this.on(\"tripleclick\", function (t) {\n            this.selectLine(this.getSelectionStartFromPointer(t.e));\n          });\n        },\n        _mouseDownHandler: function _mouseDownHandler(t) {\n          !this.canvas || !this.editable || t.e.button && 1 !== t.e.button || (this.__isMousedown = !0, this.selected && this.setCursorByClick(t.e), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()));\n        },\n        _mouseDownHandlerBefore: function _mouseDownHandlerBefore(t) {\n          !this.canvas || !this.editable || t.e.button && 1 !== t.e.button || this === this.canvas._activeObject && (this.selected = !0);\n        },\n        initMousedownHandler: function initMousedownHandler() {\n          this.on(\"mousedown\", this._mouseDownHandler), this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n        },\n        initMouseupHandler: function initMouseupHandler() {\n          this.on(\"mouseup\", this.mouseUpHandler);\n        },\n        mouseUpHandler: function mouseUpHandler(t) {\n          if (this.__isMousedown = !1, !(!this.editable || this.group || t.transform && t.transform.actionPerformed || t.e.button && 1 !== t.e.button)) {\n            if (this.canvas) {\n              var e = this.canvas._activeObject;\n              if (e && e !== this) return;\n            }\n\n            this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0;\n          }\n        },\n        setCursorByClick: function setCursorByClick(t) {\n          var e = this.getSelectionStartFromPointer(t),\n              i = this.selectionStart,\n              r = this.selectionEnd;\n          t.shiftKey ? this.setSelectionStartEndWithShift(i, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());\n        },\n        getSelectionStartFromPointer: function getSelectionStartFromPointer(t) {\n          for (var e = this.getLocalPointer(t), i = 0, r = 0, n = 0, o = 0, s = 0, a = 0, h = this._textLines.length; a < h && n <= e.y; a++) {\n            n += this.getHeightOfLine(a) * this.scaleY, 0 < (s = a) && (o += this._textLines[a - 1].length + 1);\n          }\n\n          r = this._getLineLeftOffset(s) * this.scaleX;\n\n          for (var c = 0, l = this._textLines[s].length; c < l && (i = r, (r += this.__charBounds[s][c].kernedWidth * this.scaleX) <= e.x); c++) {\n            o++;\n          }\n\n          return this._getNewSelectionStartFromOffset(e, i, r, o, l);\n        },\n        _getNewSelectionStartFromOffset: function _getNewSelectionStartFromOffset(t, e, i, r, n) {\n          var o = t.x - e,\n              s = i - t.x,\n              a = r + (o < s || s < 0 ? 0 : 1);\n          return this.flipX && (a = n - a), a > this._text.length && (a = this._text.length), a;\n        }\n      }), A.util.object.extend(A.IText.prototype, {\n        initHiddenTextarea: function initHiddenTextarea() {\n          this.hiddenTextarea = A.document.createElement(\"textarea\"), this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\"), this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\"), this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\"), this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\"), this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\"), this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n\n          var t = this._calcTextareaPosition();\n\n          this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + t.top + \"; left: \" + t.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; paddingtop: \" + t.fontSize + \";\", A.document.body.appendChild(this.hiddenTextarea), A.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this)), A.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this)), A.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this)), A.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this)), A.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this)), A.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this)), A.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this)), A.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this)), A.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (A.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this)), this._clickHandlerInitialized = !0);\n        },\n        keysMap: {\n          9: \"exitEditing\",\n          27: \"exitEditing\",\n          33: \"moveCursorUp\",\n          34: \"moveCursorDown\",\n          35: \"moveCursorRight\",\n          36: \"moveCursorLeft\",\n          37: \"moveCursorLeft\",\n          38: \"moveCursorUp\",\n          39: \"moveCursorRight\",\n          40: \"moveCursorDown\"\n        },\n        ctrlKeysMapUp: {\n          67: \"copy\",\n          88: \"cut\"\n        },\n        ctrlKeysMapDown: {\n          65: \"selectAll\"\n        },\n        onClick: function onClick() {\n          this.hiddenTextarea && this.hiddenTextarea.focus();\n        },\n        onKeyDown: function onKeyDown(t) {\n          if (this.isEditing && !this.inCompositionMode) {\n            if (t.keyCode in this.keysMap) this[this.keysMap[t.keyCode]](t);else {\n              if (!(t.keyCode in this.ctrlKeysMapDown && (t.ctrlKey || t.metaKey))) return;\n              this[this.ctrlKeysMapDown[t.keyCode]](t);\n            }\n            t.stopImmediatePropagation(), t.preventDefault(), 33 <= t.keyCode && t.keyCode <= 40 ? (this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();\n          }\n        },\n        onKeyUp: function onKeyUp(t) {\n          !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll());\n        },\n        onInput: function onInput(t) {\n          var e = this.fromPaste;\n\n          if (this.fromPaste = !1, t && t.stopPropagation(), this.isEditing) {\n            var i,\n                r,\n                n = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,\n                o = this._text.length,\n                s = n.length,\n                a = s - o;\n\n            if (\"\" === this.hiddenTextarea.value) return this.styles = {}, this.updateFromTextArea(), this.fire(\"changed\"), void (this.canvas && (this.canvas.fire(\"text:changed\", {\n              target: this\n            }), this.canvas.requestRenderAll()));\n            var h = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value),\n                c = this.selectionStart > h.selectionStart;\n            this.selectionStart !== this.selectionEnd ? (i = this._text.slice(this.selectionStart, this.selectionEnd), a += this.selectionEnd - this.selectionStart) : s < o && (i = c ? this._text.slice(this.selectionEnd + a, this.selectionEnd) : this._text.slice(this.selectionStart, this.selectionStart - a)), r = n.slice(h.selectionEnd - a, h.selectionEnd), i && i.length && (this.selectionStart !== this.selectionEnd ? this.removeStyleFromTo(this.selectionStart, this.selectionEnd) : c ? this.removeStyleFromTo(this.selectionEnd - i.length, this.selectionEnd) : this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + i.length)), r.length && (e && r.join(\"\") === A.copiedText ? this.insertNewStyleBlock(r, this.selectionStart, A.copiedTextStyle) : this.insertNewStyleBlock(r, this.selectionStart)), this.updateFromTextArea(), this.fire(\"changed\"), this.canvas && (this.canvas.fire(\"text:changed\", {\n              target: this\n            }), this.canvas.requestRenderAll());\n          }\n        },\n        onCompositionStart: function onCompositionStart() {\n          this.inCompositionMode = !0;\n        },\n        onCompositionEnd: function onCompositionEnd() {\n          this.inCompositionMode = !1;\n        },\n        onCompositionUpdate: function onCompositionUpdate(t) {\n          this.compositionStart = t.target.selectionStart, this.compositionEnd = t.target.selectionEnd, this.updateTextareaPosition();\n        },\n        copy: function copy() {\n          this.selectionStart !== this.selectionEnd && (A.copiedText = this.getSelectedText(), A.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0);\n        },\n        paste: function paste() {\n          this.fromPaste = !0;\n        },\n        _getClipboardData: function _getClipboardData(t) {\n          return t && t.clipboardData || A.window.clipboardData;\n        },\n        _getWidthBeforeCursor: function _getWidthBeforeCursor(t, e) {\n          var i,\n              r = this._getLineLeftOffset(t);\n\n          return 0 < e && (r += (i = this.__charBounds[t][e - 1]).left + i.width), r;\n        },\n        getDownCursorOffset: function getDownCursorOffset(t, e) {\n          var i = this._getSelectionForOffset(t, e),\n              r = this.get2DCursorLocation(i),\n              n = r.lineIndex;\n\n          if (n === this._textLines.length - 1 || t.metaKey || 34 === t.keyCode) return this._text.length - i;\n\n          var o = r.charIndex,\n              s = this._getWidthBeforeCursor(n, o),\n              a = this._getIndexOnLine(n + 1, s);\n\n          return this._textLines[n].slice(o).length + a + 2;\n        },\n        _getSelectionForOffset: function _getSelectionForOffset(t, e) {\n          return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart;\n        },\n        getUpCursorOffset: function getUpCursorOffset(t, e) {\n          var i = this._getSelectionForOffset(t, e),\n              r = this.get2DCursorLocation(i),\n              n = r.lineIndex;\n\n          if (0 === n || t.metaKey || 33 === t.keyCode) return -i;\n\n          var o = r.charIndex,\n              s = this._getWidthBeforeCursor(n, o),\n              a = this._getIndexOnLine(n - 1, s),\n              h = this._textLines[n].slice(0, o);\n\n          return -this._textLines[n - 1].length + a - h.length;\n        },\n        _getIndexOnLine: function _getIndexOnLine(t, e) {\n          for (var i, r, n = this._textLines[t], o = this._getLineLeftOffset(t), s = 0, a = 0, h = n.length; a < h; a++) {\n            if (e < (o += i = this.__charBounds[t][a].width)) {\n              r = !0;\n              var c = o - i,\n                  l = o,\n                  u = Math.abs(c - e);\n              s = Math.abs(l - e) < u ? a : a - 1;\n              break;\n            }\n          }\n\n          return r || (s = n.length - 1), s;\n        },\n        moveCursorDown: function moveCursorDown(t) {\n          this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown(\"Down\", t);\n        },\n        moveCursorUp: function moveCursorUp(t) {\n          0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown(\"Up\", t);\n        },\n        _moveCursorUpOrDown: function _moveCursorUpOrDown(t, e) {\n          var i = this[\"get\" + t + \"CursorOffset\"](e, \"right\" === this._selectionDirection);\n          e.shiftKey ? this.moveCursorWithShift(i) : this.moveCursorWithoutShift(i), 0 !== i && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());\n        },\n        moveCursorWithShift: function moveCursorWithShift(t) {\n          var e = \"left\" === this._selectionDirection ? this.selectionStart + t : this.selectionEnd + t;\n          return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), 0 !== t;\n        },\n        moveCursorWithoutShift: function moveCursorWithoutShift(t) {\n          return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), 0 !== t;\n        },\n        moveCursorLeft: function moveCursorLeft(t) {\n          0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight(\"Left\", t);\n        },\n        _move: function _move(t, e, i) {\n          var r;\n          if (t.altKey) r = this[\"findWordBoundary\" + i](this[e]);else {\n            if (!t.metaKey && 35 !== t.keyCode && 36 !== t.keyCode) return this[e] += \"Left\" === i ? -1 : 1, !0;\n            r = this[\"findLineBoundary\" + i](this[e]);\n          }\n          if (void 0 !== typeof r && this[e] !== r) return this[e] = r, !0;\n        },\n        _moveLeft: function _moveLeft(t, e) {\n          return this._move(t, e, \"Left\");\n        },\n        _moveRight: function _moveRight(t, e) {\n          return this._move(t, e, \"Right\");\n        },\n        moveCursorLeftWithoutShift: function moveCursorLeftWithoutShift(t) {\n          var e = !0;\n          return this._selectionDirection = \"left\", this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e = this._moveLeft(t, \"selectionStart\")), this.selectionEnd = this.selectionStart, e;\n        },\n        moveCursorLeftWithShift: function moveCursorLeftWithShift(t) {\n          return \"right\" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, \"selectionEnd\") : 0 !== this.selectionStart ? (this._selectionDirection = \"left\", this._moveLeft(t, \"selectionStart\")) : void 0;\n        },\n        moveCursorRight: function moveCursorRight(t) {\n          this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight(\"Right\", t);\n        },\n        _moveCursorLeftOrRight: function _moveCursorLeftOrRight(t, e) {\n          var i = \"moveCursor\" + t + \"With\";\n          this._currentCursorOpacity = 1, e.shiftKey ? i += \"Shift\" : i += \"outShift\", this[i](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());\n        },\n        moveCursorRightWithShift: function moveCursorRightWithShift(t) {\n          return \"left\" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveRight(t, \"selectionStart\") : this.selectionEnd !== this._text.length ? (this._selectionDirection = \"right\", this._moveRight(t, \"selectionEnd\")) : void 0;\n        },\n        moveCursorRightWithoutShift: function moveCursorRightWithoutShift(t) {\n          var e = !0;\n          return this._selectionDirection = \"right\", this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, \"selectionStart\"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e;\n        },\n        removeChars: function removeChars(t, e) {\n          void 0 === e && (e = t + 1), this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(\"\"), this.set(\"dirty\", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();\n        },\n        insertChars: function insertChars(t, e, i, r) {\n          void 0 === r && (r = i), i < r && this.removeStyleFromTo(i, r);\n          var n = A.util.string.graphemeSplit(t);\n          this.insertNewStyleBlock(n, i, e), this._text = [].concat(this._text.slice(0, i), n, this._text.slice(r)), this.text = this._text.join(\"\"), this.set(\"dirty\", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();\n        }\n      }), E = A.util.toFixed, k = /  +/g, A.util.object.extend(A.Text.prototype, {\n        toSVG: function toSVG(t) {\n          var e = this._getSVGLeftTopOffsets(),\n              i = this._getSVGTextAndBg(e.textTop, e.textLeft),\n              r = this._wrapSVGTextAndBg(i);\n\n          return this._createBaseSVGMarkup(r, {\n            reviver: t,\n            noStyle: !0,\n            withShadow: !0\n          });\n        },\n        _getSVGLeftTopOffsets: function _getSVGLeftTopOffsets() {\n          return {\n            textLeft: -this.width / 2,\n            textTop: -this.height / 2,\n            lineTop: this.getHeightOfLine(0)\n          };\n        },\n        _wrapSVGTextAndBg: function _wrapSVGTextAndBg(t) {\n          var e = this.getSvgTextDecoration(this);\n          return [t.textBgRects.join(\"\"), '\\t\\t<text xml:space=\"preserve\" ', this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\", this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\", this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\", this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\", e ? 'text-decoration=\"' + e + '\" ' : \"\", 'style=\"', this.getSvgStyles(!0), '\"', this.addPaintOrder(), \" >\", t.textSpans.join(\"\"), \"</text>\\n\"];\n        },\n        _getSVGTextAndBg: function _getSVGTextAndBg(t, e) {\n          var i,\n              r = [],\n              n = [],\n              o = t;\n\n          this._setSVGBg(n);\n\n          for (var s = 0, a = this._textLines.length; s < a; s++) {\n            i = this._getLineLeftOffset(s), (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", s)) && this._setSVGTextLineBg(n, s, e + i, o), this._setSVGTextLineText(r, s, e + i, o), o += this.getHeightOfLine(s);\n          }\n\n          return {\n            textSpans: r,\n            textBgRects: n\n          };\n        },\n        _createTextCharSpan: function _createTextCharSpan(t, e, i, r) {\n          var n = t !== t.trim() || t.match(k),\n              o = this.getSvgSpanStyles(e, n),\n              s = o ? 'style=\"' + o + '\"' : \"\",\n              a = e.deltaY,\n              h = \"\",\n              c = A.Object.NUM_FRACTION_DIGITS;\n          return a && (h = ' dy=\"' + E(a, c) + '\" '), ['<tspan x=\"', E(i, c), '\" y=\"', E(r, c), '\" ', h, s, \">\", A.util.string.escapeXml(t), \"</tspan>\"].join(\"\");\n        },\n        _setSVGTextLineText: function _setSVGTextLineText(t, e, i, r) {\n          var n,\n              o,\n              s,\n              a,\n              h,\n              c = this.getHeightOfLine(e),\n              l = -1 !== this.textAlign.indexOf(\"justify\"),\n              u = \"\",\n              f = 0,\n              d = this._textLines[e];\n          r += c * (1 - this._fontSizeFraction) / this.lineHeight;\n\n          for (var g = 0, p = d.length - 1; g <= p; g++) {\n            h = g === p || this.charSpacing, u += d[g], s = this.__charBounds[e][g], 0 === f ? (i += s.kernedWidth - s.width, f += s.width) : f += s.kernedWidth, l && !h && this._reSpaceAndTab.test(d[g]) && (h = !0), h || (n = n || this.getCompleteStyleDeclaration(e, g), o = this.getCompleteStyleDeclaration(e, g + 1), h = this._hasStyleChangedForSvg(n, o)), h && (a = this._getStyleDeclaration(e, g) || {}, t.push(this._createTextCharSpan(u, a, i, r)), u = \"\", n = o, i += f, f = 0);\n          }\n        },\n        _pushTextBgRect: function _pushTextBgRect(t, e, i, r, n, o) {\n          var s = A.Object.NUM_FRACTION_DIGITS;\n          t.push(\"\\t\\t<rect \", this._getFillAttributes(e), ' x=\"', E(i, s), '\" y=\"', E(r, s), '\" width=\"', E(n, s), '\" height=\"', E(o, s), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function _setSVGTextLineBg(t, e, i, r) {\n          for (var n, o, s = this._textLines[e], a = this.getHeightOfLine(e) / this.lineHeight, h = 0, c = 0, l = this.getValueOfPropertyAt(e, 0, \"textBackgroundColor\"), u = 0, f = s.length; u < f; u++) {\n            n = this.__charBounds[e][u], (o = this.getValueOfPropertyAt(e, u, \"textBackgroundColor\")) !== l ? (l && this._pushTextBgRect(t, l, i + c, r, h, a), c = n.left, h = n.width, l = o) : h += n.kernedWidth;\n          }\n\n          o && this._pushTextBgRect(t, o, i + c, r, h, a);\n        },\n        _getFillAttributes: function _getFillAttributes(t) {\n          var e = t && \"string\" == typeof t ? new A.Color(t) : \"\";\n          return e && e.getSource() && 1 !== e.getAlpha() ? 'opacity=\"' + e.getAlpha() + '\" fill=\"' + e.setAlpha(1).toRgb() + '\"' : 'fill=\"' + t + '\"';\n        },\n        _getSVGLineTopOffset: function _getSVGLineTopOffset(t) {\n          for (var e, i = 0, r = 0; r < t; r++) {\n            i += this.getHeightOfLine(r);\n          }\n\n          return e = this.getHeightOfLine(r), {\n            lineTop: i,\n            offset: (this._fontSizeMult - this._fontSizeFraction) * e / (this.lineHeight * this._fontSizeMult)\n          };\n        },\n        getSvgStyles: function getSvgStyles(t) {\n          return A.Object.prototype.getSvgStyles.call(this, t) + \" white-space: pre;\";\n        }\n      }), function (t) {\n        \"use strict\";\n\n        var e = t.fabric || (t.fabric = {});\n        e.Textbox = e.util.createClass(e.IText, e.Observable, {\n          type: \"textbox\",\n          minWidth: 20,\n          dynamicMinWidth: 2,\n          __cachedLines: null,\n          lockScalingFlip: !0,\n          noScaleCache: !1,\n          _dimensionAffectingProps: e.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n          initDimensions: function initDimensions() {\n            this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set(\"width\", this.dynamicMinWidth), -1 !== this.textAlign.indexOf(\"justify\") && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({\n              propertySet: \"_dimensionAffectingProps\"\n            }));\n          },\n          _generateStyleMap: function _generateStyleMap(t) {\n            for (var e = 0, i = 0, r = 0, n = {}, o = 0; o < t.graphemeLines.length; o++) {\n              \"\\n\" === t.graphemeText[r] && 0 < o ? (i = 0, r++, e++) : this._reSpaceAndTab.test(t.graphemeText[r]) && 0 < o && (i++, r++), n[o] = {\n                line: e,\n                offset: i\n              }, r += t.graphemeLines[o].length, i += t.graphemeLines[o].length;\n            }\n\n            return n;\n          },\n          styleHas: function styleHas(t, i) {\n            if (this._styleMap && !this.isWrapping) {\n              var r = this._styleMap[i];\n              r && (i = r.line);\n            }\n\n            return e.Text.prototype.styleHas.call(this, t, i);\n          },\n          isEmptyStyles: function isEmptyStyles(t) {\n            var e,\n                i,\n                r = 0,\n                n = !1,\n                o = this._styleMap[t],\n                s = this._styleMap[t + 1];\n\n            for (var a in o && (t = o.line, r = o.offset), s && (n = s.line === t, e = s.offset), i = void 0 === t ? this.styles : {\n              line: this.styles[t]\n            }) {\n              for (var h in i[a]) {\n                if (r <= h && (!n || h < e)) for (var c in i[a][h]) {\n                  return !1;\n                }\n              }\n            }\n\n            return !0;\n          },\n          _getStyleDeclaration: function _getStyleDeclaration(t, e) {\n            if (this._styleMap && !this.isWrapping) {\n              var i = this._styleMap[t];\n              if (!i) return null;\n              t = i.line, e = i.offset + e;\n            }\n\n            return this.callSuper(\"_getStyleDeclaration\", t, e);\n          },\n          _setStyleDeclaration: function _setStyleDeclaration(t, e, i) {\n            var r = this._styleMap[t];\n            t = r.line, e = r.offset + e, this.styles[t][e] = i;\n          },\n          _deleteStyleDeclaration: function _deleteStyleDeclaration(t, e) {\n            var i = this._styleMap[t];\n            t = i.line, e = i.offset + e, delete this.styles[t][e];\n          },\n          _getLineStyle: function _getLineStyle(t) {\n            var e = this._styleMap[t];\n            return this.styles[e.line];\n          },\n          _setLineStyle: function _setLineStyle(t, e) {\n            var i = this._styleMap[t];\n            this.styles[i.line] = e;\n          },\n          _deleteLineStyle: function _deleteLineStyle(t) {\n            var e = this._styleMap[t];\n            delete this.styles[e.line];\n          },\n          _wrapText: function _wrapText(t, e) {\n            var i,\n                r = [];\n\n            for (this.isWrapping = !0, i = 0; i < t.length; i++) {\n              r = r.concat(this._wrapLine(t[i], i, e));\n            }\n\n            return this.isWrapping = !1, r;\n          },\n          _measureWord: function _measureWord(t, e, i) {\n            var r,\n                n = 0;\n            i = i || 0;\n\n            for (var o = 0, s = t.length; o < s; o++) {\n              n += this._getGraphemeBox(t[o], e, o + i, r, !0).kernedWidth, r = t[o];\n            }\n\n            return n;\n          },\n          _wrapLine: function _wrapLine(t, i, r, n) {\n            var o = 0,\n                s = [],\n                a = [],\n                h = t.split(this._reSpaceAndTab),\n                c = \"\",\n                l = 0,\n                u = 0,\n                f = 0,\n                d = 0,\n                g = !0,\n                p = this._getWidthOfCharSpacing();\n\n            r -= n = n || 0;\n\n            for (var v = 0; v < h.length; v++) {\n              c = e.util.string.graphemeSplit(h[v]), u = this._measureWord(c, i, l), l += c.length, r <= (o += f + u - p) && !g ? (s.push(a), a = [], o = u, g = !0) : o += p, g || a.push(\" \"), a = a.concat(c), f = this._measureWord([\" \"], i, l), l++, g = !1, d < u && (d = u);\n            }\n\n            return v && s.push(a), d + n > this.dynamicMinWidth && (this.dynamicMinWidth = d - p + n), s;\n          },\n          isEndOfWrapping: function isEndOfWrapping(t) {\n            return !this._styleMap[t + 1] || this._styleMap[t + 1].line !== this._styleMap[t].line;\n          },\n          _splitTextIntoLines: function _splitTextIntoLines(t) {\n            for (var i = e.Text.prototype._splitTextIntoLines.call(this, t), r = this._wrapText(i.lines, this.width), n = new Array(r.length), o = 0; o < r.length; o++) {\n              n[o] = r[o].join(\"\");\n            }\n\n            return i.lines = n, i.graphemeLines = r, i;\n          },\n          getMinWidth: function getMinWidth() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n          },\n          toObject: function toObject(t) {\n            return this.callSuper(\"toObject\", [\"minWidth\"].concat(t));\n          }\n        }), e.Textbox.fromObject = function (t, i) {\n          return e.Object._fromObject(\"Textbox\", t, i, \"text\");\n        };\n      }(e), P = A.Canvas.prototype._setObjectScale, A.Canvas.prototype._setObjectScale = function (t, e, i, r, n, o, s) {\n        var a = e.target;\n        if (!(\"x\" === n && a instanceof A.Textbox)) return P.call(A.Canvas.prototype, t, e, i, r, n, o, s);\n\n        var h = a._getTransformedDimensions().x,\n            c = a.width * (t.x / h);\n\n        return c >= a.getMinWidth() ? (a.set(\"width\", c), !0) : void 0;\n      }, A.util.object.extend(A.Textbox.prototype, {\n        _removeExtraneousStyles: function _removeExtraneousStyles() {\n          for (var t in this._styleMap) {\n            this._textLines[t] || delete this.styles[this._styleMap[t].line];\n          }\n        }\n      });\n    }).call(this, i(19).Buffer);\n  }, function (t, e, i) {\n    \"use strict\";\n\n    t.exports = i(15);\n  }, function (t, e, i) {\n    var r = i(9),\n        n = i(10),\n        o = i(11);\n\n    t.exports = function (t, e) {\n      return r(t) || n(t, e) || o();\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      if (Array.isArray(t)) return t;\n    };\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      var i = [],\n          r = !0,\n          n = !1,\n          o = void 0;\n\n      try {\n        for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (i.push(s.value), !e || i.length !== e); r = !0) {\n          ;\n        }\n      } catch (t) {\n        n = !0, o = t;\n      } finally {\n        try {\n          r || null == a.return || a.return();\n        } finally {\n          if (n) throw o;\n        }\n      }\n\n      return i;\n    };\n  }, function (t, e) {\n    t.exports = function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    };\n  }, function (t, e) {\n    function i(t) {\n      return (i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n\n    function r(e) {\n      return \"function\" == typeof Symbol && \"symbol\" === i(Symbol.iterator) ? t.exports = r = function r(t) {\n        return i(t);\n      } : t.exports = r = function r(t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : i(t);\n      }, r(e);\n    }\n\n    t.exports = r;\n  }, function (t, e) {\n    t.exports = function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    };\n  }, function (t, e) {\n    function i(e, r) {\n      return t.exports = i = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      }, i(e, r);\n    }\n\n    t.exports = i;\n  }, function (t, e, i) {\n    \"use strict\";\n    /** @license React v16.6.1\n     * react.production.min.js\n     *\n     * Copyright (c) Facebook, Inc. and its affiliates.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n    var r = i(16),\n        n = \"function\" == typeof Symbol && Symbol.for,\n        o = n ? Symbol.for(\"react.element\") : 60103,\n        s = n ? Symbol.for(\"react.portal\") : 60106,\n        a = n ? Symbol.for(\"react.fragment\") : 60107,\n        h = n ? Symbol.for(\"react.strict_mode\") : 60108,\n        c = n ? Symbol.for(\"react.profiler\") : 60114,\n        l = n ? Symbol.for(\"react.provider\") : 60109,\n        u = n ? Symbol.for(\"react.context\") : 60110,\n        f = n ? Symbol.for(\"react.concurrent_mode\") : 60111,\n        d = n ? Symbol.for(\"react.forward_ref\") : 60112,\n        g = n ? Symbol.for(\"react.suspense\") : 60113,\n        p = n ? Symbol.for(\"react.memo\") : 60115,\n        v = n ? Symbol.for(\"react.lazy\") : 60116,\n        m = \"function\" == typeof Symbol && Symbol.iterator;\n\n    function y(t) {\n      for (var e = arguments.length - 1, i = \"https://reactjs.org/docs/error-decoder.html?invariant=\" + t, r = 0; r < e; r++) {\n        i += \"&args[]=\" + encodeURIComponent(arguments[r + 1]);\n      }\n\n      !function (t, e, i, r, n, o, s, a) {\n        if (!t) {\n          if ((t = void 0) === e) t = Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else {\n            var h = [i, void 0, void 0, void 0, void 0, void 0],\n                c = 0;\n            (t = Error(e.replace(/%s/g, function () {\n              return h[c++];\n            }))).name = \"Invariant Violation\";\n          }\n          throw t.framesToPop = 1, t;\n        }\n      }(!1, \"Minified React error #\" + t + \"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. \", i);\n    }\n\n    var _ = {\n      isMounted: function isMounted() {\n        return !1;\n      },\n      enqueueForceUpdate: function enqueueForceUpdate() {},\n      enqueueReplaceState: function enqueueReplaceState() {},\n      enqueueSetState: function enqueueSetState() {}\n    },\n        b = {};\n\n    function x(t, e, i) {\n      this.props = t, this.context = e, this.refs = b, this.updater = i || _;\n    }\n\n    function C() {}\n\n    function S(t, e, i) {\n      this.props = t, this.context = e, this.refs = b, this.updater = i || _;\n    }\n\n    x.prototype.isReactComponent = {}, x.prototype.setState = function (t, e) {\n      \"object\" != typeof t && \"function\" != typeof t && null != t && y(\"85\"), this.updater.enqueueSetState(this, t, e, \"setState\");\n    }, x.prototype.forceUpdate = function (t) {\n      this.updater.enqueueForceUpdate(this, t, \"forceUpdate\");\n    }, C.prototype = x.prototype;\n    var w = S.prototype = new C();\n    w.constructor = S, r(w, x.prototype), w.isPureReactComponent = !0;\n    var T = {\n      current: null,\n      currentDispatcher: null\n    },\n        O = Object.prototype.hasOwnProperty,\n        E = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    };\n\n    function k(t, e, i) {\n      var r = void 0,\n          n = {},\n          s = null,\n          a = null;\n      if (null != e) for (r in void 0 !== e.ref && (a = e.ref), void 0 !== e.key && (s = \"\" + e.key), e) {\n        O.call(e, r) && !E.hasOwnProperty(r) && (n[r] = e[r]);\n      }\n      var h = arguments.length - 2;\n      if (1 === h) n.children = i;else if (1 < h) {\n        for (var c = Array(h), l = 0; l < h; l++) {\n          c[l] = arguments[l + 2];\n        }\n\n        n.children = c;\n      }\n      if (t && t.defaultProps) for (r in h = t.defaultProps) {\n        void 0 === n[r] && (n[r] = h[r]);\n      }\n      return {\n        $$typeof: o,\n        type: t,\n        key: s,\n        ref: a,\n        props: n,\n        _owner: T.current\n      };\n    }\n\n    function P(t) {\n      return \"object\" == typeof t && null !== t && t.$$typeof === o;\n    }\n\n    var A = /\\/+/g,\n        D = [];\n\n    function j(t, e, i, r) {\n      if (D.length) {\n        var n = D.pop();\n        return n.result = t, n.keyPrefix = e, n.func = i, n.context = r, n.count = 0, n;\n      }\n\n      return {\n        result: t,\n        keyPrefix: e,\n        func: i,\n        context: r,\n        count: 0\n      };\n    }\n\n    function M(t) {\n      t.result = null, t.keyPrefix = null, t.func = null, t.context = null, t.count = 0, D.length < 10 && D.push(t);\n    }\n\n    function F(t, e, i) {\n      return null == t ? 0 : function t(e, i, r, n) {\n        var a = typeof e;\n        \"undefined\" !== a && \"boolean\" !== a || (e = null);\n        var h = !1;\n        if (null === e) h = !0;else switch (a) {\n          case \"string\":\n          case \"number\":\n            h = !0;\n            break;\n\n          case \"object\":\n            switch (e.$$typeof) {\n              case o:\n              case s:\n                h = !0;\n            }\n\n        }\n        if (h) return r(n, e, \"\" === i ? \".\" + I(e, 0) : i), 1;\n        if (h = 0, i = \"\" === i ? \".\" : i + \":\", Array.isArray(e)) for (var c = 0; c < e.length; c++) {\n          var l = i + I(a = e[c], c);\n          h += t(a, l, r, n);\n        } else if (\"function\" == typeof (l = null === e || \"object\" != typeof e ? null : \"function\" == typeof (l = m && e[m] || e[\"@@iterator\"]) ? l : null)) for (e = l.call(e), c = 0; !(a = e.next()).done;) {\n          h += t(a = a.value, l = i + I(a, c++), r, n);\n        } else \"object\" === a && y(\"31\", \"[object Object]\" == (r = \"\" + e) ? \"object with keys {\" + Object.keys(e).join(\", \") + \"}\" : r, \"\");\n        return h;\n      }(t, \"\", e, i);\n    }\n\n    function I(t, e) {\n      return \"object\" == typeof t && null !== t && null != t.key ? (i = t.key, r = {\n        \"=\": \"=0\",\n        \":\": \"=2\"\n      }, \"$\" + (\"\" + i).replace(/[=:]/g, function (t) {\n        return r[t];\n      })) : e.toString(36);\n      var i, r;\n    }\n\n    function L(t, e) {\n      t.func.call(t.context, e, t.count++);\n    }\n\n    function R(t, e, i) {\n      var r,\n          n,\n          s = t.result,\n          a = t.keyPrefix;\n      t = t.func.call(t.context, e, t.count++), Array.isArray(t) ? B(t, s, i, function (t) {\n        return t;\n      }) : null != t && (P(t) && (n = a + (!(r = t).key || e && e.key === t.key ? \"\" : (\"\" + t.key).replace(A, \"$&/\") + \"/\") + i, t = {\n        $$typeof: o,\n        type: r.type,\n        key: n,\n        ref: r.ref,\n        props: r.props,\n        _owner: r._owner\n      }), s.push(t));\n    }\n\n    function B(t, e, i, r, n) {\n      var o = \"\";\n      null != i && (o = (\"\" + i).replace(A, \"$&/\") + \"/\"), F(t, R, e = j(e, o, r, n)), M(e);\n    }\n\n    var Y = {\n      Children: {\n        map: function map(t, e, i) {\n          if (null == t) return t;\n          var r = [];\n          return B(t, r, null, e, i), r;\n        },\n        forEach: function forEach(t, e, i) {\n          if (null == t) return t;\n          F(t, L, e = j(null, null, e, i)), M(e);\n        },\n        count: function count(t) {\n          return F(t, function () {\n            return null;\n          }, null);\n        },\n        toArray: function toArray(t) {\n          var e = [];\n          return B(t, e, null, function (t) {\n            return t;\n          }), e;\n        },\n        only: function only(t) {\n          return P(t) || y(\"143\"), t;\n        }\n      },\n      createRef: function createRef() {\n        return {\n          current: null\n        };\n      },\n      Component: x,\n      PureComponent: S,\n      createContext: function createContext(t, e) {\n        return void 0 === e && (e = null), (t = {\n          $$typeof: u,\n          _calculateChangedBits: e,\n          _currentValue: t,\n          _currentValue2: t,\n          Provider: null,\n          Consumer: null\n        }).Provider = {\n          $$typeof: l,\n          _context: t\n        }, t.Consumer = t;\n      },\n      forwardRef: function forwardRef(t) {\n        return {\n          $$typeof: d,\n          render: t\n        };\n      },\n      lazy: function lazy(t) {\n        return {\n          $$typeof: v,\n          _ctor: t,\n          _status: -1,\n          _result: null\n        };\n      },\n      memo: function memo(t, e) {\n        return {\n          $$typeof: p,\n          type: t,\n          compare: void 0 === e ? null : e\n        };\n      },\n      Fragment: a,\n      StrictMode: h,\n      Suspense: g,\n      createElement: k,\n      cloneElement: function cloneElement(t, e, i) {\n        null == t && y(\"267\", t);\n        var n = void 0,\n            s = r({}, t.props),\n            a = t.key,\n            h = t.ref,\n            c = t._owner;\n\n        if (null != e) {\n          void 0 !== e.ref && (h = e.ref, c = T.current), void 0 !== e.key && (a = \"\" + e.key);\n          var l = void 0;\n\n          for (n in t.type && t.type.defaultProps && (l = t.type.defaultProps), e) {\n            O.call(e, n) && !E.hasOwnProperty(n) && (s[n] = void 0 === e[n] && void 0 !== l ? l[n] : e[n]);\n          }\n        }\n\n        if (1 == (n = arguments.length - 2)) s.children = i;else if (1 < n) {\n          l = Array(n);\n\n          for (var u = 0; u < n; u++) {\n            l[u] = arguments[u + 2];\n          }\n\n          s.children = l;\n        }\n        return {\n          $$typeof: o,\n          type: t.type,\n          key: a,\n          ref: h,\n          props: s,\n          _owner: c\n        };\n      },\n      createFactory: function createFactory(t) {\n        var e = k.bind(null, t);\n        return e.type = t, e;\n      },\n      isValidElement: P,\n      version: \"16.6.1\",\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        ReactCurrentOwner: T,\n        assign: r\n      }\n    };\n    Y.unstable_ConcurrentMode = f, Y.unstable_Profiler = c;\n    var X = Y || {\n      default: Y\n    };\n    t.exports = X.default || X;\n  }, function (t, e, i) {\n    \"use strict\";\n    /*\n    object-assign\n    (c) Sindre Sorhus\n    @license MIT\n    */\n\n    var r = Object.getOwnPropertySymbols,\n        n = Object.prototype.hasOwnProperty,\n        o = Object.prototype.propertyIsEnumerable;\n    t.exports = function () {\n      try {\n        if (!Object.assign) return !1;\n        var t = new String(\"abc\");\n        if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n\n        for (var e = {}, i = 0; i < 10; i++) {\n          e[\"_\" + String.fromCharCode(i)] = i;\n        }\n\n        if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n          return e[t];\n        }).join(\"\")) return !1;\n        var r = {};\n        return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n          r[t] = t;\n        }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, r)).join(\"\");\n      } catch (t) {\n        return !1;\n      }\n    }() ? Object.assign : function (t, e) {\n      for (var i, s, a = function (t) {\n        if (null == t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n        return Object(t);\n      }(t), h = 1; h < arguments.length; h++) {\n        for (var c in i = Object(arguments[h])) {\n          n.call(i, c) && (a[c] = i[c]);\n        }\n\n        if (r) {\n          s = r(i);\n\n          for (var l = 0; l < s.length; l++) {\n            o.call(i, s[l]) && (a[s[l]] = i[s[l]]);\n          }\n        }\n      }\n\n      return a;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var r = i(18);\n\n    function n() {}\n\n    t.exports = function () {\n      function t(t, e, i, n, o, s) {\n        if (s !== r) {\n          var a = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n          throw a.name = \"Invariant Violation\", a;\n        }\n      }\n\n      function e() {\n        return t;\n      }\n\n      var i = {\n        array: t.isRequired = t,\n        bool: t,\n        func: t,\n        number: t,\n        object: t,\n        string: t,\n        symbol: t,\n        any: t,\n        arrayOf: e,\n        element: t,\n        instanceOf: e,\n        node: t,\n        objectOf: e,\n        oneOf: e,\n        oneOfType: e,\n        shape: e,\n        exact: e\n      };\n      return i.checkPropTypes = n, i.PropTypes = i;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    t.exports = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  }, function (t, e, i) {\n    \"use strict\";\n\n    (function (t) {\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n       * @license  MIT\n       */\n      var r = i(21),\n          n = i(22),\n          o = i(23);\n\n      function s() {\n        return h.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n      }\n\n      function a(t, e) {\n        if (s() < e) throw new RangeError(\"Invalid typed array length\");\n        return h.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = h.prototype : (null === t && (t = new h(e)), t.length = e), t;\n      }\n\n      function h(t, e, i) {\n        if (!(h.TYPED_ARRAY_SUPPORT || this instanceof h)) return new h(t, e, i);\n        if (\"number\" != typeof t) return c(this, t, e, i);\n        if (\"string\" == typeof e) throw new Error(\"If encoding is specified then the first argument must be a string\");\n        return u(this, t);\n      }\n\n      function c(t, e, i, r) {\n        if (\"number\" == typeof e) throw new TypeError('\"value\" argument must not be a number');\n        return \"undefined\" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, i, r) {\n          if (e.byteLength, i < 0 || e.byteLength < i) throw new RangeError(\"'offset' is out of bounds\");\n          if (e.byteLength < i + (r || 0)) throw new RangeError(\"'length' is out of bounds\");\n          return e = void 0 === i && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, i) : new Uint8Array(e, i, r), h.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = h.prototype : t = f(t, e), t;\n        }(t, e, i, r) : \"string\" == typeof e ? function (t, e, i) {\n          if (\"string\" == typeof i && \"\" !== i || (i = \"utf8\"), !h.isEncoding(i)) throw new TypeError('\"encoding\" must be a valid string encoding');\n          var r = 0 | g(e, i),\n              n = (t = a(t, r)).write(e, i);\n          return n !== r && (t = t.slice(0, n)), t;\n        }(t, e, i) : function (t, e) {\n          if (h.isBuffer(e)) {\n            var i = 0 | d(e.length);\n            return 0 === (t = a(t, i)).length || e.copy(t, 0, 0, i), t;\n          }\n\n          if (e) {\n            if (\"undefined\" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || \"length\" in e) return \"number\" != typeof e.length || (r = e.length) != r ? a(t, 0) : f(t, e);\n            if (\"Buffer\" === e.type && o(e.data)) return f(t, e.data);\n          }\n\n          var r;\n          throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n        }(t, e);\n      }\n\n      function l(t) {\n        if (\"number\" != typeof t) throw new TypeError('\"size\" argument must be a number');\n        if (t < 0) throw new RangeError('\"size\" argument must not be negative');\n      }\n\n      function u(t, e) {\n        if (l(e), t = a(t, e < 0 ? 0 : 0 | d(e)), !h.TYPED_ARRAY_SUPPORT) for (var i = 0; i < e; ++i) {\n          t[i] = 0;\n        }\n        return t;\n      }\n\n      function f(t, e) {\n        var i = e.length < 0 ? 0 : 0 | d(e.length);\n        t = a(t, i);\n\n        for (var r = 0; r < i; r += 1) {\n          t[r] = 255 & e[r];\n        }\n\n        return t;\n      }\n\n      function d(t) {\n        if (t >= s()) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + s().toString(16) + \" bytes\");\n        return 0 | t;\n      }\n\n      function g(t, e) {\n        if (h.isBuffer(t)) return t.length;\n        if (\"undefined\" != typeof ArrayBuffer && \"function\" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;\n        \"string\" != typeof t && (t = \"\" + t);\n        var i = t.length;\n        if (0 === i) return 0;\n\n        for (var r = !1;;) {\n          switch (e) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return i;\n\n            case \"utf8\":\n            case \"utf-8\":\n            case void 0:\n              return L(t).length;\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return 2 * i;\n\n            case \"hex\":\n              return i >>> 1;\n\n            case \"base64\":\n              return R(t).length;\n\n            default:\n              if (r) return L(t).length;\n              e = (\"\" + e).toLowerCase(), r = !0;\n          }\n        }\n      }\n\n      function p(t, e, i) {\n        var r = t[e];\n        t[e] = t[i], t[i] = r;\n      }\n\n      function v(t, e, i, r, n) {\n        if (0 === t.length) return -1;\n\n        if (\"string\" == typeof i ? (r = i, i = 0) : 2147483647 < i ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, isNaN(i) && (i = n ? 0 : t.length - 1), i < 0 && (i = t.length + i), i >= t.length) {\n          if (n) return -1;\n          i = t.length - 1;\n        } else if (i < 0) {\n          if (!n) return -1;\n          i = 0;\n        }\n\n        if (\"string\" == typeof e && (e = h.from(e, r)), h.isBuffer(e)) return 0 === e.length ? -1 : m(t, e, i, r, n);\n        if (\"number\" == typeof e) return e &= 255, h.TYPED_ARRAY_SUPPORT && \"function\" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(t, e, i) : Uint8Array.prototype.lastIndexOf.call(t, e, i) : m(t, [e], i, r, n);\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n\n      function m(t, e, i, r, n) {\n        var o,\n            s = 1,\n            a = t.length,\n            h = e.length;\n\n        if (void 0 !== r && (\"ucs2\" === (r = String(r).toLowerCase()) || \"ucs-2\" === r || \"utf16le\" === r || \"utf-16le\" === r)) {\n          if (t.length < 2 || e.length < 2) return -1;\n          a /= s = 2, h /= 2, i /= 2;\n        }\n\n        function c(t, e) {\n          return 1 === s ? t[e] : t.readUInt16BE(e * s);\n        }\n\n        if (n) {\n          var l = -1;\n\n          for (o = i; o < a; o++) {\n            if (c(t, o) === c(e, -1 === l ? 0 : o - l)) {\n              if (-1 === l && (l = o), o - l + 1 === h) return l * s;\n            } else -1 !== l && (o -= o - l), l = -1;\n          }\n        } else for (a < i + h && (i = a - h), o = i; 0 <= o; o--) {\n          for (var u = !0, f = 0; f < h; f++) {\n            if (c(t, o + f) !== c(e, f)) {\n              u = !1;\n              break;\n            }\n          }\n\n          if (u) return o;\n        }\n\n        return -1;\n      }\n\n      function y(t, e, i, r) {\n        i = Number(i) || 0;\n        var n = t.length - i;\n        r ? n < (r = Number(r)) && (r = n) : r = n;\n        var o = e.length;\n        if (o % 2 != 0) throw new TypeError(\"Invalid hex string\");\n        o / 2 < r && (r = o / 2);\n\n        for (var s = 0; s < r; ++s) {\n          var a = parseInt(e.substr(2 * s, 2), 16);\n          if (isNaN(a)) return s;\n          t[i + s] = a;\n        }\n\n        return s;\n      }\n\n      function _(t, e, i, r) {\n        return B(function (t) {\n          for (var e = [], i = 0; i < t.length; ++i) {\n            e.push(255 & t.charCodeAt(i));\n          }\n\n          return e;\n        }(e), t, i, r);\n      }\n\n      function b(t, e, i) {\n        return 0 === e && i === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, i));\n      }\n\n      function x(t, e, i) {\n        i = Math.min(t.length, i);\n\n        for (var r = [], n = e; n < i;) {\n          var o,\n              s,\n              a,\n              h,\n              c = t[n],\n              l = null,\n              u = 239 < c ? 4 : 223 < c ? 3 : 191 < c ? 2 : 1;\n          if (n + u <= i) switch (u) {\n            case 1:\n              c < 128 && (l = c);\n              break;\n\n            case 2:\n              128 == (192 & (o = t[n + 1])) && 127 < (h = (31 & c) << 6 | 63 & o) && (l = h);\n              break;\n\n            case 3:\n              o = t[n + 1], s = t[n + 2], 128 == (192 & o) && 128 == (192 & s) && 2047 < (h = (15 & c) << 12 | (63 & o) << 6 | 63 & s) && (h < 55296 || 57343 < h) && (l = h);\n              break;\n\n            case 4:\n              o = t[n + 1], s = t[n + 2], a = t[n + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && 65535 < (h = (15 & c) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) && h < 1114112 && (l = h);\n          }\n          null === l ? (l = 65533, u = 1) : 65535 < l && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), n += u;\n        }\n\n        return function (t) {\n          var e = t.length;\n          if (e <= C) return String.fromCharCode.apply(String, t);\n\n          for (var i = \"\", r = 0; r < e;) {\n            i += String.fromCharCode.apply(String, t.slice(r, r += C));\n          }\n\n          return i;\n        }(r);\n      }\n\n      e.Buffer = h, e.SlowBuffer = function (t) {\n        return +t != t && (t = 0), h.alloc(+t);\n      }, e.INSPECT_MAX_BYTES = 50, h.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () {\n        try {\n          var t = new Uint8Array(1);\n          return t.__proto__ = {\n            __proto__: Uint8Array.prototype,\n            foo: function foo() {\n              return 42;\n            }\n          }, 42 === t.foo() && \"function\" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;\n        } catch (t) {\n          return !1;\n        }\n      }(), e.kMaxLength = s(), h.poolSize = 8192, h._augment = function (t) {\n        return t.__proto__ = h.prototype, t;\n      }, h.from = function (t, e, i) {\n        return c(null, t, e, i);\n      }, h.TYPED_ARRAY_SUPPORT && (h.prototype.__proto__ = Uint8Array.prototype, h.__proto__ = Uint8Array, \"undefined\" != typeof Symbol && Symbol.species && h[Symbol.species] === h && Object.defineProperty(h, Symbol.species, {\n        value: null,\n        configurable: !0\n      })), h.alloc = function (t, e, i) {\n        return r = null, o = e, s = i, l(n = t), n <= 0 ? a(r, n) : void 0 !== o ? \"string\" == typeof s ? a(r, n).fill(o, s) : a(r, n).fill(o) : a(r, n);\n        var r, n, o, s;\n      }, h.allocUnsafe = function (t) {\n        return u(null, t);\n      }, h.allocUnsafeSlow = function (t) {\n        return u(null, t);\n      }, h.isBuffer = function (t) {\n        return !(null == t || !t._isBuffer);\n      }, h.compare = function (t, e) {\n        if (!h.isBuffer(t) || !h.isBuffer(e)) throw new TypeError(\"Arguments must be Buffers\");\n        if (t === e) return 0;\n\n        for (var i = t.length, r = e.length, n = 0, o = Math.min(i, r); n < o; ++n) {\n          if (t[n] !== e[n]) {\n            i = t[n], r = e[n];\n            break;\n          }\n        }\n\n        return i < r ? -1 : r < i ? 1 : 0;\n      }, h.isEncoding = function (t) {\n        switch (String(t).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return !0;\n\n          default:\n            return !1;\n        }\n      }, h.concat = function (t, e) {\n        if (!o(t)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        if (0 === t.length) return h.alloc(0);\n        var i;\n        if (void 0 === e) for (i = e = 0; i < t.length; ++i) {\n          e += t[i].length;\n        }\n        var r = h.allocUnsafe(e),\n            n = 0;\n\n        for (i = 0; i < t.length; ++i) {\n          var s = t[i];\n          if (!h.isBuffer(s)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n          s.copy(r, n), n += s.length;\n        }\n\n        return r;\n      }, h.byteLength = g, h.prototype._isBuffer = !0, h.prototype.swap16 = function () {\n        var t = this.length;\n        if (t % 2 != 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n\n        for (var e = 0; e < t; e += 2) {\n          p(this, e, e + 1);\n        }\n\n        return this;\n      }, h.prototype.swap32 = function () {\n        var t = this.length;\n        if (t % 4 != 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n\n        for (var e = 0; e < t; e += 4) {\n          p(this, e, e + 3), p(this, e + 1, e + 2);\n        }\n\n        return this;\n      }, h.prototype.swap64 = function () {\n        var t = this.length;\n        if (t % 8 != 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n\n        for (var e = 0; e < t; e += 8) {\n          p(this, e, e + 7), p(this, e + 1, e + 6), p(this, e + 2, e + 5), p(this, e + 3, e + 4);\n        }\n\n        return this;\n      }, h.prototype.toString = function () {\n        var t = 0 | this.length;\n        return 0 === t ? \"\" : 0 === arguments.length ? x(this, 0, t) : function (t, e, i) {\n          var r = !1;\n          if ((void 0 === e || e < 0) && (e = 0), e > this.length) return \"\";\n          if ((void 0 === i || i > this.length) && (i = this.length), i <= 0) return \"\";\n          if ((i >>>= 0) <= (e >>>= 0)) return \"\";\n\n          for (t || (t = \"utf8\");;) {\n            switch (t) {\n              case \"hex\":\n                return T(this, e, i);\n\n              case \"utf8\":\n              case \"utf-8\":\n                return x(this, e, i);\n\n              case \"ascii\":\n                return S(this, e, i);\n\n              case \"latin1\":\n              case \"binary\":\n                return w(this, e, i);\n\n              case \"base64\":\n                return b(this, e, i);\n\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return O(this, e, i);\n\n              default:\n                if (r) throw new TypeError(\"Unknown encoding: \" + t);\n                t = (t + \"\").toLowerCase(), r = !0;\n            }\n          }\n        }.apply(this, arguments);\n      }, h.prototype.equals = function (t) {\n        if (!h.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        return this === t || 0 === h.compare(this, t);\n      }, h.prototype.inspect = function () {\n        var t = \"\",\n            i = e.INSPECT_MAX_BYTES;\n        return 0 < this.length && (t = this.toString(\"hex\", 0, i).match(/.{2}/g).join(\" \"), this.length > i && (t += \" ... \")), \"<Buffer \" + t + \">\";\n      }, h.prototype.compare = function (t, e, i, r, n) {\n        if (!h.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        if (void 0 === e && (e = 0), void 0 === i && (i = t ? t.length : 0), void 0 === r && (r = 0), void 0 === n && (n = this.length), e < 0 || i > t.length || r < 0 || n > this.length) throw new RangeError(\"out of range index\");\n        if (n <= r && i <= e) return 0;\n        if (n <= r) return -1;\n        if (i <= e) return 1;\n        if (this === t) return 0;\n\n        for (var o = (n >>>= 0) - (r >>>= 0), s = (i >>>= 0) - (e >>>= 0), a = Math.min(o, s), c = this.slice(r, n), l = t.slice(e, i), u = 0; u < a; ++u) {\n          if (c[u] !== l[u]) {\n            o = c[u], s = l[u];\n            break;\n          }\n        }\n\n        return o < s ? -1 : s < o ? 1 : 0;\n      }, h.prototype.includes = function (t, e, i) {\n        return -1 !== this.indexOf(t, e, i);\n      }, h.prototype.indexOf = function (t, e, i) {\n        return v(this, t, e, i, !0);\n      }, h.prototype.lastIndexOf = function (t, e, i) {\n        return v(this, t, e, i, !1);\n      }, h.prototype.write = function (t, e, i, r) {\n        if (void 0 === e) r = \"utf8\", i = this.length, e = 0;else if (void 0 === i && \"string\" == typeof e) r = e, i = this.length, e = 0;else {\n          if (!isFinite(e)) throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n          e |= 0, isFinite(i) ? (i |= 0, void 0 === r && (r = \"utf8\")) : (r = i, i = void 0);\n        }\n        var n = this.length - e;\n        if ((void 0 === i || n < i) && (i = n), 0 < t.length && (i < 0 || e < 0) || e > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n        r || (r = \"utf8\");\n\n        for (var o, s, a, h, c, l, u, f, d, g = !1;;) {\n          switch (r) {\n            case \"hex\":\n              return y(this, t, e, i);\n\n            case \"utf8\":\n            case \"utf-8\":\n              return f = e, d = i, B(L(t, (u = this).length - f), u, f, d);\n\n            case \"ascii\":\n              return _(this, t, e, i);\n\n            case \"latin1\":\n            case \"binary\":\n              return _(this, t, e, i);\n\n            case \"base64\":\n              return h = this, c = e, l = i, B(R(t), h, c, l);\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return s = e, a = i, B(function (t, e) {\n                for (var i, r, n, o = [], s = 0; s < t.length && !((e -= 2) < 0); ++s) {\n                  r = (i = t.charCodeAt(s)) >> 8, n = i % 256, o.push(n), o.push(r);\n                }\n\n                return o;\n              }(t, (o = this).length - s), o, s, a);\n\n            default:\n              if (g) throw new TypeError(\"Unknown encoding: \" + r);\n              r = (\"\" + r).toLowerCase(), g = !0;\n          }\n        }\n      }, h.prototype.toJSON = function () {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      var C = 4096;\n\n      function S(t, e, i) {\n        var r = \"\";\n        i = Math.min(t.length, i);\n\n        for (var n = e; n < i; ++n) {\n          r += String.fromCharCode(127 & t[n]);\n        }\n\n        return r;\n      }\n\n      function w(t, e, i) {\n        var r = \"\";\n        i = Math.min(t.length, i);\n\n        for (var n = e; n < i; ++n) {\n          r += String.fromCharCode(t[n]);\n        }\n\n        return r;\n      }\n\n      function T(t, e, i) {\n        var r = t.length;\n        (!e || e < 0) && (e = 0), (!i || i < 0 || r < i) && (i = r);\n\n        for (var n = \"\", o = e; o < i; ++o) {\n          n += I(t[o]);\n        }\n\n        return n;\n      }\n\n      function O(t, e, i) {\n        for (var r = t.slice(e, i), n = \"\", o = 0; o < r.length; o += 2) {\n          n += String.fromCharCode(r[o] + 256 * r[o + 1]);\n        }\n\n        return n;\n      }\n\n      function E(t, e, i) {\n        if (t % 1 != 0 || t < 0) throw new RangeError(\"offset is not uint\");\n        if (i < t + e) throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n\n      function k(t, e, i, r, n, o) {\n        if (!h.isBuffer(t)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (n < e || e < o) throw new RangeError('\"value\" argument is out of bounds');\n        if (i + r > t.length) throw new RangeError(\"Index out of range\");\n      }\n\n      function P(t, e, i, r) {\n        e < 0 && (e = 65535 + e + 1);\n\n        for (var n = 0, o = Math.min(t.length - i, 2); n < o; ++n) {\n          t[i + n] = (e & 255 << 8 * (r ? n : 1 - n)) >>> 8 * (r ? n : 1 - n);\n        }\n      }\n\n      function A(t, e, i, r) {\n        e < 0 && (e = 4294967295 + e + 1);\n\n        for (var n = 0, o = Math.min(t.length - i, 4); n < o; ++n) {\n          t[i + n] = e >>> 8 * (r ? n : 3 - n) & 255;\n        }\n      }\n\n      function D(t, e, i, r, n, o) {\n        if (i + r > t.length) throw new RangeError(\"Index out of range\");\n        if (i < 0) throw new RangeError(\"Index out of range\");\n      }\n\n      function j(t, e, i, r, o) {\n        return o || D(t, 0, i, 4), n.write(t, e, i, r, 23, 4), i + 4;\n      }\n\n      function M(t, e, i, r, o) {\n        return o || D(t, 0, i, 8), n.write(t, e, i, r, 52, 8), i + 8;\n      }\n\n      h.prototype.slice = function (t, e) {\n        var i,\n            r = this.length;\n        if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : r < t && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : r < e && (e = r), e < t && (e = t), h.TYPED_ARRAY_SUPPORT) (i = this.subarray(t, e)).__proto__ = h.prototype;else {\n          var n = e - t;\n          i = new h(n, void 0);\n\n          for (var o = 0; o < n; ++o) {\n            i[o] = this[o + t];\n          }\n        }\n        return i;\n      }, h.prototype.readUIntLE = function (t, e, i) {\n        t |= 0, e |= 0, i || E(t, e, this.length);\n\n        for (var r = this[t], n = 1, o = 0; ++o < e && (n *= 256);) {\n          r += this[t + o] * n;\n        }\n\n        return r;\n      }, h.prototype.readUIntBE = function (t, e, i) {\n        t |= 0, e |= 0, i || E(t, e, this.length);\n\n        for (var r = this[t + --e], n = 1; 0 < e && (n *= 256);) {\n          r += this[t + --e] * n;\n        }\n\n        return r;\n      }, h.prototype.readUInt8 = function (t, e) {\n        return e || E(t, 1, this.length), this[t];\n      }, h.prototype.readUInt16LE = function (t, e) {\n        return e || E(t, 2, this.length), this[t] | this[t + 1] << 8;\n      }, h.prototype.readUInt16BE = function (t, e) {\n        return e || E(t, 2, this.length), this[t] << 8 | this[t + 1];\n      }, h.prototype.readUInt32LE = function (t, e) {\n        return e || E(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];\n      }, h.prototype.readUInt32BE = function (t, e) {\n        return e || E(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);\n      }, h.prototype.readIntLE = function (t, e, i) {\n        t |= 0, e |= 0, i || E(t, e, this.length);\n\n        for (var r = this[t], n = 1, o = 0; ++o < e && (n *= 256);) {\n          r += this[t + o] * n;\n        }\n\n        return (n *= 128) <= r && (r -= Math.pow(2, 8 * e)), r;\n      }, h.prototype.readIntBE = function (t, e, i) {\n        t |= 0, e |= 0, i || E(t, e, this.length);\n\n        for (var r = e, n = 1, o = this[t + --r]; 0 < r && (n *= 256);) {\n          o += this[t + --r] * n;\n        }\n\n        return (n *= 128) <= o && (o -= Math.pow(2, 8 * e)), o;\n      }, h.prototype.readInt8 = function (t, e) {\n        return e || E(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];\n      }, h.prototype.readInt16LE = function (t, e) {\n        e || E(t, 2, this.length);\n        var i = this[t] | this[t + 1] << 8;\n        return 32768 & i ? 4294901760 | i : i;\n      }, h.prototype.readInt16BE = function (t, e) {\n        e || E(t, 2, this.length);\n        var i = this[t + 1] | this[t] << 8;\n        return 32768 & i ? 4294901760 | i : i;\n      }, h.prototype.readInt32LE = function (t, e) {\n        return e || E(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;\n      }, h.prototype.readInt32BE = function (t, e) {\n        return e || E(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];\n      }, h.prototype.readFloatLE = function (t, e) {\n        return e || E(t, 4, this.length), n.read(this, t, !0, 23, 4);\n      }, h.prototype.readFloatBE = function (t, e) {\n        return e || E(t, 4, this.length), n.read(this, t, !1, 23, 4);\n      }, h.prototype.readDoubleLE = function (t, e) {\n        return e || E(t, 8, this.length), n.read(this, t, !0, 52, 8);\n      }, h.prototype.readDoubleBE = function (t, e) {\n        return e || E(t, 8, this.length), n.read(this, t, !1, 52, 8);\n      }, h.prototype.writeUIntLE = function (t, e, i, r) {\n        t = +t, e |= 0, i |= 0, r || k(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);\n        var n = 1,\n            o = 0;\n\n        for (this[e] = 255 & t; ++o < i && (n *= 256);) {\n          this[e + o] = t / n & 255;\n        }\n\n        return e + i;\n      }, h.prototype.writeUIntBE = function (t, e, i, r) {\n        t = +t, e |= 0, i |= 0, r || k(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);\n        var n = i - 1,\n            o = 1;\n\n        for (this[e + n] = 255 & t; 0 <= --n && (o *= 256);) {\n          this[e + n] = t / o & 255;\n        }\n\n        return e + i;\n      }, h.prototype.writeUInt8 = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 1, 255, 0), h.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;\n      }, h.prototype.writeUInt16LE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : P(this, t, e, !0), e + 2;\n      }, h.prototype.writeUInt16BE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : P(this, t, e, !1), e + 2;\n      }, h.prototype.writeUInt32LE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : A(this, t, e, !0), e + 4;\n      }, h.prototype.writeUInt32BE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : A(this, t, e, !1), e + 4;\n      }, h.prototype.writeIntLE = function (t, e, i, r) {\n        if (t = +t, e |= 0, !r) {\n          var n = Math.pow(2, 8 * i - 1);\n          k(this, t, e, i, n - 1, -n);\n        }\n\n        var o = 0,\n            s = 1,\n            a = 0;\n\n        for (this[e] = 255 & t; ++o < i && (s *= 256);) {\n          t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255;\n        }\n\n        return e + i;\n      }, h.prototype.writeIntBE = function (t, e, i, r) {\n        if (t = +t, e |= 0, !r) {\n          var n = Math.pow(2, 8 * i - 1);\n          k(this, t, e, i, n - 1, -n);\n        }\n\n        var o = i - 1,\n            s = 1,\n            a = 0;\n\n        for (this[e + o] = 255 & t; 0 <= --o && (s *= 256);) {\n          t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255;\n        }\n\n        return e + i;\n      }, h.prototype.writeInt8 = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 1, 127, -128), h.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;\n      }, h.prototype.writeInt16LE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : P(this, t, e, !0), e + 2;\n      }, h.prototype.writeInt16BE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : P(this, t, e, !1), e + 2;\n      }, h.prototype.writeInt32LE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 4, 2147483647, -2147483648), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : A(this, t, e, !0), e + 4;\n      }, h.prototype.writeInt32BE = function (t, e, i) {\n        return t = +t, e |= 0, i || k(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : A(this, t, e, !1), e + 4;\n      }, h.prototype.writeFloatLE = function (t, e, i) {\n        return j(this, t, e, !0, i);\n      }, h.prototype.writeFloatBE = function (t, e, i) {\n        return j(this, t, e, !1, i);\n      }, h.prototype.writeDoubleLE = function (t, e, i) {\n        return M(this, t, e, !0, i);\n      }, h.prototype.writeDoubleBE = function (t, e, i) {\n        return M(this, t, e, !1, i);\n      }, h.prototype.copy = function (t, e, i, r) {\n        if (i || (i = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), 0 < r && r < i && (r = i), r === i) return 0;\n        if (0 === t.length || 0 === this.length) return 0;\n        if (e < 0) throw new RangeError(\"targetStart out of bounds\");\n        if (i < 0 || i >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n        if (r < 0) throw new RangeError(\"sourceEnd out of bounds\");\n        r > this.length && (r = this.length), t.length - e < r - i && (r = t.length - e + i);\n        var n,\n            o = r - i;\n        if (this === t && i < e && e < r) for (n = o - 1; 0 <= n; --n) {\n          t[n + e] = this[n + i];\n        } else if (o < 1e3 || !h.TYPED_ARRAY_SUPPORT) for (n = 0; n < o; ++n) {\n          t[n + e] = this[n + i];\n        } else Uint8Array.prototype.set.call(t, this.subarray(i, i + o), e);\n        return o;\n      }, h.prototype.fill = function (t, e, i, r) {\n        if (\"string\" == typeof t) {\n          if (\"string\" == typeof e ? (r = e, e = 0, i = this.length) : \"string\" == typeof i && (r = i, i = this.length), 1 === t.length) {\n            var n = t.charCodeAt(0);\n            n < 256 && (t = n);\n          }\n\n          if (void 0 !== r && \"string\" != typeof r) throw new TypeError(\"encoding must be a string\");\n          if (\"string\" == typeof r && !h.isEncoding(r)) throw new TypeError(\"Unknown encoding: \" + r);\n        } else \"number\" == typeof t && (t &= 255);\n\n        if (e < 0 || this.length < e || this.length < i) throw new RangeError(\"Out of range index\");\n        if (i <= e) return this;\n        var o;\n        if (e >>>= 0, i = void 0 === i ? this.length : i >>> 0, t || (t = 0), \"number\" == typeof t) for (o = e; o < i; ++o) {\n          this[o] = t;\n        } else {\n          var s = h.isBuffer(t) ? t : L(new h(t, r).toString()),\n              a = s.length;\n\n          for (o = 0; o < i - e; ++o) {\n            this[o + e] = s[o % a];\n          }\n        }\n        return this;\n      };\n      var F = /[^+\\/0-9A-Za-z-_]/g;\n\n      function I(t) {\n        return t < 16 ? \"0\" + t.toString(16) : t.toString(16);\n      }\n\n      function L(t, e) {\n        var i;\n        e = e || 1 / 0;\n\n        for (var r = t.length, n = null, o = [], s = 0; s < r; ++s) {\n          if (55295 < (i = t.charCodeAt(s)) && i < 57344) {\n            if (!n) {\n              if (56319 < i) {\n                -1 < (e -= 3) && o.push(239, 191, 189);\n                continue;\n              }\n\n              if (s + 1 === r) {\n                -1 < (e -= 3) && o.push(239, 191, 189);\n                continue;\n              }\n\n              n = i;\n              continue;\n            }\n\n            if (i < 56320) {\n              -1 < (e -= 3) && o.push(239, 191, 189), n = i;\n              continue;\n            }\n\n            i = 65536 + (n - 55296 << 10 | i - 56320);\n          } else n && -1 < (e -= 3) && o.push(239, 191, 189);\n\n          if (n = null, i < 128) {\n            if ((e -= 1) < 0) break;\n            o.push(i);\n          } else if (i < 2048) {\n            if ((e -= 2) < 0) break;\n            o.push(i >> 6 | 192, 63 & i | 128);\n          } else if (i < 65536) {\n            if ((e -= 3) < 0) break;\n            o.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128);\n          } else {\n            if (!(i < 1114112)) throw new Error(\"Invalid code point\");\n            if ((e -= 4) < 0) break;\n            o.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128);\n          }\n        }\n\n        return o;\n      }\n\n      function R(t) {\n        return r.toByteArray(function (t) {\n          var e;\n          if ((t = (e = t, e.trim ? e.trim() : e.replace(/^\\s+|\\s+$/g, \"\")).replace(F, \"\")).length < 2) return \"\";\n\n          for (; t.length % 4 != 0;) {\n            t += \"=\";\n          }\n\n          return t;\n        }(t));\n      }\n\n      function B(t, e, i, r) {\n        for (var n = 0; n < r && !(n + i >= e.length || n >= t.length); ++n) {\n          e[n + i] = t[n];\n        }\n\n        return n;\n      }\n    }).call(this, i(20));\n  }, function (XLa, YLa) {\n    var ZLa;\n\n    ZLa = function () {\n      return this;\n    }();\n\n    try {\n      ZLa = ZLa || Function(\"return this\")() || eval(\"this\");\n    } catch (t) {\n      \"object\" == typeof window && (ZLa = window);\n    }\n\n    XLa.exports = ZLa;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    e.byteLength = function (t) {\n      var e = c(t),\n          i = e[0],\n          r = e[1];\n      return 3 * (i + r) / 4 - r;\n    }, e.toByteArray = function (t) {\n      for (var e, i = c(t), r = i[0], s = i[1], a = new o(3 * (r + (f = s)) / 4 - f), h = 0, l = 0 < s ? r - 4 : r, u = 0; u < l; u += 4) {\n        e = n[t.charCodeAt(u)] << 18 | n[t.charCodeAt(u + 1)] << 12 | n[t.charCodeAt(u + 2)] << 6 | n[t.charCodeAt(u + 3)], a[h++] = e >> 16 & 255, a[h++] = e >> 8 & 255, a[h++] = 255 & e;\n      }\n\n      var f;\n      return 2 === s && (e = n[t.charCodeAt(u)] << 2 | n[t.charCodeAt(u + 1)] >> 4, a[h++] = 255 & e), 1 === s && (e = n[t.charCodeAt(u)] << 10 | n[t.charCodeAt(u + 1)] << 4 | n[t.charCodeAt(u + 2)] >> 2, a[h++] = e >> 8 & 255, a[h++] = 255 & e), a;\n    }, e.fromByteArray = function (t) {\n      for (var e, i = t.length, n = i % 3, o = [], s = 0, a = i - n; s < a; s += 16383) {\n        o.push(l(t, s, a < s + 16383 ? a : s + 16383));\n      }\n\n      return 1 === n ? (e = t[i - 1], o.push(r[e >> 2] + r[e << 4 & 63] + \"==\")) : 2 === n && (e = (t[i - 2] << 8) + t[i - 1], o.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + \"=\")), o.join(\"\");\n    };\n\n    for (var r = [], n = [], o = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", a = 0, h = s.length; a < h; ++a) {\n      r[a] = s[a], n[s.charCodeAt(a)] = a;\n    }\n\n    function c(t) {\n      var e = t.length;\n      if (0 < e % 4) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      var i = t.indexOf(\"=\");\n      return -1 === i && (i = e), [i, i === e ? 0 : 4 - i % 4];\n    }\n\n    function l(t, e, i) {\n      for (var n, o, s = [], a = e; a < i; a += 3) {\n        n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), s.push(r[(o = n) >> 18 & 63] + r[o >> 12 & 63] + r[o >> 6 & 63] + r[63 & o]);\n      }\n\n      return s.join(\"\");\n    }\n\n    n[\"-\".charCodeAt(0)] = 62, n[\"_\".charCodeAt(0)] = 63;\n  }, function (t, e) {\n    e.read = function (t, e, i, r, n) {\n      var o,\n          s,\n          a = 8 * n - r - 1,\n          h = (1 << a) - 1,\n          c = h >> 1,\n          l = -7,\n          u = i ? n - 1 : 0,\n          f = i ? -1 : 1,\n          d = t[e + u];\n\n      for (u += f, o = d & (1 << -l) - 1, d >>= -l, l += a; 0 < l; o = 256 * o + t[e + u], u += f, l -= 8) {\n        ;\n      }\n\n      for (s = o & (1 << -l) - 1, o >>= -l, l += r; 0 < l; s = 256 * s + t[e + u], u += f, l -= 8) {\n        ;\n      }\n\n      if (0 === o) o = 1 - c;else {\n        if (o === h) return s ? NaN : 1 / 0 * (d ? -1 : 1);\n        s += Math.pow(2, r), o -= c;\n      }\n      return (d ? -1 : 1) * s * Math.pow(2, o - r);\n    }, e.write = function (t, e, i, r, n, o) {\n      var s,\n          a,\n          h,\n          c = 8 * o - n - 1,\n          l = (1 << c) - 1,\n          u = l >> 1,\n          f = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          d = r ? 0 : o - 1,\n          g = r ? 1 : -1,\n          p = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e) / Math.LN2), e * (h = Math.pow(2, -s)) < 1 && (s--, h *= 2), 2 <= (e += 1 <= s + u ? f / h : f * Math.pow(2, 1 - u)) * h && (s++, h /= 2), l <= s + u ? (a = 0, s = l) : 1 <= s + u ? (a = (e * h - 1) * Math.pow(2, n), s += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, n), s = 0)); 8 <= n; t[i + d] = 255 & a, d += g, a /= 256, n -= 8) {\n        ;\n      }\n\n      for (s = s << n | a, c += n; 0 < c; t[i + d] = 255 & s, d += g, s /= 256, c -= 8) {\n        ;\n      }\n\n      t[i + d - g] |= 128 * p;\n    };\n  }, function (t, e) {\n    var i = {}.toString;\n\n    t.exports = Array.isArray || function (t) {\n      return \"[object Array]\" == i.call(t);\n    };\n  }, function (t, e) {\n    t.exports = f;\n  }, function (t, e) {}, function (t, e) {}, function (t, e) {}, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e);\n\n    var r = i(8),\n        n = i.n(r),\n        o = i(1),\n        s = i.n(o),\n        a = i(3),\n        h = i.n(a),\n        c = i(4),\n        l = i.n(c),\n        u = i(5),\n        f = i.n(u),\n        d = i(7),\n        g = i.n(d),\n        p = i(0),\n        v = i.n(p),\n        m = i(2),\n        y = i.n(m),\n        _ = function () {\n      function t() {\n        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10,\n            i = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];\n        s()(this, t), this.undoLimit = e, this.undoList = [], this.redoList = [], this.current = null, this.debug = i;\n      }\n\n      return y()(t, [{\n        key: \"getUndoLimit\",\n        value: function value() {\n          return this.undoLimit;\n        }\n      }, {\n        key: \"getCurrent\",\n        value: function value() {\n          return this.current;\n        }\n      }, {\n        key: \"keep\",\n        value: function value(t) {\n          try {\n            this.redoList = [], this.current && this.undoList.push(this.current), this.undoList.length > this.undoLimit && this.undoList.shift(), this.current = t;\n          } finally {\n            this.print();\n          }\n        }\n      }, {\n        key: \"undo\",\n        value: function value() {\n          try {\n            return this.current && (this.redoList.push(this.current), this.redoList.length > this.undoLimit && this.redoList.shift(), 0 === this.undoList.length && (this.current = null)), 0 < this.undoList.length ? (this.current = this.undoList.pop(), this.current) : null;\n          } finally {\n            this.print();\n          }\n        }\n      }, {\n        key: \"redo\",\n        value: function value() {\n          try {\n            return 0 < this.redoList.length ? (this.current && this.undoList.push(this.current), this.current = this.redoList.pop(), this.current) : null;\n          } finally {\n            this.print();\n          }\n        }\n      }, {\n        key: \"canRedo\",\n        value: function value() {\n          return 0 < this.redoList.length;\n        }\n      }, {\n        key: \"canUndo\",\n        value: function value() {\n          return 0 < this.undoList.length || null !== this.current;\n        }\n      }, {\n        key: \"clear\",\n        value: function value() {\n          this.undoList = [], this.redoList = [], this.current = null, this.print();\n        }\n      }, {\n        key: \"print\",\n        value: function value() {\n          this.debug && console.log(this.undoList, \" -> \" + this.current + \" <- \", this.redoList.slice(0).reverse());\n        }\n      }]), t;\n    }(),\n        b = function () {\n      function t(e) {\n        s()(this, t), this._canvas = e;\n      }\n\n      return y()(t, [{\n        key: \"configureCanvas\",\n        value: function value(t) {}\n      }, {\n        key: \"doMouseUp\",\n        value: function value(t) {}\n      }, {\n        key: \"doMouseDown\",\n        value: function value(t) {}\n      }, {\n        key: \"doMouseMove\",\n        value: function value(t) {}\n      }, {\n        key: \"doMouseOut\",\n        value: function value(t) {}\n      }]), t;\n    }(),\n        x = function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          var e = this._canvas;\n          e.isDrawingMode = !1, e.selection = !0, e.forEachObject(function (t) {\n            t.selectable = t.evented = !0;\n          });\n        }\n      }]), e;\n    }(b),\n        C = function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          this._canvas.isDrawingMode = !0, this._canvas.freeDrawingBrush.width = t.lineWidth, this._canvas.freeDrawingBrush.color = t.lineColor;\n        }\n      }]), e;\n    }(b),\n        S = i(6).fabric,\n        w = function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          var e = this._canvas;\n          e.isDrawingMode = e.selection = !1, e.forEachObject(function (t) {\n            return t.selectable = t.evented = !1;\n          }), this._width = t.lineWidth, this._color = t.lineColor;\n        }\n      }, {\n        key: \"doMouseDown\",\n        value: function value(t) {\n          this.isDown = !0;\n          var e = this._canvas,\n              i = e.getPointer(t.e),\n              r = [i.x, i.y, i.x, i.y];\n          this.line = new S.Line(r, {\n            strokeWidth: this._width,\n            fill: this._color,\n            stroke: this._color,\n            originX: \"center\",\n            originY: \"center\",\n            selectable: !1,\n            evented: !1\n          }), e.add(this.line);\n        }\n      }, {\n        key: \"doMouseMove\",\n        value: function value(t) {\n          if (this.isDown) {\n            var e = this._canvas,\n                i = e.getPointer(t.e);\n            this.line.set({\n              x2: i.x,\n              y2: i.y\n            }), this.line.setCoords(), e.renderAll();\n          }\n        }\n      }, {\n        key: \"doMouseUp\",\n        value: function value(t) {\n          this.isDown = !1;\n        }\n      }, {\n        key: \"doMouseOut\",\n        value: function value(t) {\n          this.isDown = !1;\n        }\n      }]), e;\n    }(b),\n        T = i(6).fabric,\n        O = function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          var e = this._canvas;\n          e.isDrawingMode = e.selection = !1, e.forEachObject(function (t) {\n            return t.selectable = t.evented = !1;\n          }), this._width = t.lineWidth, this._color = t.lineColor, this._fill = t.fillColor;\n        }\n      }, {\n        key: \"doMouseDown\",\n        value: function value(t) {\n          var e = this._canvas;\n          this.isDown = !0;\n          var i = e.getPointer(t.e);\n          this.startX = i.x, this.startY = i.y, this.rect = new T.Rect({\n            left: this.startX,\n            top: this.startY,\n            originX: \"left\",\n            originY: \"top\",\n            width: i.x - this.startX,\n            height: i.y - this.startY,\n            stroke: this._color,\n            strokeWidth: this._width,\n            fill: this._fill,\n            transparentCorners: !1,\n            selectable: !1,\n            evented: !1,\n            angle: 0\n          }), e.add(this.rect);\n        }\n      }, {\n        key: \"doMouseMove\",\n        value: function value(t) {\n          if (this.isDown) {\n            var e = this._canvas,\n                i = e.getPointer(t.e);\n            this.startX > i.x && this.rect.set({\n              left: Math.abs(i.x)\n            }), this.startY > i.y && this.rect.set({\n              top: Math.abs(i.y)\n            }), this.rect.set({\n              width: Math.abs(this.startX - i.x)\n            }), this.rect.set({\n              height: Math.abs(this.startY - i.y)\n            }), this.rect.setCoords(), e.renderAll();\n          }\n        }\n      }, {\n        key: \"doMouseUp\",\n        value: function value(t) {\n          this.isDown = !1;\n        }\n      }]), e;\n    }(b),\n        E = i(6).fabric,\n        k = function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          var e = this._canvas;\n          e.isDrawingMode = e.selection = !1, e.forEachObject(function (t) {\n            return t.selectable = t.evented = !1;\n          }), this._width = t.lineWidth, this._color = t.lineColor, this._fill = t.fillColor;\n        }\n      }, {\n        key: \"doMouseDown\",\n        value: function value(t) {\n          var e = this._canvas;\n          this.isDown = !0;\n          var i = e.getPointer(t.e),\n              r = [i.x, i.y];\n          this.startX = r[0], this.startY = r[1], this.circle = new E.Circle({\n            left: this.startX,\n            top: this.startY,\n            originX: \"left\",\n            originY: \"center\",\n            strokeWidth: this._width,\n            stroke: this._color,\n            fill: this._fill,\n            selectable: !1,\n            evented: !1,\n            radius: 1\n          }), e.add(this.circle);\n        }\n      }, {\n        key: \"doMouseMove\",\n        value: function value(t) {\n          if (this.isDown) {\n            var e,\n                i,\n                r,\n                n,\n                o = this._canvas,\n                s = o.getPointer(t.e);\n            this.circle.set({\n              radius: (e = {\n                x: this.startX,\n                y: this.startY\n              }, i = {\n                x: s.x,\n                y: s.y\n              }, r = i.x - e.x, n = i.y - e.y, Math.sqrt(r * r + n * n) / 2),\n              angle: 180 * Math.atan2(s.y - this.startY, s.x - this.startX) / Math.PI\n            }), this.circle.setCoords(), o.renderAll();\n          }\n        }\n      }, {\n        key: \"doMouseUp\",\n        value: function value(t) {\n          this.isDown = !1;\n        }\n      }]), e;\n    }(b),\n        P = (i(6).fabric, function (t) {\n      function e() {\n        return s()(this, e), h()(this, l()(e).apply(this, arguments));\n      }\n\n      return f()(e, t), y()(e, [{\n        key: \"configureCanvas\",\n        value: function value(t) {\n          var e = this._canvas;\n          e.isDrawingMode = e.selection = !1, e.forEachObject(function (t) {\n            return t.selectable = t.evented = !1;\n          }), e.defaultCursor = \"move\";\n        }\n      }, {\n        key: \"doMouseDown\",\n        value: function value(t) {\n          var e = this._canvas;\n          this.isDown = !0;\n          var i = e.getPointer(t.e);\n          this.startX = i.x, this.startY = i.y;\n        }\n      }, {\n        key: \"doMouseMove\",\n        value: function value(t) {\n          if (this.isDown) {\n            var e = this._canvas,\n                i = e.getPointer(t.e);\n            e.relativePan({\n              x: i.x - this.startX,\n              y: i.y - this.startY\n            }), e.renderAll();\n          }\n        }\n      }, {\n        key: \"doMouseUp\",\n        value: function value(t) {\n          this.isDown = !1;\n        }\n      }]), e;\n    }(b)),\n        A = {\n      Circle: \"circle\",\n      Line: \"line\",\n      Pencil: \"pencil\",\n      Rectangle: \"rectangle\",\n      Select: \"select\",\n      Pan: \"pan\"\n    },\n        D = i(6).fabric,\n        j = function (t) {\n      function e() {\n        var t, i;\n        s()(this, e);\n\n        for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++) {\n          o[a] = arguments[a];\n        }\n\n        return (i = h()(this, (t = l()(e)).call.apply(t, [this].concat(o)))).state = {\n          parentWidth: 550,\n          action: !0\n        }, i._initTools = function (t) {\n          i._tools = {}, i._tools[A.Select] = new x(t), i._tools[A.Pencil] = new C(t), i._tools[A.Line] = new w(t), i._tools[A.Rectangle] = new O(t), i._tools[A.Circle] = new k(t), i._tools[A.Pan] = new P(t);\n        }, i.enableTouchScroll = function () {\n          var t = i._fc;\n          t.allowTouchScrolling || (t.allowTouchScrolling = !0);\n        }, i.disableTouchScroll = function () {\n          var t = i._fc;\n          t.allowTouchScrolling && (t.allowTouchScrolling = !1);\n        }, i.addImg = function (t) {\n          var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n              r = i._fc;\n          D.Image.fromURL(t, function (t) {\n            var i = {\n              left: Math.random() * (r.getWidth() - .5 * t.width),\n              top: Math.random() * (r.getHeight() - .5 * t.height),\n              scale: .5\n            };\n            Object.assign(i, e), t.scale(i.scale), t.set({\n              left: i.left,\n              top: i.top\n            }), r.add(t);\n          });\n        }, i._onObjectAdded = function (t) {\n          if (i.state.action) {\n            var e = t.target;\n            e.__version = 1;\n            var r = e.toJSON();\n            e.__originalState = r;\n            var n = JSON.stringify(r);\n\n            i._history.keep([e, n, n]);\n          } else i.setState({\n            action: !0\n          });\n        }, i._onObjectMoving = function (t) {}, i._onObjectScaling = function (t) {}, i._onObjectRotating = function (t) {}, i._onObjectModified = function (t) {\n          var e = t.target;\n          e.__version += 1;\n          var r = JSON.stringify(e.__originalState),\n              n = e.toJSON();\n          e.__originalState = n;\n          var o = JSON.stringify(n);\n\n          i._history.keep([e, r, o]);\n        }, i._onObjectRemoved = function (t) {\n          var e = t.target;\n          e.__removed ? e.__version += 1 : e.__version = 0;\n        }, i._onMouseDown = function (t) {\n          i._selectedTool.doMouseDown(t);\n        }, i._onMouseMove = function (t) {\n          i._selectedTool.doMouseMove(t);\n        }, i._onMouseOut = function (t) {\n          if (i._selectedTool.doMouseOut(t), i.props.onChange) {\n            var e = i.props.onChange;\n            setTimeout(function () {\n              e(t.e);\n            }, 10);\n          }\n        }, i._onMouseUp = function (t) {\n          if (i._selectedTool.doMouseUp(t), i.props.tool !== A.Pencil) {\n            var e = i._fc.getObjects(),\n                r = e[e.length - 1];\n\n            r && 1 === r.__version && (r.__originalState = r.toJSON());\n          }\n\n          if (i.props.onChange) {\n            var n = i.props.onChange;\n            setTimeout(function () {\n              n(t.e);\n            }, 10);\n          }\n        }, i._resize = function (t) {\n          t && t.preventDefault();\n          var e = i.props,\n              r = e.widthCorrection,\n              n = e.heightCorrection,\n              o = i._fc,\n              s = i._container,\n              a = s.offsetWidth,\n              h = s.clientHeight,\n              c = o.getWidth(),\n              l = o.getHeight(),\n              u = ((a - r) / c).toFixed(2),\n              f = ((h - n) / l).toFixed(2);\n\n          if (o.setWidth(a - r), o.setHeight(h - n), o.backgroundImage) {\n            var d = o.backgroundImage;\n            d.width = d.width * u, d.height = d.height * f;\n          }\n\n          var g = o.getObjects();\n\n          for (var p in g) {\n            var v = g[p],\n                m = v.scaleX * u,\n                y = v.scaleY * f,\n                _ = v.left * u,\n                b = v.top * f;\n\n            v.scaleX = m, v.scaleY = y, v.left = _, v.top = b, v.setCoords();\n          }\n\n          i.setState({\n            parentWidth: a\n          }), o.renderAll(), o.calcOffset();\n        }, i._backgroundColor = function (t) {\n          if (t) {\n            var e = i._fc;\n            e.setBackgroundColor(t, function () {\n              return e.renderAll();\n            });\n          }\n        }, i.zoom = function (t) {\n          var e = i._fc,\n              r = e.getObjects();\n\n          for (var n in r) {\n            r[n].scaleX = r[n].scaleX * t, r[n].scaleY = r[n].scaleY * t, r[n].left = r[n].left * t, r[n].top = r[n].top * t, r[n].setCoords();\n          }\n\n          e.renderAll(), e.calcOffset();\n        }, i.undo = function () {\n          var t = i._history,\n              e = t.getCurrent(),\n              r = n()(e, 3),\n              o = r[0],\n              s = r[1];\n          r[2], t.undo(), o.__removed ? i.setState({\n            action: !1\n          }, function () {\n            i._fc.add(o), o.__version -= 1, o.__removed = !1;\n          }) : o.__version <= 1 ? i._fc.remove(o) : (o.__version -= 1, o.setOptions(JSON.parse(s)), o.setCoords(), i._fc.renderAll()), i.props.onChange && i.props.onChange();\n        }, i.redo = function () {\n          var t = i._history;\n\n          if (t.canRedo()) {\n            var e = i._fc,\n                r = t.redo(),\n                o = n()(r, 3),\n                s = o[0],\n                a = (o[1], o[2]);\n            0 === s.__version ? i.setState({\n              action: !1\n            }, function () {\n              e.add(s), s.__version = 1;\n            }) : (s.__version += 1, s.setOptions(JSON.parse(a))), s.setCoords(), e.renderAll(), i.props.onChange && i.props.onChange();\n          }\n        }, i.canUndo = function () {\n          return i._history.canUndo();\n        }, i.canRedo = function () {\n          return i._history.canRedo();\n        }, i.toDataURL = function (t) {\n          return i._fc.toDataURL(t);\n        }, i.toJSON = function (t) {\n          return i._fc.toJSON(t);\n        }, i.fromJSON = function (t) {\n          if (t) {\n            var e = i._fc;\n            setTimeout(function () {\n              e.loadFromJSON(t, function () {\n                e.renderAll(), i.props.onChange && i.props.onChange();\n              });\n            }, 100);\n          }\n        }, i.clear = function (t) {\n          var e = i.toJSON(t);\n          return i._fc.clear(), i._history.clear(), e;\n        }, i.removeSelected = function () {\n          var t = i._fc,\n              e = t.getActiveObject();\n\n          if (e) {\n            var r = [];\n            \"activeSelection\" === e.type ? e.forEachObject(function (t) {\n              return r.push(t);\n            }) : r.push(e), r.forEach(function (e) {\n              e.__removed = !0;\n              var r = e.toJSON();\n              e.__originalState = r;\n              var n = JSON.stringify(r);\n              i._history.keep([e, n, n]), t.remove(e);\n            }), t.discardActiveObject(), t.requestRenderAll();\n          }\n        }, i.copy = function () {\n          i._fc.getActiveObject().clone(function (t) {\n            return i._clipboard = t;\n          });\n        }, i.paste = function () {\n          i._clipboard.clone(function (t) {\n            var e = i._fc;\n            e.discardActiveObject(), t.set({\n              left: t.left + 10,\n              top: t.top + 10,\n              evented: !0\n            }), \"activeSelection\" === t.type ? (t.canvas = e, t.forEachObject(function (t) {\n              return e.add(t);\n            }), t.setCoords()) : e.add(t), i._clipboard.top += 10, i._clipboard.left += 10, e.setActiveObject(t), e.requestRenderAll();\n          });\n        }, i.setBackgroundFromDataUrl = function (t) {\n          var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n              r = i._fc;\n          e.stretched && (delete e.stretched, Object.assign(e, {\n            width: r.width,\n            height: r.height\n          })), e.stretchedX && (delete e.stretchedX, Object.assign(e, {\n            width: r.width\n          })), e.stretchedY && (delete e.stretchedY, Object.assign(e, {\n            height: r.height\n          }));\n          var n = new Image();\n          n.onload = function () {\n            return r.setBackgroundImage(new D.Image(n), function () {\n              return r.renderAll();\n            }, e);\n          }, n.src = t;\n        }, i.addText = function (t) {\n          var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n              r = i._fc,\n              n = new D.IText(t, e),\n              o = {\n            left: .5 * (r.getWidth() - n.width),\n            top: .5 * (r.getHeight() - n.height)\n          };\n          Object.assign(e, o), n.set({\n            left: e.left,\n            top: e.top\n          }), r.add(n);\n        }, i.componentDidMount = function () {\n          var t = i.props,\n              e = t.tool,\n              r = t.value,\n              n = t.undoSteps,\n              o = t.defaultValue,\n              s = t.backgroundColor,\n              a = i._fc = new D.Canvas(i._canvas);\n          i._initTools(a), i._backgroundColor(s);\n          var h = i._tools[e];\n          h.configureCanvas(i.props), i._selectedTool = h, window.addEventListener(\"resize\", i._resize, !1), i._history = new _(n), a.on(\"object:added\", i._onObjectAdded), a.on(\"object:modified\", i._onObjectModified), a.on(\"object:removed\", i._onObjectRemoved), a.on(\"mouse:down\", i._onMouseDown), a.on(\"mouse:move\", i._onMouseMove), a.on(\"mouse:up\", i._onMouseUp), a.on(\"mouse:out\", i._onMouseOut), a.on(\"object:moving\", i._onObjectMoving), a.on(\"object:scaling\", i._onObjectScaling), a.on(\"object:rotating\", i._onObjectRotating), i.disableTouchScroll(), i._resize(), (r || o) && i.fromJSON(r || o);\n        }, i.componentWillUnmount = function () {\n          return window.removeEventListener(\"resize\", i._resize);\n        }, i.componentDidUpdate = function (t, e) {\n          i.state.parentWidth === e.parentWidth && i.props.width === t.width && i.props.height === t.height || i._resize(), i.props.tool !== t.tool && (i._selectedTool = i._tools[i.props.tool] || i._tools[A.Pencil]), i._fc.defaultCursor = \"default\", i._selectedTool.configureCanvas(i.props), i.props.backgroundColor !== t.backgroundColor && i._backgroundColor(i.props.backgroundColor), (i.props.value !== t.value || i.props.value && i.props.forceValue) && i.fromJSON(i.props.value);\n        }, i.render = function () {\n          var t = i.props,\n              e = t.className,\n              r = t.style,\n              n = t.width,\n              o = t.height,\n              s = Object.assign({}, r || {}, n ? {\n            width: n\n          } : {}, o ? {\n            height: o\n          } : {\n            height: 512\n          });\n          return g.a.createElement(\"div\", {\n            className: e,\n            ref: function ref(t) {\n              return i._container = t;\n            },\n            style: s\n          }, g.a.createElement(\"canvas\", {\n            id: function () {\n              var t,\n                  e = \"\";\n\n              for (t = 0; t < 32; t += 1) {\n                switch (t) {\n                  case 8:\n                  case 20:\n                    e += \"-\", e += (16 * Math.random() | 0).toString(16);\n                    break;\n\n                  case 12:\n                    e += \"-\", e += \"4\";\n                    break;\n\n                  case 16:\n                    e += \"-\", e += (4 * Math.random() | 8).toString(16);\n                    break;\n\n                  default:\n                    e += (16 * Math.random() | 0).toString(16);\n                }\n              }\n\n              return e;\n            }(),\n            ref: function ref(t) {\n              return i._canvas = t;\n            }\n          }, \"Sorry, Canvas HTML5 element is not supported by your browser :(\"));\n        }, i;\n      }\n\n      return f()(e, t), e;\n    }(d.PureComponent);\n\n    j.propTypes = {\n      lineColor: v.a.string,\n      lineWidth: v.a.number,\n      fillColor: v.a.string,\n      backgroundColor: v.a.string,\n      opacity: v.a.number,\n      undoSteps: v.a.number,\n      tool: v.a.string,\n      imageFormat: v.a.string,\n      value: v.a.object,\n      forceValue: v.a.bool,\n      widthCorrection: v.a.number,\n      heightCorrection: v.a.number,\n      onChange: v.a.func,\n      defaultValue: v.a.object,\n      width: v.a.number,\n      height: v.a.number,\n      className: v.a.string,\n      style: v.a.object\n    }, j.defaultProps = {\n      lineColor: \"black\",\n      lineWidth: 10,\n      fillColor: \"transparent\",\n      backgroundColor: \"transparent\",\n      opacity: 1,\n      undoSteps: 25,\n      tool: A.Pencil,\n      widthCorrection: 2,\n      heightCorrection: 0,\n      forceValue: !1\n    };\n    var M = j;\n    i.d(e, \"SketchField\", function () {\n      return M;\n    }), i.d(e, \"Tools\", function () {\n      return A;\n    }), e.default = {\n      SketchField: M,\n      Tools: A\n    };\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}